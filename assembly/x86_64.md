# Registers

There are two main types of registers we will be focusing on: Data Registers and Pointer Registers.



## Data Registers

Data Registers - are usually used for storing instructions/syscall arguments. The primary data registers are: rax, rbx, rcx, and rdx. The rdi and rsi registers also exist and are usually used for the instruction destination and source operands. Then, we have secondary data registers that can be used when all previous registers are in use, which are r8, r9, and r10.
- rax
- rbx
- rcx
- rdx
- r8 
- r9 	
- r10 	


## Pointer Registers

Pointer Registers - are used to store specific important address pointers. The main pointer registers are the Base Stack Pointer rbp, which points to the beginning of the Stack, the Current Stack Pointer rsp, which points to the current location within the Stack (top of the Stack), and the Instruction Pointer rip, which holds the address of the next instruction.

- rbp
- rsp
- rip


## Sub-Registers

Each 64-bit register can be further divided into smaller sub-registers containing the lower bits, at one byte 8-bits, 2 bytes 16-bits, and 4 bytes 32-bits. Each sub-register can be used and accessed on its own, so we don't have to consume the full 64-bits if we have a smaller amount of data.

|Size in bits |	Size in bytes |	Name |	Example|
|----|-----|-----|-----|
|16-bit |	2 bytes |	the base name |	ax|
|8-bit 	|1 bytes |	base name and/or ends with l |	al|
|32-bit 	|4 bytes |	base name + starts with the e prefix 	|eax|
|64-bit 	|8 bytes |	base name + starts with the r prefix |	rax|



The same goes for pointer registers. If we take the base stack pointer bp, its 16-bit sub-register is bp, so the 8-bit is bpl, the 32-bit is ebp, and the 64-bit is rbp.




|Description |	64-bit Register |	32-bit Register |	16-bit Register |	8-bit Register|
|-------------|-----------------|------------------|-------------------|---------------|
|Data/Arguments Registers| 				
|Syscall Number/Return value| 	rax |	eax| 	ax |	al|
|Callee Saved |	rbx 	|ebx |	bx |	bl|
|1st arg - Destination operand| 	rdi |	edi |	di| 	dil|
|2nd arg - Source operand |	rsi |	esi |	si |	sil|
|3rd arg |	rdx |	edx |	dx| 	dl|
|4th arg - Loop counter| 	rcx| 	ecx| 	cx| 	cl|
|5th arg| 	r8| 	r8d| 	r8w| 	r8b|
|6th arg| 	r9| 	r9d |	r9w |	r9b|
|Pointer Registers| 				
|Base Stack Pointer| 	rbp |	ebp |	bp| 	bpl|
|Current/Top Stack Pointer| 	rsp |	esp |	sp| 	spl|
|Instruction Pointer 'call only'| 	rip |	eip| 	ip |	ipl|


# Memory Addresses

There are several types of address fetching (i.e., addressing modes) in the x86 architecture:

|Addressing Mode |	Description |	Example|
|-------|--------|--------|
Immediate |	The value is given within the instruction |	add 2
Register |	The register name that holds the value is given in the instruction |	add rax
Direct |	The direct full address is given in the instruction |	call 0xffffffffaa8a25ff
Indirect |	A reference pointer is given in the instruction 	|call 0x44d000 or call [rax]
Stack |	Address is on top of the stack |	add rsp


In the above table, lower is slower. The less immediate the value is, the slower it is to fetch it.


## Address Endianness

f we have the address 0x0011223344556677 to be stored in memory, little-endian processors would store the 0x00 byte on the right-most bytes, and then the 0x11 byte would be filled after it, so it becomes 0x1100, and then the 0x22 byte, so it becomes 0x221100, and so on. Once all bytes are in place, they would look like 0x7766554433221100, which is the reverse of the original value. Of course, when retrieving the value back, the processor will also use little-endian retrieval, so the value retrieved would be the same as the original value.



# Data Types

|Component |	Length |	Example|
|------|----------|----------|
|byte |	8 bits |	0xab|
|word |	16 bits - 2 bytes |	0xabcd|
double word (dword) |	32 bits - 4 bytes| 	0xabcdef12
quad word (qword) |	64 bits - 8 bytes| 	0xabcdef1234567890


 The following table shows the appropriate data type for each sub-register:

|Sub-register |	Data Type|
|------|-------|
al |	byte|
ax |	word|
eax |	dword
rax |	qword


# Assembly File Structure

each line can have three elements:
1. Labels 	
2. Instructions 	
3. Operands

we can define a label at each line. Each label can be referred to by instructions or by directives.

```
Example code

         global  _start

         section .data
message: db      "Hello HTB Academy!"

         section .text
_start:
         mov     rax, 1
         mov     rdi, 1
         mov     rsi, message
         mov     rdx, 18
         syscall

         mov     rax, 60
         mov     rdi, 0
         syscall
```

Next, if we look at the example code line-by-line, we see that it has three main parts:

|Section| 	Description|
|----------|--------|
global _start| 	This is a directive that directs the code to start executing at the _start label defined below.
section .data |	This is the data section, which should contain all of the variables.
section .text |	This is the text section containing all of the code to be executed.

## Directives

An Assembly code is line-based, which means that the file is processed line-by-line, executing the instruction of each line. We see at the first line a directive global _start, which instructs the machine to start processing the instructions after the _start label. So, the machine goes to the _start label and starts executing the instructions there, which will print the message on the screen. This will be covered more thoroughly in the Control Instructions sections.

## Variables

Next, we have the .data section. The data section holds our variables to make it easier for us to define variables and reuse them without writing them multiple times. Once we run our program, all of our variables will be loaded into memory in the data segment.

We can define variables using db for a list of bytes, dw for a list of words, dd for a list of digits, and so on. We can also label any of our variables so we can call it or reference it later. The following are some examples of defining variables:

|Instruction |	Description|
|-------|---------|
db 0x0a |	Defines the byte 0x0a, which is a new line.
message db 0x41, 0x42, 0x43, 0x0a 	|Defines the label message => abc\n.
message db "Hello World!", 0x0a 	|Defines the label message => Hello World!\n.


Furthermore, we can use the equ instruction with the $ token to evaluate an expression, like the length of a defined variable's string. However, the labels defined with the equ instruction are constants, and they cannot be changed later.

```
Example code

section .data
    message db "Hello World!", 0x0a
    length  equ $-message
    
Note: the $ token indicates the current distance from the beginning of the current section. As the message variable is at the beginning of the data section, the current location, i.e,. value of $, equals the length of the string.
```

## Code

The second (and most important) section is the .text section. This section holds all of the assembly instructions and loads them to the text memory segment. Once all instructions are loaded into the text segment, the processor starts executing them one after another.

The text segment within the memory is read-only, so we cannot write any variables within it. The data section, on the other hand, is read/write, which is why we write our variables to it. However, the data segment within the memory is not executable, so any code we write to it cannot be executed.

Tip: We can add comments to our assembly code with a semi-colon ;


# Assembling

First, we will copy the  code into a file called filename.s

Note: assembly files usually use the .s or the .asm extensions. 

$ nasm -f elf64 filename.s

! If we wanted to assemble a 32-bit code, we would use -f elf

This should output a filename.o object file, which is then assembled into machine code, along with the details of all variables and sections. This file is not executable just yet.


# Linking

The final step is to link our file using ld. The helloWorld.o object file, though assembled, still cannot be executed. This is because many references and labels used by nasm need to be resolved into actual addresses, along with linking the file with various OS libraries that may be needed.

This is why a Linux binary is called ELF, which stands for an Executable and Linkable Format. To link a file using ld, we can use the following command:

$ ld -o filename filename.o

Note: if we were to assemble a 32-bit binary, we need to add the '-m elf_i386' flag.



```
#Bash script to automate the proccess of assembling and linking


#!/bin/bash

fileName="${1%%.*}" # remove .s extension

nasm -f elf64 ${fileName}".s"
ld ${fileName}".o" -o ${fileName}
[ "$2" == "-g" ] && gdb -q ${fileName} || ./${fileName}

```


# Disassembling

To disassemble a file, we will use the objdump tool, which dumps machine code from a file and interprets the assembly instruction of each hex code. We can disassemble a binary using the -D flag.

Note: we will also use the flag -M intel, so that objdump would write the instructions in the Intel syntax, which we are using, as we discussed before.


$ objdump -M intel -d helloWorld

The -d flag will only disassemble the .text section of our code. To dump any strings, we can use the -s flag, and add -j .data to only examine the .data section. This means that we also do not need to add -M intel.

$ objdump -sj .data helloWorld



# GDB

### Functions

To start, we will use the info command to check which functions are defined within the binary:

gdb$   info functions

### Variables

gdb$   info variables

### Disassemble

gdb$   disas {func_name}


!You may notice through debugging that some memory addresses are in the form of 0x00000000004xxxxx, rather than their raw address in memory 0xffffffffaa8a25ff. This is due to $rip-relative addressing in Position-Independent Executables PIE, in which the memory addresses are used relative to their distance from the instruction pointer $rip within the program's own Virtual RAM, rather than using raw memory addresses. This feature may be disabled to reduce the risk of binary exploitation.

## Debugging 

Debugging consists mainly of four steps:

|Step |	Description|
|------|---------|
Break |	Setting breakpoints at various points of interest
Examine 	|Running the program and examining the state of the program at these points
Step 	|Moving through the program to examine how it acts with each instruction and with user input
Modify |	Modify values in specific registers or addresses at specific breakpoints, to study how it would affect the execution


### Break

The first step of debugging is setting breakpoints to stop the execution at a specific location or when a particular condition is met. We can set a breakpoint at a specific address or for a particular function. To set a breakpoint, we can use the break or b command along with the address or function name we want to break at.

gdb$ b _start

If we want to set a breakpoint at a certain address, like _start+10, we can either b *_start+10 or b *0x40100a
The * tells GDB to break at the instruction stored in 0x40100a

 Once the program is running, if we set another breakpoint, in order to continue to that breakpoint, we should use the continue or c command. If we use run or r again, it will run the program from the start. This can be useful to skip loops, as we will see later in the module.

### Examine

 To manually examine any of the addresses or registers or examine any other, we can use the x command in the format of x/FMT ADDRESS, as help x would tell us. The ADDRESS is the address or register we want to examine, while FMT is the examine format. The examine format FMT can have three parts:

|Argument |	Description |	Example|
|------------|---------|-------|
Count 	|The number of times we want to repeat the examine |	2, 3, 10
Format 	|The format we want the result to be represented in 	|x(hex), s(string), i(instruction)
Size 	|The size of memory we want to examine |	b(byte), h(halfword), w(word), g(giant, 8 bytes)


### Instructions

 if we wanted to examine the next four instructions in line, we will have to examine the $rip register (which holds the address of the next instruction), and use 4 for the count, i for the format, and g for the size (for 8-bytes or 64-bits). So, the final examine command would be x/4ig $rip, as follows:

gdb$  x/3ig $rip

=> 0x401000 <_start>:	mov    eax,0x1
   0x401005 <_start+5>:	mov    edi,0x1
   0x40100a <_start+10>:	movabs rsi,0x402000


### Strings

We can also examine a variable stored at a specific memory address.In this case, we will not put anything for the Count, as we only want one address (1 is the default), and will use s as the format to get it in a string format rather than in hex:

gef$  x/s 0x402000

0x402000:	"Hello HTB Academy!"

### Addresses


The most common format of examining is hex x. We often need to examine addresses and registers containing hex data, such as memory addresses, instructions, or binary data. Let us examine the same previous instruction, but in hex format, to see how it looks:

gef$  x/wx 0x401000

0x401000 <_start>:	0x000001b8

We see instead of mov eax,0x1, we get 0x000001b8, which is the hex representation of the mov eax,0x1 machine code in little-endian formatting.

    This is read as: b8 01 00 00.


### Step

To move through the program, there are three different commands we can use: stepi and step.

The stepi or si command will step through the assembly instructions one by one, which is the smallest level of steps possible while debugging. 

Similarly to examine, we can repeat the si command by adding a number after it. For example, if we wanted to move 3 steps to reach the syscall instruction, we can do so as follows:

gef➤  si 3

Note: There's also the next or n command, which will also continue until the next line, but will skip any functions called in the same line of code, instead of breaking at them like step. There's also the nexti or ni, which is similar to si, but skips functions calls, as we will see later on in the module.


### Modify

The final step of debugging is modifying values in registers and addresses at a certain point of execution. This helps us in seeing how this would affect the execution of the program.

To modify values in GDB, we can use the set command. However, we will utilize the patch command in GEF to make this step much easier. Let's enter help patch in GDB to get its help menu:

gef➤  help patch

As we can see, we have to provide the type/size of the new value, the location to be stored, and the value we want to use. So, let's try changing the string stored in the .data section (at address 0x402000 as we saw earlier) to the string Patched!\n.

We will break at the first syscall at 0x401019, and then do the patch, as follows:

gef➤  break *0x401019

Breakpoint 1 at 0x401019
gef➤  r
gef➤  patch string 0x402000 "Patched!\\x0a"  (  This is replacing strings until the lenght specified)
gef➤  c

Continuing.
Patched!
 Academy!


We see that we successfully modified the string and got Patched!\n Academy! instead of the old string. Notice how we used \x0a for adding a new line after our string.

### Registers

We also note that we did not replace the entire string. This is because we only modified the characters up to the length of our string and left the remainder of the old string. Finally, the printf function specified a length of 0x12 of bytes to be printed.

To fix this, let's modify the value stored in $rdx to the length of our string, which is 0x9. We will only patch a size of one byte. We will go into details of how syscall works later in the module. Let us demonstrate using set to modify $rdx, as follows:


gef➤  break *0x401019

Breakpoint 1 at 0x401019
gef➤  r
gef➤  patch string 0x402000 "Patched!\\x0a"
gef➤  set $rdx=0x9
gef➤  c

Continuing.
Patched!




## Data Movement

The main Data Movement instructions are:

|Instruction |	Description |	Example|
|------------|-------------|-----------|
mov |	Move data or load immediate data |	mov rax, 1 -> rax = 1
lea |	Load an address pointing to the value |	lea rax, [rsp+5] -> rax = rsp+5
xchg |	Swap data between two registers or addresses |	xchg rax, rbx -> rax = rbx, rbx = rax


### Moving Data

Let's use the mov instruction as the very first instructions in our module project fibonacci. We will need to load the initial values (F0=0 and F1=1) to rax and rbx, such that rax = 0 and rbx = 1. Let us copy the following code to a fib.s file:

```
global  _start

section .text
_start:
    mov rax, 0
    mov rbx, 1

```

Like this, we have loaded the initial values into our registers to later perform other operations and instructions on them.

Note: In assembly, moving data does not affect the source operand. So, we can consider mov as a copy function, rather than an actual move.


### Loading Data

We can load immediate data using the mov instruction. For example, we can load the value of 1 into the rax register using the mov rax, 1 instruction. We have to remember here that the size of the loaded data depends on the size of the destination register. For example, in the above mov rax, 1 instruction, since we used the 64-bit register rax, it will be moving a 64-bit representation of the number 1 (i.e. 0x00000001), which is not very efficient.This is why it is more efficient to use a register size that matches our data size. For example, we will get the same result as the above example if we use mov al, 1, since we are moving 1-byte (0x01) into a 1-byte register (al), which is much more efficient. This is evident when we look at the disassembly of both instructions in objdump.

### Address Pointers

Another critical concept to understand is using pointers. In many cases, we would see that the register or address we are using does not immediately contain the final value but contains another address that points to the final value. This is always the case with pointer registers, like rsp, rbp, and rip, but is also used with any other register or memory address.

### Moving Pointer Values

To move the actual value, we will have to use square brackets [], which in x86_64 assembly and Intel syntax means load value at address. So, in the same above example, if we wanted to move the final value rsp is pointing to, we can wrap rsp in square brackets, like mov rax, [rsp], and this mov instruction will move the final value rather than the immediate value (which is an address to the final value).

! We can use square brackets to compute an address offset relative to a register or another address. For example, we can do mov rax, [rsp+10] to move the value stored 10 address away from rsp.

### Loading Value Pointers

Finally, we need to understand how to load a pointer address to a value, using the lea (or Load Effective Address) instruction, which loads a pointer to the specified value, as in lea rax, [rsp]. This is the opposite of what we just learned above (i.e., load pointer to a value vs. move value from pointer).

In some instances, we need to load the address of a value to a certain register rather than directly load the value in that register. This is usually done when the data is large and would not fit in one register, so the data is placed on the stack or in the heap, and a pointer to its location is stored in the register.

First, if we wanted to load a direct pointer to a variable or a label, we can still use mov instructions. Since the variable name is a pointer to where it is located in memory, mov will store this pointer to the destination address. For example, both mov rax, rsp and lea rax, [rsp] will do the same thing of storing the pointer to message at rax.

However, if we wanted to load a pointer with an offset (i.e., a few addresses away from a variable or an address), we should use lea. This is why with lea the source operand is usually a variable, a label, or an address wrapped in square brackets, as in lea rax, [rsp+10]. This enables using offsets (i.e., [rsp+10]).

Note that if we use mov rax, [rsp+10], it will actually move the value at [rsp+10] to rax, as discussed earlier. We cannot move a pointer with an offset using mov.

## Arithmetic Instructions

We will split arithmetic instructions into two types: instructions that take only one operand (Unary), instructions that take two operands (Binary).

### Unary Instructions

The following are the main Unary Arithmetic Instructions (we will assume that rax starts as 1 for each instruction):

|Instruction |	Description |	Example|
|------------|--------------|----------|
inc |	Increment by 1 |	inc rax -> rax++ or rax += 1 -> rax = 2
dec |	Decrement by 1 |	dec rax -> rax-- or rax -= 1 -> rax = 0


Let's practice these instructions by going back to our fib.s code. So far, we have initialized rax and rbx with our initial values 0 and 1 with the mov instruction. Instead of moving the immediate value of 1 to bl, let's move 0 to it, and then use inc to make it 1:

global  _start
section .text
_start:
    mov al, 0
    mov bl, 0
    inc bl


### Binary Instructions

Next, we have Binary Arithmetic Instructions, and the main ones are: We'll assume that both rax and rbx start as 1 for each instruction.

|Instruction |	Description |	Example|
|------------|--------------|----------|
add |	Add both operands 	|add rax, rbx -> rax = 1 + 1 -> 2
sub |	Subtract Source from Destination (i.e rax = rax - rbx) |	sub rax, rbx -> rax = 1 - 1 -> 0
imul |	Multiply both operands |	imul rax, rbx -> rax = 1 * 1 -> 1

Note that in all of the above instructions, the result is always stored in the destination operand, while the source operand is not affected.

 Adding two numbers is the core step of calculating a Fibonacci Sequence, since the current Fibonacci number (Fn) is the sum of the two preceding it (Fn = Fn-1 + Fn-2).

```
global  _start

section .text
_start:
   mov al, 0
   mov bl, 0
   inc bl
   add rax, rbx

```

### Bitwise Instructions

Now, let's move to Bitwise Instructions, which are instructions that work on the bit level (we'll assume that rax = 1 and rbx = 2 for each instruction):


|Instruction |	Description |	Example|
|------------|--------------|----------|
not |	Bitwise NOT (invert all bits, 0->1 and 1->0) |	not rax -> NOT 00000001 -> 11111110
and |	Bitwise AND (if both bits are 1 -> 1, if bits are different -> 0) |	and rax, rbx -> 00000001 AND 00000010 -> 00000000
or 	|Bitwise OR (if either bit is 1 -> 1, if both are 0 -> 0) |	or rax, rbx -> 00000001 OR 00000010 -> 00000011
xor |	Bitwise XOR (if bits are the same -> 0, if bits are different -> 1) 	|xor rax, rbx -> 00000001 XOR 00000010 -> 00000011


The xor instruction has various use cases, but since it zeros similar bits, we can use it to turn any value to 0 by xoring a value with itself. We need to put, using xor on any register with itself will turn it into 0.

For example, if we want to turn the rax register to 0, the most efficient way to do it is xor rax, rax, which will make rax = 0. This is simply because all bits of rax are similar, and so xor will turn all of them to 0. Going back to our previous fib.s code, instead of moving 0 to both rax and rbx, we can use xor on each of them, as follows:


```
global  _start

section .text
_start:
    xor rax, rax
    xor rbx, rbx
    inc rbx
    add rax, rbx


```

## Loops

Assembly code is line-based, so it will always look to the following line for instructions to process. However, as we can expect, most programs do not follow a simple set of sequential steps but usually have a more complex structure.

This is where Control instructions come in. Such instructions allow us to change the flow of the program and direct it to another line. There are many examples of how this can be done. We have already discussed Directives that tell the program to direct the execution to a specific label.

Other types of Control Instructions include:
- Loops 	
- Branching 	
- Function Calls



### Loop Structure

A loop in assembly is a set of instructions that repeat for rcx times. Let's take the following example:

```
exampleLoop:
    instruction 1
    instruction 2
    instruction 3
    instruction 4
    instruction 5
    loop exampleLoop

```

Once the assembly code reaches exampleLoop, it will start executing the instructions under it. We should set the number of iterations we want the loop to go through in the rcx register. Every time the loop reaches the loop instruction, it will decrease rcx by 1 (i.e., dec rcx) and jump back to the specified label, exampleLoop in this case. So, before we enter any loop, we should mov the number of loop iterations we want to the rcx register.



|Instruction |	Description |	Example|
|------------|--------------|--------|
mov rcx, x |	Sets loop (rcx) counter to x |	mov rcx, 3
loop |	Jumps back to the start of loop until counter reaches 0 |	loop exampleLoop


To demonstrate this, let's go back to our fib.s code:

```
global  _start

section .text
_start:
    xor rax, rax
    xor rbx, rbx
    inc rbx
    add rax, rbx

```

Since any current Fibonacci number is the sum of the two numbers preceding it, we can automate this with a loop. Let's assume that the current number is stored in rax, so it is Fn, and the next number is stored in rbx, so it is Fn+1.

Starting with the last number as 0 and the current number as 1, we can have our loop as follows:

-    Get next number with 0 + 1 = 1
-    Move the current number to the last number (1 in place of 0)
-    Move the next number to the current number (1 in place of 1)
-    Loop

If we do this, we'll end up with 1 as the last number and 1 as the current number. If we loop again, we'll get 1 as the last number and 2 as the current number. So, let's implement this as assembly instructions. Since we can discard the last number 0 after we use it in the add, let's store the result in its place:

    add rax, rbx

We need to move the current number to the last number's place and move the following number to the current number. However, we have the following number in rax and the now old number in rbx, so they are swapped. Can you think of any instruction to swap them?

Let's use the xchg instruction to swap both numbers:

    xchg rax, rbx

Now we can simply loop. However, before we enter a loop, we should set rcx to the count of iterations we want. Let's start with 10 iterations and add it after initializing the rax and rbx to 0 and 1:

```
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10

```

Now we can define our loop as discussed above:

```
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    loop loopFib

```

So, our final code is:

```

global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    loop loopFib
    
```


## Unconditional Branching

The second type of Control Instructions is Branching Instructions, which are general instructions that allow us to jump to any point in the program if a specific condition is met.

###  JMP loopFib

The jmp instruction jumps the program to the label or specified location in its operand so that the program's execution is continued there. Once a program's execution is directed to another location, it will continue processing instructions from that point. If we wanted to temporarily jump to a point and then return to the original calling point, we would use functions, which we will discuss in the next section.

The basic jmp instruction is unconditional, which means that it will always jump to the specified location, regardless of the conditions. This contrasts with Conditional Branching instructions that only jump if a specific condition is met, which we'll discuss next.

```


global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    jmp loopFib
    
```

However, the main difference from the loop is that 'rcx' is not decrementing. This is because a jmp instruction does not consider rcx as a counter (like loop does), and so it will not automatically decrement it.

## Conditional Branching

Unlike Unconditional Branching Instructions, Conditional Branching instructions are only processed when a specific condition is met, based on the Destination and Source operands. A conditional jump instruction has multiple varieties as Jcc, where cc represents the Condition Code. The following are some of the main condition codes:

|Instruction |	Condition |	Description|
|------------|-------------|--------------|
jz |	D = 0 |	Destination equal to Zero
jnz |	D != 0 |	Destination Not equal to Zero
js |	D < 0 |	Destination is Negative
jns |	D >= 0 |	Destination is Not Negative (i.e. 0 or positive)
jg |	D > S |	Destination Greater than Source
jge |	D >= S |	Destination Greater than or Equal Source
jl |	D < S |	Destination Less than Source
jle |	D <= S |	Destination Less than or Equal Source


For example, if we wanted to perform a mov rax, rbx instruction, but only if the condition is = 0, then we can use the CMOVcc or conditional mov instruction, such as cmovz rax, rbx instruction. Similarly, if we wanted to move if the condition is <, then we can use the cmovl rax, rbx instruction, and so on for other conditions. The same applies to the set instruction, which sets the operand's byte to 1 if the condition is met or 0 otherwise. An example of this is setz rax.


### RFLAGS Register

Arithmetic instructions set the necessary 'RFLAG' bits depending on their outcome. For example, if a dec instruction resulted in a 0, then bit #6, the Zero Flag ZF, turns to 1. Likewise, whenever the bit #6 is 0, it means that the Zero Flag is off. Similarly, if a division instruction results in a float number, then the Carry Flag CF bit is turned on, or if a sub instruction resulted in a negative value, then the Sign Flag SF is turned on, and so on.

Note: When ZF is on (i.e. is 1), it's referred to as Zero ZR, and when it's off (i.e. is 0), it's referred to as Not Zero NZ. This naming may match the condition code used in the instructions, like jnz which jumps with NZ. But to avoid any confusion, let's simply focus on the flag name.



|Bit(s) 	|0| 	1| 	2| 	3| 	4| 	5| 	6| 	7| 	8| 	9 |	10| 	11| 	12-13| 	14| 	15| 	16| 	17| 	18| 	19| 	20| 	21| 	22-63|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|----|
Label (1/0) |	CF (CY/NC) |	1 |	PF (PE/PO) |0 	|AF (AC/NA) |	0 	|ZF (ZR/NZ) |	SF (NC/PL)| 	TF |	IF (EL/DI)| 	DF (DN/UP)| 	OF (OV/NV) |	IOPL| 	NT |	0 |	RF |	VM| 	AC |	VIF |	VIP |	ID |	0|
Description |	Carry Flag |	Reserved |	Parity Flag |	Reserved |	Auxiliary Carry Flag |	Reserved |	Zero Flag |	Sign Flag |	Trap Flag |	Interrupt Flag |	Direction Flag 	|Overflow Flag |	I/O Privilege Level |	Nested Task |	Reserved |	Resume Flag |	Virtual-x86 Mode |	Alignment Check / Access Control |	Virtual Interrupt Flag| 	Virtual Interrupt Pending |	Identification Flag 	|Reserved|


Just like other registers, the 64-bit RFLAGS register has a 32-bit sub-register called EFLAGS, and a 16-bit sub-register called FLAGS, which holds the most significant flags we may encounter.
The flags we would mostly be interested in are:

    The Carry Flag CF: Indicates whether we have a float.
    The Parity Flag PF: Indicates whether a number is odd or even.
    The Zero Flag ZF: Indicates whether a number is zero.
    The Sign Flag SF: Indicates whether a register is negative.



### JNZ loopFib

The loop loopFib instruction we used in the last section is, in fact, a combination of two instructions: dec rcx and jnz loopFib, but since looping is a very common function, the loop instruction was created to reduce code size and be more efficient, instead of using both every time. However, the conditional jump instructions are much more versatile than loop, since they allow us to jump anywhere in the program on any condition we require.


```
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    dec rcx			; decrement rcx counter
    jnz loopFib		; jump to loopFib until rcx is 0
    
```

 Once rcx reaches 0, the Zero Flag ZF would be turned on to 1, and so jnz would no longer jump (since it's NZ), and we would exit the loop.

### CMP

There are other cases where we may want to use a conditional jump instruction within our module project. For example, we may want to stop the program execution when the Fibonacci number is more than 10. We can do so by using the js loopFib instruction, which would jump back to loopFib as long as the last arithmetic instruction resulted in a positive number.

In this case, we will not use the jnz instruction or the rcx register but will use js instead directly after calculating the current Fibonacci number. But how would we test if the current Fibonacci number (i.e., rbx) is less than 10? This is where we come to the Compare instruction cmp.

The Compare instruction cmp simply compares the two operands, by subtracting the second operand from first operand (i.e. D1 - S2), and then sets the necessary flags in the RFLAGS register. For example, if we use cmp rbx, 10, then the compare instruction would do 'rbx - 10', and set the flags based on the result.

So, after the first Fibonacci number is calculated, it will do '1 - 10', and the result would be -9, so it will jump since it's a negative number <0. Once we reach the first Fibonacci number greater than 10, which is 13 or 0xd, it will do '13 - 10', and the result would be '3', at which case js would no longer jump, as the result is a positive number >=0.

We could use sub instructions to perform the same subtraction and set the flags if we wanted. However, this would not be efficient, as we will be changing the value of one of the registers, while the cmp only compares and does not store the result anywhere. The main advantage of 'cmp' is that it does not affect the operands.

Note: In a cmp instruction, the first operand (i.e. the Destination) must be a register, while the other can be a register, a variable, or an immediate value.

```

global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    cmp rbx, 10		; do rbx - 10
    js loopFib		; jump if result is <0


```

Now, let's continue until rbx is greater than 10, at which point js should no longer jump. Instead of manually pressing c several times, let's take this opportunity to learn how to set conditional breakpoints in gdb.

Let's first delete the current breakpoint with del 1, and then set our conditional breakpoint. The syntax is very similar to setting regular breakpoints b loopFib, but we add an if condition after it, such as 'b loopFib if $rbx > 10'. Also, instead of breaking at loopFib and then using si to reach js, let's directly break at js with * to refer to its location 'b *loopFib+9 if $rbx > 10' or 'b *0x401012 if $rbx > 10'.
Remember: we can find an instruction's location with disas loopFib.

As we can see, using conditional branching is very powerful and enables us to perform more advanced instructions based on a condition we specify. We can use the cmp instruction to test various conditions. For example, we can use jl instead of jns, which would jump as long as the Destination is Less than the Source. So, with cmp rbx, 10, rbx will start less than 10, and once rbx gets greater than 10, then rbx (i.e., the Destination) would be greater than 10, at which point jl will not jump.


# Using the Stack

The stack is a segment of memory allocated for the program to store data in, and it is usually used to store data and then retrieve them back temporarily. The top of the stack is referred to by the Top Stack Pointer rsp, while the bottom is referred to by the Base Stack Pointer rbp.

We can push data into the stack, and it will be at the top of the stack (i.e. rsp), and then we can pop data out of the stack into a register or a memory address, and it will be removed from the top of the stack.

|Instruction |	Description |	Example|
|-----------|-------------|------------|
push 	|Copies the specified register/address to the top of the stack |	push rax
pop |	Moves the item at the top of the stack to the specified register/address 	|pop rax


The stack has a Last-in First-out (LIFO) design, which means we can only pop out the last element pushed into the stack. For example, if we push rax into the stack, the top of the stack would now be the value of rax we just pushed. If we push anything on top of it, we would have to pop them out of the stack until that value of rax reaches the top of the stack, then we can pop that value back to rax.


### Usage With Functions/Syscalls

We will primarily be pushing data from registers into the stack before we call a function or call a syscall, and then restore them after the function and the syscall. This is because functions and syscalls usually use the registers for their processing, and so if the values stored in the registers will get changed after a function call or a syscall, we will lose them.

For example, if we wanted to call a syscall to print Hello World to the screen and retain the current value stored in rax, we would push rax into the stack. Then we can execute the syscall and afterward pop the value back to rax. So, this way, we would be able to both execute the syscall and retain the value of rax.

To push value into the stack, we can use its name as the operand, as in push rax, and the value will be copied to the top of the stack. When we want to retrieve that value, we first need to be sure that it is on the top of the stack, and then we can specify the storage location as the operand, as in pop rax, after which the value will be moved to rax, and will be removed from the top of the stack. The value below it will now be on top of the stack (as shown in the excise above).

! Since the stack has a LIFO design, when we restore our registers, we have to do them in reverse order. For example, if we push rax and then push rbx, when we restore, we have to pop rbx and then pop rax.

### Syscalls

A syscall is like a globally available function written in C, provided by the Operating System Kernel. A syscall takes the required arguments in the registers and executes the function with the provided arguments. For example, if we wanted to write something to the screen, we can use the write syscall, provide the string to be printed and other required arguments, and then call the syscall to issue the print.

There are many available syscalls provided by the Linux Kernel, and we can find a list of them and the syscall number of each one by reading the unistd_64.h system file:

$ cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h

### Syscall Function Arguments

To use the write syscall, we must first know what arguments it accepts. To find the arguments accepted by a syscall, we can use the man -s 2 command with the syscall name from the above list:

$ man -s 2 write

ssize_t write(int fd, const void *buf, size_t count);

We see that the syscall function expects 3 arguments:

- File Descriptor fd to be printed to (usually 1 for stdout)
- The address pointer to the string to be printed
- The length we want to print

Tip: The -s 2 flag specifies syscall man pages. We can check man man to see various sections for each man page.

### Syscall calling convention

Now that we understand how to locate various syscall and their arguments let's start learning how to call them. To call a syscall, we have to:

1.   Save registers to stack
2.    Set its syscall number in rax
3.    Set its arguments in the registers
4.    Use the syscall assembly instruction to call it


We usually should save any registers we use to the stack before any function call or syscall. However, as we are running this syscall at the beginning of our program before using any registers, we don't have any values in the registers, so we should not worry about saving them.

#### Syscall Number
Let's start by moving the syscall number to the rax register. As we saw earlier, the write syscall has a number 1, so we can start with the following command:

mov rax, 1

Now, if we reach the syscall instruction, the Kernel would know which syscall we are calling.

#### Syscall Arguments

Next, we should put each of the function's arguments in its corresponding register. The x86_64 architecture's calling convention specifies in which register each argument should be placed (e.g., first arg should be in rdi). All functions and syscalls should follow this standard and take their arguments from the corresponding registers.


|Description |	64-bit Register |	8-bit Register|
|--------|---------------|---------|
Syscall Number/Return value |	rax 	|al
Callee Saved |	rbx |	bl|
1st arg |	rdi |	dil
2nd arg |	rsi |	sil
3rd arg |	rdx |	cl
4th arg |	rcx |	bpl
5th arg |	r8 	|r8b
6th arg |	r9 	|r9b


As we can see, we have a register for each of the first 6 arguments. Any additional arguments can be stored in the stack (though not many syscalls use more than 6 arguments.).

!! Note: rax is also used for storing the return value of a syscall or a function. So, if we were expecting to get a value back from a syscall/function, it will be in rax.

With that, we should know our arguments and in which register we should store them. Going back to the write syscall function, we should pass: fd, pointer, and length. We can do so as follows:

    rdi -> 1 (for stdout)
    rsi -> 'Fibonacci Sequence:\n' (pointer to our string)
    rdx -> 20 (length of our string)


We can use mov rcx, 'string'. However, we can only store up to 16 characters in a register (i.e., 64 bits), so our intro string would not fit. Instead, let's create a variable with our string (as we learned in the Assembly File Structure section), similarly to what we did with the Hello World program:


    global  _start

    section .data
        message db "Fibonacci Sequence:", 0x0a


Note how we added 0x0a after our string, to add a new line character.

The message label is a pointer to where our string will be stored in the memory. So, we can use it as our second argument. 

    mov rax, 1       ; rax: syscall number 1
    mov rdi, 1      ; rdi: fd 1 for stdout
    mov rsi,message ; rsi: pointer to message
    mov rdx, 20      ; rdx: print length of 20 bytes


! Tip: If we ever needed to create a pointer to a value stored in a register, we can simply push it to the stack, and then use the rsp pointer to point to it.







### Exit Syscall

If our program exits with a segmentation fault,  its because we are ending our program abruptly, without going through the proper procedure of exiting programs in Linux, by calling the exit syscall and passing an exit code.

First, we need to find the exit syscall number, as follows:

```
$ grep exit /usr/include/x86_64-linux-gnu/asm/unistd_64.h

#define __NR_exit 60
#define __NR_exit_group 231

```


## Procedures

A procedure (sometimes referred to as a subroutine) is usually a set of instructions we want to execute at specific points in the program. So instead of reusing the same code, we define it under a procedure label and call it whenever we need to use it. This way, we only need to write the code once but can use it multiple times. Furthermore, we can use procedures to split a larger and more complex code into smaller, simpler segments.

### CALL/RET

When we want to start executing a procedure, we can call it, and it will go through its instructions. The call instruction pushes (i.e., saves) the next instruction pointer rip to the stack and then jumps to the specified procedure.

Once the procedure is executed, we should end it with a ret instruction to return to the point we were at before jumping to the procedure. The ret instruction pops the address at the top of the stack into rip, so the program's next instruction is restored to what it was before jumping to the procedure.

The ret instruction plays an essential role in Return-Oriented Programming (ROP), an exploitation technique usually used with Binary Exploitation.


|Instruction |	Description |	Example|
|------------|-------------|-----------|
call |	push the next instruction pointer rip to the stack, then jumps to the specified procedure 	|call printMessage
ret 	|pop the address at rsp into rip, then jump to it |	ret


! Note: It is important to understand the line-based execution flow of assembly. If we don't use a ret at the end of a procedure it will simply execute the next line. Likewise, had we returned at the end of our Exit function, we would simply go back and execute the next line, which would be the first line of printMessage.


## Functions

Functions are a form of procedures. However, functions tend to be more complex and should be expected to use the stack and all registers fully. So, we can't simply call a function as we did with procedures. Instead, functions have a Calling Convention to properly set up before being called.


There are four main things we need to consider before calling a function:

1.    Save Registers on the stack (Caller Saved)
2.    Pass Function Arguments (like syscalls)
3.    Fix Stack Alignment
4.    Get Function's Return Value (in rax)


This is relatively similar to calling a syscall, and the only difference with syscalls is that we have to store the syscall number in rax, while we can call functions directly with call function. Furthermore, with syscall we don't have to worry about Stack Alignment.

### Writing Functions

When it comes to writing a function, there are different points to consider, which are:

1.    Saving Callee Saved registers (rbx and rbp)
2.    Get arguments from registers
3.    Align the Stack
4.    Return value in rax


As we can see, these points are relatively similar to the caller points. The caller is setting up things, and then the callee (i.e., receiver) should retrieve those things and use them. These points are usually made at the beginning, and the end of the function and are called a function's prologue and epilogue. They allow functions to be called without worrying about the current state of the stack or the registers.


### Using External Functions

The libc library of functions used for C programs provides many functionalities that we can utilize without rewriting everything from scratch. The printf function in libc accepts the printing format, so we can pass it the current Fibonacci number and tell it to print it as an integer, and it'll do the conversion automatically. Before we can use a function from libc, we have to import it first and then specify the libc library for dynamic linking when linking our code with ld.

### Importing libc Functions

global  _start
extern  printf


Let's define a new procedure, printFib, to hold our function call instructions. The very first step is to save to the stack any registers we are using, which are rax and rbx, as follows:

printFib:
    push rax        ; push registers to stack
    push rbx
    ; function call
    pop rbx         ; restore registers from stack
    pop rax
    ret


First, we need to find out what arguments are accepted by the printf function by using man -s 3 for library functions manual (as we can see in man man):

```
$ man -s 3 printf

...SNIP...
       int printf(const char *format, ...);

```

the function takes a pointer to the print format (shown with a *), and then the string(s) to be printed.

First, we can create a variable that contains the output format to pass it as the first argument. The printf man page also details various print formats. We want to print an integer, so we can use the %d format, as follows:

```
global  _start
extern  printf

section .data
    message db "Fibonacci Sequence:", 0x0a
    outFormat db  "%d", 0x0a, 0x00


```

This can be our first argument, and rbx as our second argument, which printf will place as %d. So, let's move both arguments to their respective registers, as follows:

```
printFib:
    push rax            ; push registers to stack
    push rbx
    mov rdi, outFormat  ; set 1st argument (Print Format)
    mov rsi, rbx        ; set 2nd argument (Fib Number)
    pop rbx             ; restore registers from stack
    pop rax
    ret
    
```

### Stack Alignment

Whenever we want to make a call to a function, we must ensure that the Top Stack Pointer (rsp) is aligned by the 16-byte boundary from the _start function stack.

This means that we have to push at least 16-bytes (or a multiple of 16-bytes) to the stack before making a call to ensure functions have enough stack space to execute correctly. This requirement is mainly there for processor performance efficiency. Some functions (like in libc) are programed to crash if this boundary is not fixed to ensure performance efficiency.

This may be a bit confusing, but the critical thing to remember is that we should have 16-bytes (or a multiple of 16) on top of the stack before making a call. We can count the number of (unpoped) push instructions and (unreturned) call instructions, and we will get how many 8-bytes have been pushed to the stack.

### Dynamic Linker

We can now assemble our code with nasm. When we link our code with ld, we should tell it to do dynamic linking with the libc library. Otherwise, it would not know how to fetch the imported printf function. We can do so with the -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2 flags, as follows:

```
$ nasm -f elf64 fib.s &&  ld fib.o -o fib -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2
```


## Shellcoding

A shellcode is the hex representation of a binary's executable machine code.

Modern x86_64 systems may have protections against loading shellcodes into memory. This is why x86_64 binary exploitation usually relies on Return Oriented Programming (ROP), which also requires a good understanding of the assembly language and computer architecture covered in this module.

Furthermore, some attack techniques rely on infecting existing executables (like elf or .exe) or libraries (like .so or .dll) with shellcode, such that this shellcode is loaded into memory and executed once these files are run. Another advantage of using shellcodes in pentesting is the ability to directly execute code into memory without writing anything to the disk, which is very important for reducing our visibility and footprint on the remote server.


### Assembly to Machine Code

Each x86 instruction and each register has its own binary machine code (usually represented in hex), which represents the binary code passed directly to the processor to tell it what instruction to execute (through the Instruction Cycle.)

Furthermore, common combinations of instructions and registers have their own machine code as well. For example, the push rax instruction has the machine code 50, while push rbx has the machine code 53, and so on. When we assemble our code with nasm, it converts our assembly instructions to their respective machine code so that the processor can understand them.

Remember: Assembly language is made for human readability, and the processor cannot understand it without being converted into machine code. We will use pwntools to assemble and disassemble our machine code, as it is an essential tool for Binary Exploitation, and this is an excellent opportunity to start learning it. First, we can install pwntools with the following command (it should be already installed in PwnBox):

$ sudo pip3 install pwntools

Now, we can use pwn asm to assemble any assembly code into its shellcode, as follows:

$ pwn asm 'push rax'  -c 'amd64'

! Note: We used the -c 'amd64' flag to ensure the tool properly interprets our assembly code for x86_64

### Extract Shellcode
A binary's shellcode represents its executable .text section only, as shellcodes are meant to be directly executable. To extract the .text section with pwntools, we can use the ELF library to load an elf binary, which would allow us to run various functions on it. So, let's run the python3 interpreter to understand better how to use it. First, we'll have to import pwntools, and then we can read the elf binary, as follows:

```

$ python3

>>> from pwn import *
>>> file = ELF('helloworld')


```

Now, we can run various pwntools functions on it, which we can read more about here  (   https://docs.pwntools.com/en/stable/elf/elf.html   ). We need to dump machine code from the executable .text section, which we can do with the section() function, as follows:

```
>>> file.section(".text").hex()
'48be0020400000000000bf01000000ba12000000b8010000000f05b83c000000bf000000000f05'

```

or 

```

#!/usr/bin/python3

import sys
from pwn import *

context(os="linux", arch="amd64", log_level="error")

file = ELF(sys.argv[1])
shellcode = file.section(".text")
print(shellcode.hex())


```

Another (somewhat less reliable) method to extract the shellcode would be through objdump. We can write the following bash script into shellcoder.sh and use it to extract the shellcode if ever we can't use the first script:


```

#!/bin/bash

for i in $(objdump -d $1 |grep "^ " |cut -f2); do echo -n $i; done; echo;

```

### Loading Shellcode

 The shellcode we extracted above does not meet the Shellcoding Requirements we'll discuss in the next section, and so it won't run.

we'll need a shellcode, that meets all Shellcoding Requirements


```
$ python3

>>> from pwn import *
>>> context(os="linux", arch="amd64", log_level="error")
>>> run_shellcode(unhex('4831db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05')).interactive()

Hello HTB Academy!

```

### Debugging Shellcode

We can always run our shellcode with loader.py, and then attach its process to gdb with gdb -p PID. However, this will only work if our process does not exit before we attach to it. So, we will instead build our shellcode to an elf binary and then use this binary with gdb like we've been doing throughout the module.


We can use pwntools to build an elf binary from our shellcode using the ELF library, and then the save function to save it to a file:

```
ELF.from_bytes(unhex('4831db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05')).save('helloworld')

```

To make it easier to use, we can turn the above into a script and write it to assembler.py:

```
#!/usr/bin/python3

import sys, os, stat
from pwn import *

context(os="linux", arch="amd64", log_level="error")

ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
os.chmod(sys.argv[2], stat.S_IEXEC)

```


There are other methods to build our shellcode into an elf executable. We can add our shellcode to the following C code, write it to a helloworld.c, and then build it with gcc (hex bytes must be escaped with \x):

```

#include <stdio.h>

int main()
{
    int (*ret)() = (int (*)()) "\x48\x31\xdb\x66\xbb\...SNIP...\x3c\x40\x30\xff\x0f\x05";
    ret();
}

```

However, this method is not very reliable for a few reasons. First, it will wrap the entire binary in C code, so the binary will not contain our shellcode, but will contain various other C functions and libraries. This method may also not always compile, depending on the existing memory protections, so we may have to add flags to bypass memory protections, as follows:

```

$ gcc helloworld.c -o helloworld -fno-stack-protector -z execstack -Wl,--omagic -g --static

```

### Shellcoding Requirements

As we briefly mentioned in the previous section, not all binaries give working shellcodes that can be loaded directly to the memory and run. This is because there are specific requirements a shellcode must meet. Otherwise, it won't be properly disassembled on runtime into its correct assembly instructions.

This is what will happen if our assembly code is not shellcode compliant and does not meet the Shellcoding Requirements. To be able to produce a working shellcode, there are three main Shellcoding Requirements our assembly code must meet:

1.    Does not contain variables
2.    Does not refer to direct memory addresses
3.    Does not contain any NULL bytes 00


#### Remove Variables

A shellcode is expected to be directly executable once loaded into memory, without loading data from other memory segments, like .data or .bss. This is because the text memory segments are not writable, so we cannot write any variables. In contrast, the data segment is not executable, so we cannot write executable code.

So, to execute our shellcode, we must load it in the text memory segment and lose the ability to write any variables. Hence, our entire shellcode must be under '.text' in the assembly code.

There are many techniques we can use to avoid using variables, like:

1.    Moving immediate strings to registers
2.    Pushing strings to the Stack, and then use them


In the above code, we may move our string to rsi, as follows:

```
    mov rsi, 'Academy!'
```

However, a 64-bit register can only hold 8 bytes, which may not be enough for larger strings. So, our other option is to rely on the Stack by pushing our string 16-bytes at a time (in reverse order), and then using rsp as our string pointer, as follows:

```
    push 'y!'
    push 'B Academ'
    push 'Hello HT'
    mov rsi, rsp
    
```

However, this would exceed the allowed bounds of immediate strings push, which is a dword (4-bytes) at a time. So, we will instead move our string to rbx, and then push rbx to the Stack, as follows:

```

    mov rbx, 'y!'
    push rbx
    mov rbx, 'B Academ'
    push rbx
    mov rbx, 'Hello HT'
    push rbx
    mov rsi, rsp
    
```



Note: Whenever we push a string to the stack, we have to push a 00 before it to terminate the string. However, we don't have to worry about that in this case, since we can specify the print length for the write syscall.


### Remove Addresses

We are now not using any addresses in our above code since we removed the only address reference when we removed our only variable. However, we may see references in many cases, especially with calls or loops and such. So, we must ensure that our shellcode will know how to make the call with whatever environment it runs in.

To be able to do so, we cannot reference direct memory address (i.e. call 0xffffffffaa8a25ff), and instead only make calls to labels (i.e. call loopFib) or relative memory addresses (i.e., call 0x401020).

Luckily, throughout this module, we have only been making calls to labels to ensure that we learn how to write code that is easily shellcoded. If we are making a call to a label, nasm will automatically change this label into a relative address, which should work with shellcodes.

If we ever had any calls or references to direct memory addresses, we can fix that by:

    Replacing with calls to labels or rip-relative addresses (for calls and loops)
    Push to the Stack and use rsp as the address (for mov and other assembly instructions)

If we are efficient while writing our assembly code, we may not have to fix these types of issues.


### Remove NULL



NULL characters (or 0x00) are used as string terminators in assembly and machine code, and so if they are encountered, they will cause issues and may lead the program to terminate early. So, we must ensure that our shellcode does not contain any NULL bytes 00.

This commonly happens when moving a small integer into a large register, so the integer gets padded with an extra 00 to fit the larger register's size.

For example, in our code above, when we use mov rax, 1, it will be moving 00 00 00 01 into rax, such that the number size would match the register size. We can see this when we assemble the above instruction:


```
$ pwn asm 'mov rax, 1' -c 'amd64'

48c7c001000000

```

To avoid having these NULL bytes, we must use registers that match our data size. For the previous example, we can use the more efficient instruction mov al, 1, as we have been learning throughout the module. However, before we do so, we must first zero out the rax register with xor rax, rax, to ensure our data does not get mixed with older data. Let's see the shellcode for both of these instructions:

$ pwn asm 'xor rax, rax' -c 'amd64'

4831c0
$ pwn asm 'mov al, 1' -c 'amd64'

b001

As we can see, not only does our new shellcode not contain any NULL bytes, but it is also shorter, which is a very desired thing in shellcodes.

We can start with the new instruction we added earlier, mov rbx, 'y!'. We see that this instruction is moving 2-bytes into an 8-byte register. So, to fix it, we will first zero-out rbx, and then use the 2-byte (i.e. 16-bit) register bx, as follows:

```
    xor rbx, rbx
    mov bx, 'y!'
    
```




# Operations 

## Save 4 register`s values with shrd/shld 


```
!Save ax,bx,cx,dx to rdi

shrd  rdi , rax , 16
shrd  rdi , rbx , 16
shrd  rdi , rcx , 16
shrd  rdi , rdx , 16


! retrieve the values

shld rdx , rdi , 16
shl  rdi , 16
shld rcx , rdi , 16
shl  rdi , 16
shld rbx , rdi , 16
shl  rdi  , 16
shld rax , rdi , 16

```


## MUL and IMUL

### One operand version
|operand1 | Implied Operand | Value is stored to |
|----------|----------------|--------------------|
|byte      | al             | ax | 
| word      |    ax |          dx:ax|
| dword     |  eax         |  edx:eax             |
|qword      | rax           | rdx:rax             |



 So for example

```
imul ebx ; is a 32 bit dword (signed multiplication)

; so its calculating  ebx x eax 
; and stores 
; 32 low bits in eax 
; and 32 high bits in edx

```

### Two operand version

! First operand must be a register

```
imul op1 , op2      ; op1 = op1 x op2

or

imul op1 , op2 , op3  ; op1 = op2 x op3

```

